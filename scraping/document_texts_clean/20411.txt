detailsdistribution, posting, or copying of this pdf is strictly prohibited without written permission of the national academies press. (request permission) unless otherwise indicated, all materials in this pdf are copyrighted by the national academy of sciences.copyright © national academy of sciences. all rights reserved.the national academies pressvisit the national academies press at nap.edu and login or register to get:œ œ 10% off the price of print titlesœ special offers and discountsget this bookfind related titlesthis pdf is available at sharecontributorshttp://nap.edu/20411an undergraduate course on operating systems principles41 pages | 8.5 x 11 | paperbackisbn 9780309342674 | doi 10.17226/20411cosine committee; commission on education; national academy of engineeringan undergraduate course on operating systems principlescopyright national academy of sciences. all rights reserved.cosine task force publications: task force i task force ii task force ill task force iv task force v task force vi task force vii task force v ill some specifications for a computeroriented first course in electrical engineering. september, 1968. an undergraduate electrical engineering course on computer organization. october, 1968. some specifications for an undergraduate course in digital subsystems. november, 1968. an undergraduate computer engineering option for electrical engineering. january, 1970. impact of computers on electrical engineering educationa view from industry. september, 1969. digital systems laboratory courses and laboratory development. march, 1971 in preparation. an undergraduate course on operating systems principles. june, 1971. available at no charge on request from: commission on education national academy of engineering 2101 constitution avenue, n.w. washington, d.c. 20418 tel: (202) 9611417 these reports have been prepared under the auspices of the commission on education of the national academy of engineering. commission policy is to encourage the exploration of new ideas in engineering education. the commission has been kept informed of the discussions of the cosine committee but has taken no position on its reports or recommendations. the work of the cosine committee and these publications are supported in part by the national science foundation under contract nsfc310, task order no. 161. an undergraduate course on operating systems principlescopyright national academy of sciences. all rights reserved.cessed information resides in fast access memory. as multi· programming has become more important, and as more im· portance has been attached to ease of programming, so the trend has been toward management of memory by the oper· ating system rather than by user programs. these issues are treated in the context of current memory technology in module 4. modular programming increases the ability for a user to construct larger programs from component subprograms without requiring that the user know the internal operation of the components. the extent to which a system can sup· port modular programming will depend on its ability to deal with names (identifiers) in varying contexts and on its ability to allow shared access to information, both abilities being related intimately to the conventions used for handling names. these issues are the subject of module 5. the need to protect arises as soon as a computer system holds procedures and data belonging to more than one in· dividual. it must not be possible for one user's actions to disrupt or corrupt service to other users. access to proce· du res and data, especially if confidential or proprietary, must be permitted only with appropriate authorization. the principles underlying implementations of protection form the subject matter of module 6. resource allocation is concerned with obtaining optimal utilization of system resources (processor, memory, auxil· iary storage, and so on) toward meeting the system's oper· ating objectives (throughput, response times, minimum cost, and so on). models of program behavior and the use of statistical analysis are important to an understanding of resource allocation. this is the subject of module 7. there remain certain issues concerning computer system operation and design, issues that have not yet been analyzed definitively in the literature but nonetheless are very impor· tant. these include reliability, design methodologies, imple· mentation strategies, and performance evaluation. they are the subject of module 8. relation to previous cosine work and acm curriculum 68 the course proposed in this report is designed as an ad· vanced course to follow basic courses on computer organiza· tion and programming languages. the cosine committee report of september, 1967 recommended that the operating systems course be regarded as elective. in contrast, task force viii recommends that this course be considered, as much as possible, an integral part of a computer science program (whether it is a core course will depend on the needs and resources of a given department). we are able to recommend such an increase in the importance of this course because there now exists a much sounder conceptual basis for teaching the principles of operating systems than existed as recently as 1969. with respect to the acm computer science curriculum 68 (comm. acm 11, 3, march 19681, it was not the inten· tion of cosine to "implement" any course in acm's cur· riculum. although the cosine course is related to acm's course 14 (systems programming), it differs in at least three significant ways. first, the acm course description is an outline, whereas the cosine course is a detailed specifica· second, the acm outline suggests a descriptive, "case2 study" approach, whereas ours is organized along conceptual lines. third, acm emphasizes the techniques of systems pro· gramming, whereas cosine's emphasis is on the principles of system organization and operation. this shift in emphasis has been possible because the members of the task force have been associated closely with current work on advanced operating systems, the conceptualization of which has taken place since the preparation of the acm report. the material outlined in the background section of this report is organized along the lines of courses 12 (programming languages) and 13 (computer organization) of the acm cur· riculum. familiarity with a course such as 11 (data structures) is desirable though not necessary. it must be emphasized that these acm courses cover mcuh more than is required as background for this course. it must be emphasized also that these particular acm courses are cited as examples of possible background courses; the implementation of this course does not depend on prior implementation of the acm courses. project the committee recommends strongly that the tual and theoretical material outlined in this report be ac· companied by a reasonably detailed study of some particular operating system embodying these concepts. although the abstractions used in the various modules of this report serve to provide the student with an understanding of the princi· pal components of an operating system, they will do little to instill insight into how the different mechanisms mesh into a working whole or into how complexity is engendered. the instructor may wish to draw examples from a number of different systems, but the committee believes that the students should be given the opportunity to understand one complete design. the system to be studied in depth should not be too large and it should have some coherence of design, so that the student will not be overburdened with irrelevant detail. on the other hand, the system should have sufficient scope to illustrate the essential ideas of the course: a programming batch system would, for example, be factory. finally, the system should be documented ade· quately, so that recourse to the operating system code is not necessary for a detailed understanding of its implementation. the committee is aware of only a few systems that meet these requirements. these are listed below, together with citations of their documentation and addresses from which the documentation can be obtained. since the supplies of the documentation are limited, the committee suggests that the instructor obtain one copy and arrange with the source of the document for permission to reproduce enough copies for his class. 1. rc4000 software: multiprogramming system. (p. b. hansen, ed.) a/s regnecentralen copenhagen, denmark 2. cal 6400 time sharing system director, computer center university of california berkeley, california 94720 an undergraduate course on operating systems principlescopyright national academy of sciences. all rights reserved.3. clics: classroom information and computing system (a simplified version of multics), rpt. mac·tr80. project mac document room 545 technology square cambridge, mass. 02139 using the references in order to avoid overburdening a prospective instructor or his students, we have paid a great deal of attention to limiting the size of our bibliography. a citation has been included only if it satisfies, in our opinion, one or more of three criteria: 1) it is most relevant to the discussion in the modules, 21 it is the only citation available, or 3) it contains clear exposition and a good bibliography of its own. the bibliography appears at the end of the report. each citation is of the form [i, name] where i is the index key in the bibli· ography and "name" designates the author or authors. at the end of each module we have included a reference list guide which summarizes the citations in that module to· gether with indicators of three kinds: type: cconceptual, 0descriptive, eexample, ttutorial level: sstudent, aadvanced student, 1instructor importance: an integer 15 indicating the relative im· portance of the reference to the module; integer 1 is most important, 5 least. thus, if [i, name] is flagged with (cd,a,3), it is both ceptual and descriptive, appropriate reading for advanced students, and of importance rank 3. a given citation may appear in several modules with different indicators, as appropriate for that module. 3 an undergraduate course on operating systems principlescopyright national academy of sciences. all rights reserved.module 0 background the student of computer operating systems should have a good understanding of 1) programming languages, 2) puter processor organization, 3) memory organization and 4) data structures. the discussion to follow indicates the required level of maturity in these areas. though not all the material is essential, if any significant part is unfamiliar to the student he is not prepared for the course. deficiencies in background can be remedied through a selfstudy review at the beginning of the course. 0.1 programming languages it is essential that the student be experienced in bolic programming and be familiar with important language features such as expressions, data types, data structures, procedure application, formal and actual parameters, and recursion. he should understand the notion of program modularity, the idea of subprograms which can be used without knowledge of their internal structure or operation. he should also understand how source language statements and machine code are related; in particular he should under· stand the functions of the assembly, loading, and execution of a program, from the user's standpoint. discussions of these topics can be found in (40,hellerman, ch. 2) and (33, gear, chs. 34). 0.2 processor organization the student should be familiar with at least one computer processor and its instruction set. his understanding should embrace hardware functions more deeply than implementa· tion details; it should encompass how processor features, such as index registers and indirect addressing, relate to the implementation of programming language features. see (40, hellerman, secs. 8.18.6) , (33, gear, ch. 2) and (5, bell] . it is particularly important that the student have a basic knowledge of interrupt mechanisms. (40, hellerman, sec. 8.12), (33, gear, sec. 2.5), and (5, bell]. this should in· elude the types of interrupts commonly provided, the trol (enable, disable) of interrupts, and the distinction be· tween the arming and firing of an interrupt. it includes com· prehensiqn of the distinction between interrupts originating in other processors (e.g., 1/0 interrupts) and traps or faults originating in the processor itself (e.g., invalid instructions). 0.3 memory organization the student should be familiar with the common memory types (integrated circuit, core, mass or bulk core, disk, etc.) and appreciate relative costs, capacities, and access times (40, hellerman, secs. 3.13.2), (33, gear, secs. 6.16.4), (5, bell], and (75, sharpe]. he should understand the tinction between sequential access and random access devices, especially in terms of latency time characteristics. he should understand the properties of associative memory. the student should understand that a channel is a purpose processor, and how communications between cen· tral processors and channels are effected. (40, hellerman, sec. 8.13), (33, gear, sec. 6.5), and (5, bell]. 4 0.4 data structures the student must understand the most common types of data structures and their representations using both sequen· tial and linked allocation; these include stacks, queues and arrays (50, knuth]. he should be familiar also with hash tables (63, morris] . module 0: background topic outline 0.1 program"'ing languages working knowledge of symbolic progamming features data types variables expressions procedure application formal parameters actual parameters recursive procudures machine language representation of source language statements simplified program "history" assembly or compilation loading execution 0.2 processor organization machine language concepts relationships of processor features to programming language features implicit control data movement data transformation program control addressing index registers indirect addressing 0.3 memory organization hierarchy of memory typescore, drum, disk, tape and other mass media cost capacity access ti mes concepts of random access, direct access and sequential access devices associative memories 1/0 control, channels, cpu communication 0.4 data structures stacks, queues, arrays sequential allocation linked allocation hash tables an undergraduate course on operating systems principlescopyright national academy of sciences. all rights reserved.module 0: background reference list guide types: c conceptual, d descriptive, e example, ttutorial level: s student, a advanced student, i instructor key author ill!! level i m22rtance 5 bell and newell t a 1 33 geer t s 1 40 hellerman t s 2 50 knuth t s 1 63 morris t s 1 75 sharpe t a 2 5 an undergraduate course on operating systems principlescopyright national academy of sciences. all rights reserved.module 1introduction 1.1 forms of systems already, most students will have heard of systems which use operating system techniques extensively. these include: 1) realtime control systems: reservations, telephone switch· ing, process control; 2) data base systems: management formation, credit reporting; 3) general purpose programming systems: batch, multiprogramming, timesharing; and 4) computer networks. by considering characteristics these systems have in com· mon, and issues which arise over and over again in designing or understanding them, this module provides an overview of the course. the common characteristics and issues may be used as touchstones by which to motivate, and against which to judge, the ideas and techniques forming the body of the course. 1.2. views of a system almost as varied as the types of systems are the views programmers and designers hold of them. these views in· elude: 1) the system defines an extended language .2) the system defines an extended machine, e.g., a "virtual ma· chine." 3) the system creates an environment for efficient program execution. 4) the system is an information man· agement system. the instructor can find many other ples of viewpoints as he peruses the literature. despite the wide variation in types of systems and views about them, they have an important and extensive set of common char· acteristics. these are discussed next. 1.3. common characteristics the four types of systems listed above all employ some form of concurrency; for example, many reservation agents may be engaged in transactions at one time, many sub· systems of a chemical plant must be controlled, printing and computing are overlapped in a simple batchprocessing system, inputoutput for many jobs is processed concur· rently in a multiprogramming system. in some cases the concurrent activities are almost independent (as in multi· programming), in others they are related through a shared data base (reservations), in still others there are more com· plex interactions (inputoutput overlap in a single job, chem· ical processes). when the activities are independent, rency is the concern of the underlying system; as they become more closely related, explicit recognition of the concurrency must appear in their implementation. there are no clear dividing lines, and methods for handling con· currency must be available to both system and users. closely related to concurrency is sharing of information. examples of information shared among many users include: a fortran compiler, the records of a reservation or credit reporting system, a table of stock prices accessed by security analysts in a timesharing system, or channel commands and status information shared between an inputoutput channel and a central processor. sharing begets unique problems, the most important one being that concurrent attempts to access and modify data can lead to races or to use of data while it is in an inconsistent state. 6 closely related to sharing is longterm storage of data in a computer system. in fact, all the examples of sharing cited above (except the last) are also examples of longterm storage. three major problems must be solved in an implementation of longterm storage: 1) maintaining records of the location of data, and communicating locationinformation to all users (file systems and naming). 21 controlling access to data (privacy and protection). 3) guaranteeing survival of the data despite system failures (reliability). a property resulting from concurrency and data storage is nondeterminacy. on the one hand, a batchprocessing tem for fortran program is (or should be) determinate in the sense that it will give the same results every time it is run with the same inputs. on the other hand, a transaction with a reservation system is nondeterminate, since it may be in a race with another transaction for the last available space, and since its effect may depend on the state of the data base. sharing of resources, contrasted with sharing of tion, is another important characteristic of most computer systems. multiprogramming systems share memory, time sharing systems share the central processor, all systems share channels and disk storage. this kind of sharing is motivated by economics, i.e., the desire to reduce costs by sharing equipment. it raises special problems in protection and resource allocation. many systems employ various types of modularity in their design and operation. here, modularity means the ability to construct complex systems from separately designed parts. it appears in several forms, particularly programming modu· larity and operating system functional modularity. a final, very important characteristic of many real time, data base, and general purpose systemsand of all computer networksis remote conversational access. conversation requires a system to respond promptly and to switch (multi· plex) its attention among users at a high rate, i.e., support a high degree of concurrency. remote access requires it to interface with the telephone system and to handle large numbers of slow terminals. 1.4. major issues the following list of words suggests some important concerns which intersect all the functional divisions of section 1.1: generality reliability efficiency complexity compatibility except for generality, unfortunately, these are issues whose importance is not yet supported by any useful conceptual framework. as a result, we have relegated them to an inferior position at the end of the course; we emphasize that this relegation reflects the absence of teachable material and not the importance of the issues. a few general remarks about these issues are included below. an undergraduate course on operating systems principlescopyright national academy of sciences. all rights reserved.generality escapes the observations of the preceding paragraph at least to some extent. indeed, all the tions in the body of the course can be viewed as attempts to increase the generality of the basic mechanisms in oper· ating systems and thus to give them wider applicability, both as aids to understanding and as tools for programming. reliability can be considered under several headings: 1) coping with hardware unreliability, by reconfiguration and recovery from detected failures such as parity errors. 2) ing programs reliable by making their structure and faces very clear, or by proving their correctness. 3) dealing with software errors by redundancy and recovery. some examples of redundancy should be mentioned, e.g. the use of doubly linked lists or of 'headers' or 'home addresses' on disk records. the idea of a recovery procedure may also be clarified by an example, such as a disk file backup and reloading system. efficiency is partly a matter of implementation detail; as such, it should be brought out in the study of the example system. it is, however, far more a matter of conceptual nization and algorithms design. a significant reason for this (though by no means the only one) is the reduction in tem size and overhead which results from good design. complexity is the enemy of reliability, and often of efficiency and generality as well. it is an inescapable aspect of, and indeed often the reason for, using computers. one interpretation of the purpose of this course is a description of tools for structuring complex processes in comprehensible ways. a casual perusal of the trade literature will reveal the concern of both manufacturers and users with compatability. module 1: introduction topic outline 1.1. forms of computer system (software/hardware composites) real time control systems data base systems general purpose programming systems computer networks and utilities 1.2. views of system defining an extended language or virtual machine establishing an environment for program execution information management system 1.3. common characteristics concurrency sharing nondeterminate long term storage (data bases) modularity conversational remote access 1.4. issues reliability generality efficiency complexity compatibility 7 module 1: introduction reference list guide types: c conceptual, d descriptive, e example, ttutorial level: s student, a advanced student, i instructor author ill!! level i m(!2rtance corbato' and vyssotsky ""a 2 13 d 14 crisman d i 3 30 fano and corbato' d s 1 69 parkhill d a 2 75 sharpe d i 3 85 wilkes (chs 1,2) d s 1 an undergraduate course on operating systems principlescopyright national academy of sciences. all rights reserved.module 2 procedure implementation a theme which reappears throughout the course is: a primary purpose of an operating system is providing an ef· ficient and convenient environment for executing programs. this module examines this view in some detail. the most fundamental aspects of procedure implementation are dis· cussed here. further aspects affecting the convenience with which program modules can be combined are treated in module 5. 2.1 abstract model of a procedure a "procedure in execution" consists of: 1) instruction code representing an algorithm, 2) an activation record de· fining the local environment of the procedure, and 3) the nonlocal environment of the procedure. the total environ· ment of a given procedure comprises the data structures and procedures that are currently accessible to the given proce· dure. the local environment of a given procedure comprises the local working storage for the current activation of the procedure. the "activation record," which is created as part of the procedure activation, will in general contain the local working storage, the values or addresses of actual parameters, the return address, and pointers to the remainder of the environment. it is important to note that the total environ· ment is determined by the context in which the procedure is activated. since a procedure may be activated at different points in a computation, the local and nonlocal environ· ments will in general be different for each activation. there are three basic problems that an implementation of procedures must solve. first there must be a mechanism for referencing the nonlocal environment, i.e. nonlocal variables and other procedures. second, there must be a mechanism for activating a procedure, incorporating a way of naming the procedure to be activated, constructing its activation record, and transferring control. third, there must be a mechanism for passing of parameters to the activated procedure. the conceptual model described above should be illus· trated by implementations found in practice. these can be taken from common programming languages familiar to the students. fortran and algol are used as examples in the next two sections. 2.2 example implementation fortran the definition of the fortran programming language gives rise to an especially simple runtime environment (77, standards] . a fortran program consists of a set of one or more disjoint procedures (subroutines). the nonlocal environment of each procedure consists of the other dures and the variables in common. since the addresses of procedure entry points and common variables are known by load time, references and linkages to these items can be resolved at this time before execution begins. since fortran prohibits recursive activations of procedures, the local stor· age of a procedure is permanently allocated and the same locations used for each activation. parameters are passed only by reference (i.e. addresses of parameter storage locations are passed). a common tech· 8 nique is to store the addresses of parameters in the succes· sive storage locations immediately following the subroutine call instruction. since the subroutine call instruction places in the subroutine's return address cell 1 plus its own address, the subroutine can locate its parameters by interpreting the contents of the return address cell as a pointer to the list of parameter addresses. the usual convention for returning control is to execute a jump to the first location following the parameter list. a discussion of the implementation of fortran subroutines can be found in (33,gear]. after having presented the call, return, and parameter· passing mechanisms of fortran, the instructor should review the operation of linking loaders, which combine independently compiled subroutines into a program (59, mccarthy]. 2.3 example implementation algol to complete the discussion, the instructor should present an implementation of procedures which involves recursion, and the associated dynamic storage allocation of space for activation records. for this purpose it is sufficient to con· sider a subset of algol in which the passed parameters are simple variables and the only external names which a procedure may use are those of other procedures. [ 67, naur, et al.] a review of the nested declaration structure of algol and the scope rules for identifiers should be given. since algol permits the recursive use of a procedure, an implementation must permit two or more activations of the same procedure to exist simultaneously. this implies that each activation of the procedure be provided with a distinct activation record. the nesting of procedure activations in algol makes the use of a stack convenient for this pur· pose. each activation record will consist of the return ad· dress, actual parameter information, a pointer to the current activation record of the calling procedure, and the local stor· age for the activated procedure. the first three items can be set up by the calling procedure; the fourth can be done upon entry to the activated procedure so that a variable amount of storage can be allocated (e.g., local arrays can be of variable size). the actual transfer of control is simply a jump to the first location (entry point) in the fixedprogram part of the activated procedure. as in fortran, entry points of pro· cedures will be known at load time. the location of the acti· vation record of the currently executing procedure resides in a system base register or index register, and all local data references are taken relative to the contents of this register. parameters (which we have limited to simple variables) can be passed by name or by value. if a parameter is passed by name it is to be evaluated each time it is used in the pro· cedure, this evaluation being performed in the environment of the calling procedure. in the restricted situation described here, the parameter is a variable in the local data area of the calling procedure; accordingly, a name parameter can be ified by its local address within the activation record of the calling procedure. if the parameter is passed by value, the value of that parameter is copied into the activation record. returning control to the calling procedure consists of delet· an undergraduate course on operating systems principlescopyright national academy of sciences. all rights reserved.ing the activation record from the stack and executing a jump to the return address. at his option, the instructor may extend the discussion to include the algol facility for referencing arbitrary non· local names (not just procedure names). to do so, he will have to introduce the concept of a "static chain" of activa· tion records. the successive entries in this chain are the lexi· cographically enclosing blocks in the algol declaration. (this is contrasted with the dynamic chain," whose sive entries are the activation records in order of activation; the chains may be different, for example, when recursive procedure calls have been made.) a static chain is sary if the only nonlocal names are external procedure names because entry points are known prior to execution; but the addresses of data items within activation records are not known prior to execution. comprehensive treatments of algol implementation can be found in (71, randell) and (81, wegner i . procedure implementations are covered more generally in (25, dennis). module 2: procedure implementation topic outline 2.1. basic concepts pure procedure procedure activations, activation records parameters, formal and actual, value and name environment, local and total local and nonlocal references 2.2. fortran implementation memory arrangement for nonrecursive procedures transfer and return of control passing parameters by reference external references, common locations design and operation of linking subprogram loader 2.3. algol implementation block structure, scope of names recursive procedures, activation record stack passing parameters static and dynamic chains module 2: procedure implementation reference list guide !s!y 25 33 59 67 71 77 81 types: c conceptual, d descriptive, e example, ttutorial level: s student, a advanced student, i instructor author iii!! level lmeortance dennis et al. ct i 1 gear t i 1 mccarthy ct i 2 naur et al. d i 3 randell and russell ot i 2 standards (asai d i 3 wegner t a 1 9 an undergraduate course on operating systems principlescopyright national academy of sciences. all rights reserved.module 3 processes the study of operating systems adds another dimension to the design of computer programs, in the form of rent programming." it is desirable to add this dimension for at least two reasons: 1. the demand for a short response time which can be met by means of various forms of multiprogramming and multiprocessing; 2. efficient utilization of equipment, which can be realized by means of concurrent activity between the central machine and its peripheral devices. although present hardware technology makes concurrent activity feasible, it is the task of the operating system de· signer to write the programs that will effect it. this task sep· arates quite naturally into two parts: writing the programs for each of the individual activities, and designing the inter· actions between them. a method for dealing with these two aspects, which has proved effective, is to build a system as a set of sequential processes that interact at welldefined events (see for instance descriptions of multics [13, corbato], the [28, dijkstra], rc4000 [36, hansen)). instead of stricting it to be associated with a hardware processor, a proc· ess should be regarded as an activity that executes one of the system functions, an activity which the designer wishes to be performed conceptually in parallel with other activities. taking this point of view, a hardware processor is considered as a resource which is needed by a process to carry its activity forward in real time and which could be shared among esses. "parallel activity" is then interpreted in the following sense: when a snapshot is taken of the system, several esses may be found somewhere between their starting point and their points of completion. the foregoing outlines the motivation for studying parallel process as part of operating systems. the previous modules have provided the ingredients for starting a study of ating systems; the treatment of concurrent programming is the beginning of the study proper. the remainder of this module concentrates on the interaction of processes and the tools that enable parallel processes to share information. appendix m3b contains problems of the type often encountered in concurrent programming. 3. 1 parallelism in an operating system almost independent processes operating in parallel exist already in the given hardware consisting of a central machine and its peripheral devises. processes designed in software should also be considered as almost independent and nothing should be assumed about their relative speeds (see the lecture notes [27, dijkstra) ) . at his option, the instructor should devote some attention to an abstract description of a process as a set of histories, in which a history is a sequence of states s; = (p;,m;j comprising a processor state p; and a memory state m; (see the lecture notes [25, dennis, chapter 7) ). in terms of an abstract de· scription the major issues of concurrent programming mon state variables, mutual exclusion, abstraction, deterministic processes, synchronization and deadlocks) 10 can be elucidated (a detailed treatment is found in [ 41, horning]). the instructor should conclude this preliminary discussion by exhibiting some examples in which the problems mentioned show up in existing systems. if he has some experience with operating system design he certainly will know several exam· pies of synchronization or deadlock problems. 3.2 mutual exclusion whenever two or more processes may access common formation cells, some restrictions must be imposed on their access to such cells, for otherwise misrepresentation of infor· mation may result. the requirement that at most one process may be using a common cell at any given time is known as mutual exclusion. implementing it requires "primitive ations" on data, where primitive means that an operation can· not be interrupted by any other operation on this data. an instructive start in writing concurrent programs is to take "copy a value of a variable" as primitive operation [26, dijkstra). the student will find out that this primitive, though rather clumsy, is sufficient to solve the mutual exclusion problem. since this solution uses the busy form of waiting, there is a motive for looking for a better set of primitives. the primitives lock, unlock and p and v operation (with the counting semaphore) should be discussed in this light; see the appendix in [28, dijkstra) . other forms of the same primitives should be identified, e.g. [73, saltzer) and [86, wirth) . some attention should be given to implementing primitives, see appendix m3·a and [86, wirth). finally, it should be pointed out that application of these primitives may prove very unfair for some of the blocked processes unless certain priority rules are implemented, implicitly or explicitly; see appendix m38(4). 3.3 synchronization this subject should be introduced in relation with the co· operation of processes sharing the system facilities. the operation implies that a process should not continue at certain points of its program until certain information is supplied by another process; moreover, the correct operation of the tem usually requires that processes ought always to supply that information without which others cannot proceed. al· though considered as asynchronous, processes should be chronized up to such an extent that the two conditions, "the necessary information becoming available" and "the contin· uation of a process dependent upon that information," are ordered in time. in this sense the solution of the mutual exclusion problem is an example of synchronization, accord· ing to which one process requires outside information and other processes supply this information. if a given process discovers that the required information is not yet available when needed, that one process will block itself and it is the task of the others to wake it up when the required informs· tion becomes available. the primitives to be discussed here are the pairs of operations (block, wakeup) and (p, v). the occurrence of race conditions and the solution that uses an undergraduate course on operating systems principlescopyright national academy of sciences. all rights reserved.the "wakeupwaiting switch" deserve special attention (see the discussion on the wakeupwaiting switch (72, saltzer) ). this topic lends itself to further exercises in concurrent gramming. with regard to avoiding a fixed selection scheme in a voperation the concept of the private semaphore, i.e., one which can cause the stopping of only one given process, should be discussed [27, dijkstra). 3.4 process communication a discussion of the relation of a sender and a receiver communicating via a message buffer is a natural continuation of the previous section. updating the status variables of the buffer requires mutually exclusive access and the states "buffer empty" and "buffer full" require synchronization of sender and receiver [27, dijkstra). an immediate extension to the above allows m senders and n receivers cm > 1, n > 1) to communicate via a sage buffer; see [27; dijkstra] and the mailbox description [76, spier i . a further extension allows receivers to inspect the buffer for a message of highest priority instead of treating them in a strict firstinfirstout order. at this stage tions of implementation must be taken into account. (see appendix m3a.) it should not be possible, for instance, that a subset of senders monopolizes the buffer so that others will never get a chance to deposit a message. moreover, when a message has been placed in the buffer, its sender should be able to detect that it has been accepted properly. the rc4000 is a system having these facilities [37, hansen). these consid· erations show that the primitives are adequate tools, but not more than that, it being still the designer's task to effect the correct cooperation of processes. 3.5 switching control the object of this section is discussing how a set of operating processes can be implemented on present day computers. the instructor should begin by considering the various implementations of hardware interrupts, by means of which peripheral devices interact with the central machine. if material is available, it is recommended that some atten· tion is paid to queueing of channel commands and interrupt vectors [ ibm/360, b6500, pdp11) . when a process is interrupted, the status of this process should be stored in a control stack (or block) in order to make possible the subsequent resumption of this process. a good description is found in [36, hansen) . when a central processor becomes available it is usually allocated to the highest priority process in the set of "unblocked" processes. (note the distinction between "blocked" and "inactive.") the instructor could at this point introduce briefly the topic of processor scheduling, which is treated in detail in module 7. the primitive operations (p, v, lock, unlock, block, wakeup) each require an implementation of a noninterruptable sequence of machine instructions, which can be achieved by masking off the interrupts. booking a process in a waiting list and selecting a waiting process to wake up are part of the primitives; they should be mented in a very simple form in order to minimize the cution time of the noninterruptable code. there have been several proposals for, and implementations of, less primitive 11 operations than the ones mentioned above; examples are found in [7, bernstein) and [8, betourne). 3.6 system deadlocks the discussion of deadlocks is in fact a continuation of the mutual exclusion and synchronization discussions, where it was stated that a process may have to wait until certain mation becomes available. the system has maneuvered itself in a deadlock situation if none of the processes is going to provide the necessary information. it should be pointed out that a deadlock is caused by a conjunction of circumstances rather than by programming errors in the processes. examples demonstrating this point are: circular waits, infinite repeti· tion of request, two processes each holding half of a pair and asking for the other half. the solutions of the deadlock problem should be class· ified in two kinds: 1) prevent its occurrence; 2) resolve the deadlock situation when it occurs. the first type of solution requires some knowledge in advance about the minimal needs of a process, but has the advantage that it does not restrict the number of working processes unnecessarily. such a policy has been described in (35, habermann] . the second type of solution does not demand any information about future behavior, but requires that preeemption of resources or killing a process be allowed. an example of such a policy is [ 64, murphy i . a good overall view is found in [ 11, coffman). at his option, the instructor may extend the discussions of this module by including a discussion of the overall ture of operating systems. the ring structure of multics [34, graham) and the hierarchical level structure of the the system [28, dijkstra) define certain dominance relations between processes. other hierarchical structures of processes are discussed in [24, dennis & van horn) . os/360 and the rc4000 system have these relations in the form of "parentoffspring." a well· considered structured set of dominance relations facilitates the designer to check the correctness of his design and allows him to apply the rule of "divide et impera" to it. module 3: processes topic outline 3.1 parallelism in an operating system motivation of concurrent programming motivation of asynchronous processes abstract description of process various aspects of process interaction 3.2 mutual exclusion the problem of accessing shared data critical sections and busy form of waiting lock and unlock primitives; p and v operations 3.3. synchronization synchronization of events block and wake up; the wakeupwaiting switch p and v operations used as synchronization primitives an undergraduate course on operating systems principlescopyright national academy of sciences. all rights reserved.3.4. process communication senderreceiver relation generalization of senderreceiver concept some implementation aspects 3.5. switching control hardware interrupt mechanisms process status and control block implementation of primitives 3.6. system deadlocks general statement of the problem how to resolve or prevent deadlocks dominance relations module 3: processes reference list guide types: c conceptual, d descriptive, e example, ttutorial level: s student, a advanced student, i instructor !ill' author level lml!ortance 7 bernstein et al. e s 4 8 betourne et al. e s 3 11 coffman et al. t a 2 13 corbatd and vyssotsky d s 3 24 dennis and van horn c i 3 25 dennis et al. t i 2 26 dijkstra c a 3 27 dijkstra t a 1 28 dijkstra e a 2 34 graham c i 4 35 habermann c a 3 36 hansen e s 2 37 hansen d s 3 41 horning and randell c i 4 49 knuth c a 4 64 murphy c a 4 72 seltzer c s 2 76 spier and organick d s 3 86 wirth e s 3 appendix m3·a implementation and application of p and v operations p and v operate on objects of type "semaphore." this type designates a data structure which is a pair (s, 0) in which s is counter variable and 0 a set of "waiting processes." the con· ceptual difference of the p operation and other instructions in sequential processes is the fact that it may delay the exe· cution of the next instruction. the operations of p and v are: p (semi: decrement the counter sem and, if the result is negative, book the executing process on the waiting list 0 and enter the wait state. v (sem): increment the counter sem and, if the result is still not positive, select a process from the waiting list 0, remove it from 0, and release it from its wait state. the p and v operations on a semaphore are "primitive" in the sense that their execution is uninterruptable by other p or v operations on that semaphore. hazardous race condi· tions could arise if p and v operations could be broken apart 12 in more primitive instructions, which could be executed in an arbitrary order by several processes. if, for instance, decre· menting the semaphore is separated from the negative value test, two processes a>uld find sem >o when sem = 1 and both would decrement sem, which would obviously have an undesired effect. a reasonable implementation of p and v operations requires that, when it enters the wait state, a process releases resources that can be used effectively elsewhere. in particular, in a multiprogramming system, the central processor should be released by a process that enters its wait state through a p operation. hence, a realistic implementation has this structure: p (sem) executed by process y: [sem : = sem· 1; ifsem<o then begin mark y not ready; add y to osem: go to release processor; end] v (sem): [sem: = sem+1; ifsem<o then begin x : = selection from osem: remove x from osem; mark x ready to run; end] the brackets indicate that the enclosed actions are primi· tive (in order to avoid race conditions). on a machine with an interrupt system the p and v operations should be imple· mented as subroutines which are executed with all interrupts masked off (e.g., on an ibm/360 as svc calls). one can argue that the processor allocation, or the priori· ties of processes awaiting assignment to a processor, should be reconsidered when a v operation removes a process from a waiting list osem. because indeed the set of processes ready to run is being expanded. in a system with only one central processor, however, it is not necessary to do so because the process that executed the v operation is still able to use the central processor effectively. the implementation allows a specific interpretation of the semaphore value: if positive, it indicates how many times a p operation will not cause a delay, whereas, if negative, it indicates the number of processes on the waiting list of this semaphore. a hardware interrupt system is an implementation of p and v operations. each interrupt handler routine can be regarded as a process which has performed a p operation when it enables the interrupt for which it is going to wait. although the corresponding v operation is in fact per· formed by the interrupt dispatching mechanism, one may regard the peripheral device or process that caused the inter· rupt as being the source of the v operation. in some imple· mentations the occurrence of the v operation merely causes the appropriate interrupt handler process to be added to the queue of work for the central processor, the processor on which the interrupt occurred remaining under control of the process that was interrupted (multics, the). in other im· plementations the effect is an immediate allocation of the processor to the waiting process (tss/360, pdp10 monitor); an undergraduate course on operating systems principlescopyright national academy of sciences. all rights reserved.this is necessary in these systems in order to run the devices at maximum speed, because new commands may be presented to the devices only after an interrupt. the interrupt mechanism is a more restrictive form of p and v operation, because it relies on the fact that dsem never contains more than one process, and moreover the tity of this process is associated uniquely with the particular semaphore (the interrupt bit). therefore the interrupt patching mechanism can locate the waiting interrupt handler process simply by finding out what caused the interrupt. the general structure of processes communicating via a communicating channel provides an excellent example of the application of p and v operations. a certain channel has a capacity of c messages. senders s; deposit messages and ceivers r; accept them. "accept" and "deposit" are tions on the channel, each of which implies a sequence of operations on the channel status variables, of which the number of messages mand the number of empty slots e. in order to be able to interpret the channel status uously at all times, accept and deposit should not be cuted simultaneously. this is achieved by introducing a aphore mutex, which has the initial value 1 and is used to realize the mutual exclusion of accept and deposit. further· more, senders and receivers should be synchronized with respect to the conditions "channel empty" and "channel full." when the channel is empty, the receivers are to be blocked from attempting to accept messages and it is the senders' obligation to notify the receivers when a message is placed. similarly, the senders must be blocked from at· tempting to deposit messages when the channel is full and they should be notified when again there is an empty slot available. the synchronization can be achieved by making mand e counting semaphores with initial value 0 and c respectively, and programming senders and receivers as follows: si: begin r;= begin prepare message; p(m); p(e); p(mutex); p(mutex); accept; deposit v(mutex); v(mutex); v(e); v(m); process message go go to ri end end it is essential that the operations p(e) and p(m) are not cuted between p(mutex) and v(mutex), whereas the order of the v operations could be reversed. appendix m3bsome examples of exercises in concurrent programming 1) two cyclic sequential processes a and b intend ally to execute a "critical section" in their programs. a section of program is called "critical" because there is a requirement that one of them is allowed to enter its critical section only if the other is not passing its critical section at the same time; in other words, the critical sections must be mutually cluded. program prologues and epilogues of the critical sec13 tions in a and 8 assuming that "copy the value of a variable" is the only uninterruptable action. (26, dijkstra), (27, dijkstra.) 2) extend problem 1 ton processes a;, ... , an, where n>3. 3) the sleeping barber (27, dijkstra.) a certain barbershop consists of two rooms: the waiting room wand the room 8 containing the barber chairs. the shop is so oonstructed that a sliding door d allows access either between wand b, or else between wand the street. thus d allows either the barber to inspect the waiting room w or it allows a customer to come in from the street, but not both. if the barber inspects wand finds nobody there, he will return to 8 and fall asleep; otherwise he will invite the next customer to get his hair cut. if a customer enters the shop and he finds the barber asleep, he should wake up the barber. program the barber and the customers using p and v operations. 4) if there is no restriction on how many customers may enter the waiting room, and if it is not known in which order the v operation is going to wake up the waiting processes, the customers of the previous problem could lock out the barber completely by denying him access to the door nitely. modify the solution of the previous problem so that the barber cannot be locked out. 5) an operating system oontains a process c which commands a line printer device lp, and a process p which deletes the line printer oommands after completion. the processes and line printer lp communicate via an interrupt system with the following data structure: an "activation bit" a; a (hardware) semaphore /; a "switch bit" s and two command buffersb[o) and 8(1). printer lp operates according to this algorithm: lp: if a= 0 then go to lpelła = 0; execute b [sj,· v(i); go to lp; a. the first line is a p operation on the activation bit a. what is the body of the corresponding v operation (which ought to be performed by process cl? b. design programs for c and p (using additional vari· ables and semaphores if necessary) such that the dual buffer system is utilized in the sense that lp may execute a command in one buffer while the other buffer is used to place or delete a command. specify the initial values of the variables and semaphores assuming that the system starts with both the buffers being empty. c. try to combine c and p in one sequential program. would it be more efficient to have one instead of two processes? an undergraduate course on operating systems principlescopyright national academy of sciences. all rights reserved.module 4 memory management 4.1 introduction. the study of modern memory systems concerns two tinct problems: 11 the set of techniques arising from our having to use two or more levels of memory in computer systems. these techniques encompass those of the "onelevel store" or virtual memory. 21 the means of achieving systems supporting very general forms of modular gramming; these include methods for dealing with objects whose size or structure may vary, and those allowing efficient sharing of procedure and data information among many esses. these methods involve enlarging the set of names dress space) within which a process may attempt to access procedure and data objects, either by a storage system arate from address space or by a structured address space. although the second of these two aspects is the subject of module 5, it is not completely independent of the first, which is the subject of module 4. 4.2 abstractions: spaces and mappings. most of the modern solutions to the automatic storage allocation problem derive from the onelevel store introduced on the atlas computer (47, kilburn et al). this machine tinguished "address" from "location," an address being the name for a word of information and a location being a cal site in which to store information. the set of all addresses (program addresses) a process can generate as it references information has come to be known as the address space of the process, and the set of all physical main memory location names (hardware addresses) has come to be known as ory space. by making this distinction, one is able to remove considerations of main memory management from the task of constructing a program, for the address space can be associated permanently with a program and can be made independent of assumptions about memory space. the memory management problem becomes the system's lem as it translates program addresses into location addresses during execution. 4.3. motivation. computers have always included several distinct types of storage media, and the memory has been organized into at least two levels: main (directly addressable) memory and auxiliary (backup) memory. the desire for large amounts of storage has always forced a compromise between the tity of (fast, expensive) main memory and (slow, cheap) auxiliary memory. the onelevel store implements what appears to the programmer to be a very large main memory without a backing store. there are two ways of motivating it. the first starts from the idea of implementing a large, programmable virtual (simulated) memory on a machine having a relatively smaller main memory. the second traces the possible times at which program identifiers are "bound" to (associated with i physical locations. see (21, denning, pp 143157), (85, wilkes, ch 4). 14 the argument according to large virtual memory proceeds as follows. in the original stored program computers, main memory was quite small by today's standards; thus all gramming was carried out in machine code and a large tion of program development was devoted to the overlay problem, viz., deciding how and when to move information between main and auxiliary memory and inserting priate commands to do so into the program. when large (magnetic core) memories were introduced, pressure to solve the overlay problem was relieved. this respite was shortlived, however, for the introduction of algebraic source languages (e.g., fortran and algol) and the linking loader made it possible to construct large programs with relative ease. the resulting strain on main memory resources was aggravated because all the information involved in the execution of a computation was kept in main memory even though much of it remained unreferenced most of the time. thus the need for executing large programs in small main memory spaces motivated hardware and software mechanisms that cally moved information between main memory and auxiliary memory. the argument according to binding time postponement proceeds as follows. there are five binding times of interest. 11 if the program is specified in machine language, addresses in it are bound to storage locations from the time the gram is written. 2) if the program is specified in a highlevel language, program identifiers are bound to storage locations by the compiler. 3) if the program is specified as a collection of subroutines, program identifiers are bound to storage tions by the loader. in 13, binding is permanent, once formed. it may, however, be also dynamic. 4) storage is cated (deallocated) to named objects on demand, such as at procedure activation (deactivation) time in algol, and upon data structure creation (destruction) in lisp or pl/i. 5) age is allocated automatically by memory management ware and software provided by the computer system itself. the sequence 1 through 5 is in fact the historical evolution of solutions to the storage allocation problem. it is characterized by postponement of binding. although postponing binding time increases the cost of implementation, it also increases freedom and flexibility in allocating resources. the two preceding paragraphs outline an approach by which the instructor can familiarize his students with the motivations, both qualitative and quantitative, for automatic storage allocation. detailed accounts of the qualitative fications can be found in [ 18, denning), (21, denning), (22, dennis), and (70, randell & kuehner). for quantitative justification, we recommend: 1) discussing sayre's paper, which reports on comparisons between automatic and ual (programmercontrolled) storage allocation procedures (74, sayre), also (21, denning, pp 159161). and 2) assigning homework problems in which the student is asked to program with overlays devised by himself. an excellent example is a set of programs for multiplying two nxn matrices when main memory contains jn2 n2 .ł and n data locations. an undergraduate course on operating systems principlescopyright national academy of sciences. all rights reserved.however one arrives at the conclusion that some form of dynamic storage allocation is required, one must also con: elude that the programmer cannot handle it adequately him· self: 1) he is not privy to enough information about machine operation to make allocation decisions efficiently. 21 solving the overlay problem at the programming level requires sive outlays of a programmer's time, and the results are not consistently rewarding. it is important to emphasize that there is a distinction be· tween the mechanisms and the policies of storage ment. the mechanisms are on a low level of abstraction in that they deal directly with the hardware features of the system, whereas the policies are on a higher level in that no detailed knowledge of machine organization is necessary or even relevant. the properties of onelevel storage mechanisms are discussed in sections 4.44.6, the policies in section 4.7. examples of onelevel store in contemporary systems are given in (6, bensoussan et al], (70, randell & kuehner]. 4.4 formalization. it is essential to study memory systems by means of the abstractions address space, memory space, and address map, and to emphasize them over and over. they are easy to grasp, and a student will be unable to comprehend the seemingly endless variety of existing memory systems unless he can be shown a pattern. as suggested earlier, memory management problems can be studied in terms of a mapping f:n.m where n is the address space of a given program, m is the main memory space of the system, and fis the address map. if the word with program address x is stored at location y, then f(x) = y. if x is in auxiliary memory but not in main memory, f(x) is undefined, and an attempt to reference such an x creates a fault condition which causes the system to terrupt the program's execution until x can be placed in ory and f updated. the physical interpretation of fis that a "mapping mechanism" is interposed between the processor and memory to translate process generated addresses (in n) into location addresses (in m). this reflects our earlier quirement that the address space n be independent of prior assumptions about m: since the programmer is aware only of n but not the two levels of memory, his program can erate addresses from n only. 4.5 properties of onelevel store. the following paragraphs summarize six important prop· erties of systems providing virtual memory. virtual memory fulfills a variety of programming tives. 11 memory management and overlays are of no con· cern to the programmer. 21 no prior assumptions about the memory space m need be made, and the address space n is invariant to assumptions about m. 31 physically, mis a linear array of locations; typically, n is linear but contiguous gram addresses need not be stored in contiguous locations since the address map f provides proper address translation. the address map thus provides,"artificial contiguity" and, hence, great flexibility when decisions about where informa· tion may be placed must be made (any unused location in m is suitable). 15 virtual memory fulfills a variety of system design tives arising in conjunction with multiprogramming and time· sharing systems: the abilities to 1) run a program partly loaded in main memory, 2) begin execution of a program shortly after it is presented, 3) reload parts of a program in parts of memory different from where they may previously have sided, and 4) vary the amount of storage used by a program. virtual memory provides a solution to the relocation problem. since there is no prior relation between n and m, it is possible to load parts of n into m without regard to their order. it may still be necessary, however, to use a loader to link and relocate subroutines within n. speedup. a twolevel memory system with main memory mand auxiliary memory sufficiently large to contain all of n can normally be made to operate at nearly the speed of m, even though n may be very much larger than m. (to do this, it is necessary that a program's "working set" of information resides in mat each moment of time; see section 4.7.) two examples of this may be found in practice. 1) main memory is magnetic core, auxiliary is drum, and the address map is implemented as a combination of hardware and software (21, denning]. 2) main memory is high speed semiconductor registers, auxiliary memory is magnetic core; according to this approach, known as "cache store" or "slave memory," the address map and management policies are implemented in hardware, the speeds of the two levels being so fast that decisions taken by software would be too slow (84, wilkes] . spacetime trading. let t8(n) denote the running time of the fastest program correctly solving a given problem when the address space size is n and the entire program is loaded in memory. the spacetime tradeoff states that t8(n+1) < t8(n). suppose the memory size is m. the observed running time of this program is t(n) = tefnj,+ t0 (n), where t0 is the over· head in the storage management mechanism; t0 (n) = 0 when n<mand t0 (n+t)>t0 (n)whenn,=:: m. it may easily happen that t(n+1) t(n), i.e., space and time do not trade. since mis assumed unknown a priori, the time tradeoff cannot be used while programming. protection. an elementary form of protection is provided: since a process may reference only the information in its dress space, any other information is inaccessible to it. 4.6 implementations. diagrams indicating the operation of address mapping mechanisms can be found in (21, denning], (22, dennis]. the address map f is normally represented in the form of a table, so that it may be accessed and updated efficiently. two points are worth noting: 1) since n (the size of n) is typically much larger than m (the size of ml, a table with n entries, one for each element of n, is impractical. a table with m entries of the form (x,f(x)) is·more viable. since this table still must be indexed by a program address x, associa· tive and hashing techniques may be used to access and update it. 2) when considering viable implementations of f, it is necessary to dispense with the notion of providing separate mapping information for each element of n. instead, one partitions n into "blocks" of contiguous addresses and vides separate mapping information for blocks only. there are two alternatives: the block size is fixed and uniform, and an undergraduate course on operating systems principlescopyright national academy of sciences. all rights reserved.the block size is variable. according to the former known as pagingblocks of address space are called "pages" and the blocks of main memory "page frames." the latter alternative arises when one considers defining the boundaries of block according to natural logical boundaries within the program, such as subroutines. for each alternative, one must consider: efficiency of the mapping mechanism, efficiency of storage utilization, and efficiency of possible allocation pol· icies (21, denning, pp 165172), (50, knuth, pp. 435455). the instructor should point out that there are two conflicting trends. on the one hand, fixed block size leads to simpler, more efficient storage management systems when properly designed, whereas on the other hand the need for efficient name management requires that n be partitioned into logical units called segments (22, dennis) . the value of mentation" (the ability to have segments) is discussed in connection with dynamic and shared information structures as part of module 5. 4.7. policies. a discussion of particular memory management policies and criteria for choosing one is appropriate at this point. the instructor should point out, however, that memory ment is being studied now as a closed problem whereas it is in reality one component of a larger, systemwide resource allocation policy. the choice of a policy may, therefore, de· pend on additional issues to be raised in module 7. a memory management policy comprises three sub· policies (21, denning, p 158) : 1) the fetch policy deter· mines when a block should be moved from auxiliary to main memory, either on demand or in advance thereof. 2) the placement policy determines into which unallocated region of main memory an incoming block should be placed. 3) the replacement policy determines which blocks should be re· moved from main memory and returned to auxiliary. the complexity of the three subpolicies can be compared ingly as block size is fixed or not; the complexity of a good policy may well affect the choice whether to use more than one block size. in demand paging systems, for example, all blocks are identical as far as the placement policy is cerned, so that memory management reduces to a study of replacement algorithms [4, belady), (58, mattson et al]. demand paging is widely used and well documented in the literature, most of what is known being for the case of fixed main memory size. the instructor should give examples of policies and compare their relative performance (4, belady), (21, denning) , [58, mattson et al]. he should discuss the heuristic "principle of optimality" for minimizing the rate of page replacements: replace the page with the longest pected time until reuse. this principle is equivalent to the "working set principle": a process should be run if and only if its working set is in main memory. a complete discussion of these points is given in (18, denning), (21, denning, pp 180181). the study of storage management policies may be rounded out by a treatment of policies for managing the auxiliary store. considerations identical to those for managing main memory arise here: whether block size should be fixed or not, what should be the block size(s), and how to store tables locating 16 blocks in the auxiliary store. in addition, the use of "shortest access time first" disciplines for optimizing the performance of rotatingmedium (disk, drum) request queues should be mentioned [1, abate & dubner), (21, denning, pp 173176). many a large paging system's auxiliary memory comprises drums and disks, the drums being used to swap pages of active programs to and from core, the disks being used for long· term storage of files. files used by active programs may exist on both drum and disk simultaneously. the term "page mi· gration" refers to the motion of pages of such files between drum and disk (85, wilkes, p 45). 4.8. extension to multiprogramming. as before, mechanisms can be treated separately from policies. in most systems a separate address space and ad· dress map are associated with each process. there are then, two ways to handle the mapping of the resulting collection of address spaces to the main memory. 1) base and bound registers, or relocation registers, may be used to delineate a region of memory to be assigned to a given address space (21, denning), (22, dennis). this is useful only when main memory can hold several address spaces (e.g. cdc 6600). 2) main memory is treated as a pool of blocks, and the tem draws from this pool to assign blocks to individual dress maps as needed. the second alternative is more efficient to implement, especially if paging is used. the working set principle is fundamental to multi· programmed memory management. if this is not followed, attempted overcommitment of main memory can induce collapse of performance, known as thrashing (19, denning], (21, denning, pp 181183). module 4: memory management topic outline 4.1. the needs of modern memory systems techniques for onelevel store techniques for name management 4.2. introduction and discussion of abstractions address and memory spaces address map 4.3. motivation two level memory system argument from large virtual main memory argument from binding time postponement quantitative justification empirical results homework problem demonstrating difficulty of overlays 4.4. formalization of concepts 4.5. properties of onelevel store fulfilling programming objectives fulfilling system objectives relocation speedup; coredrum, cachecore spacetime trading protection an undergraduate course on operating systems principlescopyright national academy of sciences. all rights reserved.4.6. implementation form and use of tables fixed vs. variable block size 4.7. the role of allocation policies subpolicies: fetch, placement, replacement tradeoffs: storage utilization, block size, policies principles of demand paging auxiliary memory management paging drum page migration 4.8. extension to multiprogramming basebound registers vs. pooling blocks working set principle of management module 4: memory management reference list guide types: c conceptual, d descriptive, e example, t tutorial level: s student, a advanced student, i instructor author .hi!! level lml!qrtance 1 abate and dubner c a 3 4 be lady de a 4 6 bensoussan et al. e i 4 18 denning ct s 1 19 denning c i 4 21 denning cdt s 1 22 dennis c s 1 47 kilburn et al. ce a 3 50 knuth c s 2 58 mattson et al. c a 3 70 randell and kuehner de s 1 74 sayre e s 2 84 wilkes c a 2 85 wilkes cdt s 2 17 an undergraduate course on operating systems principlescopyright national academy of sciences. all rights reserved.module 5 name management 5.1 motivation the techniques for memory management studied in module 4 do not provide for the following important system tives concerning the computational memory, i.e., that used to hold the procedures and data structures involved in computations: 1. longterm storage of information. 2. controlled sharing of access to data bases and procedures. 3. creation, deletion, growth and shrinkage of information objects during the course of computations. 4. program modularity, the ability of users to construct programs by linking together subprograms without knowledge of their internal operation. these objectives must be met at the system level because they concern use of shared resources (space in main memory, peripheral storage devices and shared procedure or data bases). in each case questions of naming arise: objects of informa· tion (e.g .. files) must be named for reference by computa· tions; decisions to share objects and procedures should not result in conflicts in the meanings of names. as a result of this module, the student should understand how issues of naming objects arise; and he should learn the concepts and schemes through which the system objectives listed above can be achieved. the instructor should emphasize that there is as yet no single, generally accepted solution to the naming prob· lem, a solution meeting all four objectives. thus the structor must concentrate on developing an appreciation of these issues, and the merits and limitations of known proaches to their resolution. 5.2 basic concepts in a program, names are the symbols that specify the ob· jects operated on by the program. in source language programs names are the identifiers of variables, structures, procedures and statements. when a program is compiled, most identifiers are replaced with numerical names (relative addresses) so that efficient accessing of instructions and data is possible: labels become addresses relative to the base of the machine code of the procedure, identifiers of local variables become addresses relative to the base of the procedure's activation record. tifiers of external objects (e.g. other procedures and files) cannot be replaced by the compiler, and therefore must be retained in essentially unaltered form in the compiled procedure. a compiled procedure is assigned a position in the address space of a computation (by a loader or a linking routine) so that it may be executed with other procedures during a putation. when this is done symbolic references between cedures are usually replaced with names in the form of ad· dresses that locate the procedure within the address space of the computation. context by nature of programmers and machines, the same name often will have two or more valid meanings. some examples 18 are: the same identifier may be used in distinct fortran subroutines or algol blocks; the address field of an struction in the machine code for an algol procedure must refer to different instances of variables for distinct activations of the procedure; machine language programs of different users may occupy the same memory locations having different meanings accordingly. in each of these cases, the different meanings of a name are distinguished by additional information available to the compiler, loader, or hardware when the name is interpreted. this additional information is called the context in which the name is used. (exercise: in each of the examples above, what are the contexts of the names?) the context of a name need not be known at all stages of a name's use or transformation. for example, the compiler of a procedure cannot act on external names (those referencing other procedures, data structures, or files); it must leave such names in essentially the same form as they appeared in the source program. the context necessary for correct tation of these names is often not known until the procedure is assigned to the address space of a computation, or perhaps not even until execution is under way. distinct contexts for names used by different users are often provided by physically separating the information be· longing to one from that belonging to another. this ment makes sharing of information (other than system infor· mation) difficult. if each user's information is catalogued in a "directory" but still is physically separated from other formation, program modules can be shared only by the tedious and wasteful process of copying them from one directory to another. a fundamental principle in the discussions of dynamic structures and sharing of procedures to follow, there are illustrations of an important principle concerning the interpretation of names by a puter system: the meaning of a name must not change during any inter· val within which independent procedures may use the name to refer to the same object this means, for example, that the positions.of objects within the address space of a computation cannot be changed if these objects are referred to by independently specified procedures. the difficulties in using overlay schemes (22, dennis], (54, lanzano], (68, pankhurst] for handling allocation of main memory stem from violation of this principle: because over· lay schemes involve assigning two or more objects to over· lapping areas in address space, the names (address) of such areas change in meaning during computation. to avoid chaos, each procedure making a change in the allocation of memory must inform all other procedures of the new arrangement of objects in address space. this requisite communication is, however, inconsistent with the objective that procedures be independently written. an undergraduate course on operating systems principlescopyright national academy of sciences. all rights reserved.5.3 file systems computer systems generally provide for long term storage of information in the form of files. a file is an organized lection of data usually kept in peripheral storage devices such as magnetic drum or disk, or magnetic tape. the file ment part of an operating system provides users means for generating and using files and manages the allocation of files to available space on storage units. each user of the system is provided with a directory, in which his files are indexed or cataloged by names of hi!> own choosing. in a number of tems, the objects indexed in a directory may include other directories as well as files, thus giving each user ability to create a directory tree, for organizing his collection of filed procedures and data bases in a hierarchy. a particular object is specified by a sequence of names, a pathname, that selects a path from a root of the directory hierarchy to the desired object. the file system provides also for protection and trolled sharing of files (this will be discussed fully in module 6). these general concepts of file system organization are cussed in [16, daley and neuman), [24, dennis and van horn) and [ 10, clark) . since the hierarchy of directories fines a mapping from pathnames to objects, the file system may be regarded as defining an address space for files. in most computer systems the address space defined by the file system is logically distinct from the address space for the computational memory. hence, procedures and portions of files must be copied between the computational address space and the file address space during the course of a tion, an object being accessible only if it is in the tional address space. files themselves may be structured in several ways: 1. as a string of bits, characters or words. 2. as a sequence of records. 3. as an indexed collection of records, each record having a unique key. the records may be accessed by key or in the sequence defined by a natural ordering of the keys. files structured as ordered sets of words an often managed as sequences of blocks of fixed size for conver.ient allocation to free storage space (note the analogy with the use of paging to implement a linear address space in main memory). the block structure of files is a matter of implementation and is made invisible to user computations. the idea of "record" is an historically important way of delimiting fragments of data, originating in the use of punched cards. files of records are stored on contiguous areas of storage devices (disk and tape) and are most suitable for sequential processing as is common practice in business applications. the indexed sequential file is important in systems that access data bases in "real time." hash coding techniques are used to locate the record for an arbitrary key without searching the file [10, clark), [42, ibm). in discussing file structure, the instructor should tinguish carefully between structure that is seen by the user (the abstract structure of the file) and structure for mentation purposes that is hidden (or should be hidden) from the user. files may be of arbitrary size within wide limits, and may grow or shrink during processing; thus a file system provides 19 facilities for manipulating dynamic structures. modular gramming may be done using program modules that obtain inputs from files and store results in other files. file tories provide long term storage for procedures and data and may include protection and shared access control features. thus a general purpose file system would seem to achieve all four system objectives stated earlier. yet, there are serious limitations. i. a data file (or the portion of it being processed) must be copied into the computational address space to gain the advantage of accessing it through the hardware addressing facilities of the computer. the implied loss of efficiency will be severe for computer limited computations if files are used as the basic objects. 11. procedures or program modules retrieved from the file system must be loaded into the computational address space prior to execution. in most systems all procedures must be loaded in advance of tion, wasting address space and making it sible to activate procedures whose names are not known until retrieved from data bases or typed in from a terminal. if procedures may be loaded dynamically, the copying and linking steps will be time consuming. 111. there are few generally accepted standards for the structure and naming of files and for the primitive file operations implemented by file systems. ing standards relate to cobol, a language for data processing applications. conventional file systems are not a suitable base for efficient implementation of procedures expressed in algol, fortran or or pl/i. iv. clashes of identifiers (file names) appearing in pendently written procedures are not avoided. this matter is discussed further in the section 5.6, on modularity. 5.4 segmented address space these four limitations result at least in part from the tinction between the computational memory and the file ory, and can be relieved by using the virtual memory concept to remove this distinction. this has been achieved by bining use of file directories with a large, segmented address space. the address space is divided into a large number of ments, each being potentially large enough to hold any object (procedure or data file) indexed in the file directories. erence by a computation to information in the address space is made by a pair of values (segment number, word number), segment numbers being assigned to procedures and data files when they first are referenced by a computation. after the first reference, the given procedure or data object is bound to a particular segment of address space and, thereafter, the ject may be referenced efficiently as a resident of address space rather than by a search of its pathname in the directory hierarchy. two methods are in use for implementing a segmented dress space. in one [21, denning), [43, iliffe), [44, iliffe and an undergraduate course on operating systems principlescopyright national academy of sciences. all rights reserved.jodeit], [70, randell and kuehner], the segment number is used as an index in a systemmanaged table of "descriptors" or "codewords." a descriptor (codeword) locates the origin of a segment within the main memory if space in main ory has been allocated for the segment, or in peripheral ory otherwise. the other method divides segments (linear name spaces in their own right) into pages and uses two levels of system tables to map (segment number, word number) pairs into main memory locations [21, denning], [22, dennis], [15, daley and dennis]. in both schemes the tem tables also contain access control and protection tags. the use of a segmented address space is valuable for viding independently written procedures space for large namic structures, and for permitting all objects to be shared by computations if desired. these ideas are examined in the following paragraphs. in current systems, the advantages of segmented address spaces have not compensated for the difficulty and complexity of their efficient implementation. for example, the anisms required for linking procedures together in the address space of a computation are intricate [ 15, daley and dennis] and should be considered an advanced topic. 5.5 dynamic structures a dynamic data structure is an organized collection of information that changes in extent during a computation. two types of such data structures are in common use: 1) size tables, such as symbol tables, stacks, or matrices; and 2) linkedlist structures [31, foster]. both types (or tions thereof) require some mechanism for managing the dress space in which they reside. with respect to the first type, there are two approaches, depending on the size of the dress space and the nature of the mapping to memory tions if addresses are virtual. if the address space is sufficiently large, each structure may be assigned to a separate segment of address space, large enough so the structure may grow and contract without conflicting with other structures. since large parts of the address space will be unoccupied, this approach is of interest only when a virtual memory mechanism is present to map the occupied parts of address space into ory (e.g. a segmented address space). if, on the other hand, a large address space is not available but the structures involved in a computation will fit into memory space, a system of routines may be provided for managing the assignment of parts of structures in the available space. schemes for dynamically allocating contiguous blocks within a relatively small address space are described in [50, knuth, pp 435455], and are similar in function to the tines discussed below for managing linked structures. a linked list structure is a collection of items, each sisting of a datum and a pointer (or pointers) to other items. the pointers are addresses that locate items within the dress space [31, foster]. a particular datum is accessed by following a chain of pointers from a single item that serves as the root of the structure. the system routines which access the structure on behalf of a program have three functions: 1) free storagemanagement, i.e., handling allocation of new items, deletion of old items, and maintaining records of free space; 2) garbage collection, i.e., identifying items which have been deleted but not yet returned to the pool of free 20 items; and 3) compaction, i.e., the relocation of live items in the address space so that the i ive items occupy a uous region [45, jodeit], [50, knuth, pp 435455.] compaction is used when the structures must be placed into as small a portion of address space as possible. since the compaction process invalidates the addresses in the items until it is completed, no accesses can be permitted to the structure during compaction. this is an important illustration of the general principle stated at the beginning of this module. compaction changes the names (addresses in this case) by which components of data structures may be referenced by computations. if two computations access the data structures concurrently, both must be halted during compaction and, moreover, any dresses (pointers to data structure items) held in private working storage of either computation must be corrected. this is why compaction is avoided in the design of storage allocation schemes for multiprogram operating systems. paction is often used to limit linked structures to a smaller contiguous portion of virtual address space to improve formance of single process computations on a paged computer. linked list structures are the standard representation of data in certain programming languages such as lisp; but they are often useful in providing efficient storage of complex structures for any application. for this reason, facilities for manipulating linked structures are provided in languages such as pl/i and algol 68. 5.6 modularity the construction of a computer program can be greatly simplified if its major parts are already in the form of gram modules that can be easily combined without edge of their internal operation. the student should learn the characteristics of computer hardware and software essential to modular programming, and understand how practical systems achieve or fail to achieve these necessary properties. two fundamental requirements for successful modular construction of programs are: 1. program modules to be used together must employ consistent representations for all information exchanged among them. 2. a universal scheme must be established by convention for interfacing program modules with one another. modularity can be achieved for a particular group of system users if they adopt uniform conventions among themselves for data representation and intermodule communication. such standards can be developed and agreed upon for any puter system, but seldom without some compromise between degree of generality and efficiency of program execution. modularity achieved through use of shared files in the ner described earlier is an example. different user groups, however, are likely to adopt conflicting conventions, and programs which do not honor such conventions are unusable as modules. this discussion of the limitations of imposing conventions on existing systems should be followed by study of system characteristics that permit any program written for execution an undergraduate course on operating systems principlescopyright national academy of sciences. all rights reserved.by the system to be used as a module in the construction of larger programs. the requirement for consistent representation of municated data is met if all modules are expressed in the same source language, processed by the same compiler, and use only the data types provided by the language. otherwise, this requirement cannot be satisfied without extreme care in the design and implementation of the language processors and execution environment [80, wegner), [59, mccarthy et al). the most important form of program module is the dure, for which basic implementation concepts were treated in module 2. for modular programming, a procedure's author must be free to choose whatever names he desires for objects referenced by the procedureinstructions, variables, data, structures, and other procedureswithout clashing with inde· pendent choices made by the authors of other procedures. to aid in understanding the solution of this and related naming problems, the notions of "argument structure" and "procedure structure" may be introduced. the information which does not vary from one activation to another of a procedure p is called the procedure structure of p. it consists of 1. the code (machine language) of procedure p. 2. the procedure structures of other procedures that are used by pin the same way in every activation of p. 3. any data structures (e.g., own data in algol 60, or static data in pl/i) that "belong" to the procedure in the sense that all activations of p refer to the same instances of the structure. the parts of the procedure structure must be referenced directly by names appearing in the code of the procedure. these names are chosen by the author of the procedure and should be of no concern to the user of the procedure; the context in which these names are interpreted must therefore be distinct for each distinct procedure. the information which may change from one activation to another consists of 1. the input data. 2. the output data. 3. the activation record (working storage). the argument structure consists of the input and output data. conceptually, the components (simple or compound) of the argument structure can be assumed numbered by distinct integers 1,2,3, .... in his coding of the procedure, the author may associate symbolic names x 1.x 2 .x 3, ... with these bered components. similarly, the user of a procedure may associate his own symbolic names y1,y2,y3, ... with these numbered components. thus the ordering and structure of the components is fixed and part of the interface tion, but both author and user are free to choose names for them as they please. the names used in a procedure to reference its activation record are local and the procedure's author must be free to choose them as he pleases. since these names refer to ent data in different activations, the context in which these names are interpreted must be different for each activation. furthermore, the working storage must be able to expand to 21 meet the storage requirements of the activation, which may be arbitrarily large. if one procedure may be called from several independently written procedures, nonlocal references (as in algol 60) have no meaningful interpretation. also, external references (as in a fortran implementation) only make sense in a global context, where name clashes are possible. thus mod· ular programming must be done without the aid of side effects all input and output data of a program module must be conveyed as components of the argument structure. implementations of algol 60 provide distinct working storage areas for nested procedure activations and therefore handle recursive programs, the amount of working storage being specified upon procedure activation. thus limitation 11 and, to some degree limitation i, are overcome. in systems that offer algol 68 or pl/i, means for representing and manipulating linked structures are provided, thereby remov· ing limitation 111 for an important class of data structures. yet clashes between names (of external procedures and files, for example) are still possible and limit the degree to which modular programming is possible. this problem is discussed in [24, dennis and van horn, pp 151154), [78, vanderbilt, chapters 2 and 3). clashes could be avoided by providing two contexts for the interpretation of "external" names occurring within dures. context for procedures and files that are part of the procedure structure would be provided by a procedure tory associated with the procedure in execution. context for procedures and files named in the argument structure would be provided by an argument directory selected by the calling procedure. in this way, all names would be interpreted in appropriate contexts, and all possibilities of name clashes avoided. although this idea is not implemented in any rent system, some similar scheme will be necessary in future systems if modular programming is to be achieved. with these concepts as background, the class can study the extent to which modular programming is permitted by ious classes of systems. in the fortran environment of module 1, each subprogram has a single, permanentlyassigned, fixed activation record. context for naming the parameters of a call is typically provided by the return address, a list of parameters being in some fixed location with respect to each point of call. internal references within a subroutine are signed meaning within the body of the subroutine only. some limitations of this are 1. working storage is not expandable. 2. recursion is not implemented. 3. there is no means for representing dynamic objects. 4. external references made by subprograms are inter· preted within the (global) context of the loader's bol table; thus a name clash will occur if two grams use the same name to refer to distinct objects. (this can be especially troublesome if subprograms written by authors for their personal environments are used in other environments.) an undergraduate course on operating systems principlescopyright national academy of sciences. all rights reserved.5.7 sharing (advanced topic) to permit sharing of procedure and data among users of a computer system, it is necessary to have a systemwide naming scheme so that one user can reference objects owned by others. one method for doing this uses a systemwide directory tree and allows directories to contain links to other directories [16, daley and neumann). as an advanced topic, the instructor may discuss imple· mentations io which a single copy of a procedure or data object in main memory is used by all computations sharing access to the object. there are three motivations for doing this: 1) conserve main memory, 2) avoid redundant copies of information, and 3) reduce overhead required to move extra copies in and out of main memory. in most systems sharing of code in main memory is limited to supervisor and library programs; it is implemented by serving for these shared objects a certain known portion of each user's address space. if, on the other hand, every procedure in a computer tem must be regarded as potentially shared among computa· tions, the implications for addressing mechanisms of the tem are farreaching [22, dennis). not only is it necessary to separate data and procedure information by means of "pure procedures," but a satisfactory means of transferring control between procedures is needed [15, daley and dennis). if control transfer instructions contain absolute addresses in the address space of a computation, a shared procedure must be assigned to the same position in the address space of every computation that uses it. it follows that each address space must sufficiently large to hold all potentially shareable procedures. since there is no way for the system to know which procedures users may wish to share, it is attractive to implement a single address space for all computations in the system. no such system has been constructed, and it remains to see whether such an implementation would be practical. now, suppose control transfer instructions contain ad· dresses relative to the base address of the procedure in which they appear. a procedure may now be assigned different posi· tions in the address spaces of different computations, but the processor must contain a base register containing the base address of the procedure in the applicable address space; all control transfer instructions are interpreted relative to this base register. provision must be made for reloading the base register whenever control is passed between procedures, and a scheme for properly implementing external references must be worked out. one complete scheme is described in [ 15, daley and dennis] . because addresses have different meanings for different computations, this scheme has some serious dis· advantages. communication between computations is difficult, since directory names rather than addresses must be used to identify objects in messages. also, once a procedure has been assigned a position in address space of a computation, it is not legitimate for the system to delete it until the user can guarantee no further attempt to access it by its assigned ad· dress will be mede. as a result, occupancy of address space will tend to increase as a computation references new objects; thus a program that runs for an extended period, continually accessing new information, will have to manage its own use of address space. 22 module 5: name management topic outline 5.1 motivation system objectives concerning storage and access to procedures and data bases. issues concerning treatment of names by system objective to appreciate issues and understand merits of known techniques 5.2 basic concepts forms of names: identifiers, addresses; translation of names by compiler, loader, and system. context for interpretation of names; examples a fundamental principle: meaning of name must not change while in use by independent procedures example: overlay schemes. 5.3 file systems files, directory hierarchies structure of files, their representation on strange devices, implementation achieving system objectives by use of files to represent data limitation of file systems 5.4 segmented address space segments, twocomponent addresses, binding procedure or data to address space implementations with base registers with paging 5.5 dynamic structures two types: arrays of variable size; linked structures management of address space for dynamic structures: free space management, garbage collection compaction, a violation of the naming principle. desirability of large segmented address space. 5.6 modularity fundamental requirements consistent data representations interfacing conventions concepts for modular use of procedures procedure structure, argument structure limitation of systems for modular programming fortran algol 60 algol 68 or pl/i 5.7 sharing use of links in directories for permitting controlled access motivations for shared use of information in main memory implementation alternatives common address space for all computations distinct address spaces with relative addressing; the problem of linking. an undergraduate course on operating systems principlescopyright national academy of sciences. all rights reserved.module 5: name management reference list guide types: c conceptual, d descriptive, e example, ttutorial level: s student, a advanced student, i instructor key author !yi!! level i m2ortance 10 clark d i 4 15 daley and dannis cd a 2 16 daley and neumann cd s 2 21 danning cdt s 2 22 dennis c s 1 24 dennis and van horn cd s 1 31 foster t s 2 42 ibm d i 4 43 iliffe cd s 1 44 iliffe and jodeit cd s 1 45 jodeit d i 2 50 knuth det s 2 54 lanzano de i 2 59 mccarthy et al. cd s 2 68 pankhurst d s 2 70 randell and kuehner d s 3 72 seltzer c a 3 80 wegner cd s 3 23 an undergraduate course on operating systems principlescopyright national academy of sciences. all rights reserved.module 6 protection "protection" is a general term for all the mechanisms which control the access of a process to other objects in the system. there is an immense variety of implementations, it being normal for a single system to have several different and unrelated protection mechanisms; for example, supervisor/ user modes, memory relocation and bounds registers, a num· bering system for open files, access control by user to file directories, and a password scheme for user identification. the study of protection has been deferred until this module of the course because the concepts studied so far could be embodied in a computer system having no protec· tion features, it being assumed that all users are friendly and infallible. this observation should not be taken to imply that protection is a minor consideration. indeed, real usersand the programs they writeare far from infallible, and privacy is a central issue in most systems. as a result, protection con· siderations are in fact pervasive in system designs. the abstractions developed in this module should be ii· lustrated from the operating systems being studied as exam· pies. the material in this module is presented here in consid· erable detail because the literature is inadequate. 6.1 motivation the original motivation for putting protection mech· anisms into computer systems was keeping one user's malice or error from harming other users. a user can harm others in several ways: 1. by destroying or modifying another user's data; 2. by reading or copying another user's data without permission; 3. by degrading the service another user receives, e.g. using up all the disk space or getting more than a fair share of the processing time. an extreme case is a malicious act or accident which crashes the system (the ultimate degradation). more recently it has been realized that these reasons for wanting protection are just as strong if applied to "programs" as well as "users." this line of reasoning leads in three directions: 1. toward enforcing the rules of modular programming so that it is possible to guarantee (through the protection system) that errors in one module will not affect another one. this kind of control engenders confidence in the reliability of a large system, since the protection provides "fire walls" which prevent the spread of trouble [34, graham], [52, lampson] . 2. toward the support of proprietary programs, so that a user can buy a service in the form of a program which he can only call, but not read [52, lampson]. a simple case is a proprietary fortran compiler whose use is charged by number of statements compiled. a more complex case is a proprietary program which compares trial data against a proprietary data base. 3. a third case may suggest that some generality is really required to handle those problems, rather than a few ad hoc mechanisms. this is the construction of a routine 24 to assist in the debugging of other programs. a de· bugger needs to be able to access all the objects the program being debugged can, but must protect itself and its data (breakpoints, symbol tables, etc.) from de· struction by malfunctions in the program being debugged [51, lampson] ł [52, lampson] . 6.2 protection domains at the foundation of any protection system is the idea of protection environments or contexts. depending on the con· text in which a process finds itself, it has certain powers; different contexts have different powers. a simple example of a twocontext system, the contexts being implemented in hardware, is computer with supervisor and user (problem) states (modes). a program executing in supervisor state can execute i /0 instructions, set the memory protection registers, halt the machine, etc., but it may do none of these things in the user state. a somewhat more elaborate example is os/360 mvt, in which there is one supervisor context and up to 15 user contexts; the limit of 15 is enforced by the use of 4bit keys in the 360's memory protection system. yet another example is the individual users of a multiaccess systemeach has his own protected program and files, so that there are at least as many protection contexts as there are users [85, wilkes]. these examples suggest the generality and subtlety of the idea. many words have attempted to capture it: protection context, environment, state, or sphere [24, dennis and van horn], capability list [53, lampson], ring [34, graham]. domain [52, lampson] . the word "domain" will be used here, since it is somewhat neutral and has fewer misleading associations than the alternatives. an idealized system is described below in order to clarify the meaning of the term "domain" and provide a framework for the description of real systems. the idealized system consists of processes which share nothing and communicate with each other only by means of messages. a message consists of an identification of the send· ing process followed by an arbitrary amount of data. the identification is supplied by the system and therefore cannot be forged. processes are assigned unique integer names by the system. any process may send messages (at its expense) to any other process. messages are received one at a time in the order in which they were sent. see [37, hansen] for an actual system very similar to this one, but described from a what different viewpoint. within this system every object belongs to exactly one process and cannot be accessed by any process other than its owner. each process therefore defines a single domain. it may also be regarded as a separate machine, complete with memory. file storage, tape units, etc., and isolated from all contact with other processes except for the message trans· mission facility. this scheme constitutes a logically complete (though inefficient) protection system, except for two points which are discussed later. the following point (which has nothing to do with tection) is important. with this system we can simulate a sub· an undergraduate course on operating systems principlescopyright national academy of sciences. all rights reserved.routine mechanism, regarding one process (a) as the calling routine and another (b) as the routine being called. to call b, a sends b a message specifying the parameters and then waits for b to reply. to return, b replies with another sage containing the value, if any, and then begins waiting for another call. unlike an ordinary subroutine calling mechanism, this one 1norks even if b must be protected from a, e.g. if b is the supervisor and a a user program. it works because b mines where he is "entered," namely at the point where he waits for a's message. random transfers of control to an bitrary point in b are not possible. (multiple entry points are possible, since b can decode one of the parameters to select an entry point.) furthermore, the "return" is protected also. thus, if a mistrusts b, e.g. in the case of a command processor calling a user program, the same argument shows that b will not be able to return to a except in the manner intended by a spurious additional "returns" (extra messages) from b are impossible as well, since a knows when he is expecting a turn message from b and can ignore messages at other times. the scheme clearly works even if each domain mistrusts the other, as in the case of calling a proprietary program [53, lampson]. what if a calls b by this mechanism and b never returns, because bis faulty or even malicious? if a wishes to guard against this possibility, he need only arrange (before calling b), to receive a message from some reliable system process c after an elapsed time longer than b is expected to run. if the message a receives next is from c rather than from b, then a knows something has gone wrong and can proceed to take corrective action. finally, we show that domains are protected against authorized call. recall, that, as part of each message, the system supplies the identity (name) of the caller. this identi· fication may be thought of as a signature, a seal, a badge, or a ticket, which b can use to check the validity of the call. the key point is: the identification is supplied by the tem which guarantees that it cannot be forged. th is point is so simple and yet so subtle that we will illustrate it with an example. suppose that a, whose system identification is 6389, sends to b a message consisting of three numbers: 31, 45, 9. what b will receive is four numbers: 6389, 31, 45, 9. the first number is attached to the message by the system from its knowledge of the sender's identity. there is no way for a to affect the value of the first number in the message. from b's point of view, then, the message starts with a single identifying integer. if b is expecting a message from a, all he must do is look through his message buffer until he finds one starting with a's identification number. how b gets to know a's name is an interesting question which will be examined below, but the following simple scheme will suffice: a's user at his terminal asks a for the number and shouts it across the room to b's user, who types it in to b. remember that this number is not a password. knowing it allows b to give a cess, but does not help anyone else (including b) to sonate a, as the description of message handling given above should make perfectly clear. the kind of protection or access control which can be enforced with this system is extremely flexible and general, 25 since arbitrary programs can be written by users to make the protection decisions. (suggested exercise: show how an structor could implement a grading program which gives student programs at most three tries at obtaining a correct answer.) as was suggested earlier, the system we have been describ· ing has two major flaws. first, it is impossible to regain trol over a runaway process, since there is no way to force a process to do anything or to stop it. this makes debugging difficult. although such a process cannot do any damage, it can waste resources. second, an elaborate system of tions is required to get processes to cooperate. suppose, for example, that process a has some data which it wants to share with processes or friends of a's owner. it is necessary for a's owner, whom we regard as another process communicating with a via a terminal, to learn the names of his friends' esses and to include in a some subroutine which knows these names and responds appropriately to messages carrying them as identification. moreover, a and its correspondents must agree on the interpretation of messages. the protection system we have described is as devoid of convenience as is a central processor without an assembler. just as the processor needs an elaborate system of tions in the form of loaders, binary formats, assemblers, etc., to make it usable, so a protection mechanism requires a tem of conventions on process names, data formats, etc. the issues raised by these two points are discussed in the next section. 6.3 objects and access matrices in order to provide facilities for external control of esses, it is necessary that the protection facility allow for trolled access of one domain by others. (the simple scheme described above allowed no access at all.) thus there must be a way of describing what is to be shared and how access is to be controlled among domains. access to processes can be controlled by a simple tree structure [37, hansen], [51, lampson] , but it can also be handled more generally by the same machinery which we will introduce below. (it is not at all clear that the scheme described below is the only, or even the best, set of conventions to impose, but it does have the property that most of the schemes used in existing systems are special cases of this one.) the more general protection system can be described in terms of another idealized system with three major ponents: a set x of objects, a set d of domains, and an access matrix (access function) a. objects are the things in the system which have to be protected. typical objects in existing systems are processes, domains, files, segments, and terminals. the question what to designate as objects is a ter of convention, to be determined by the protection quirements of each system. objects have names with global validity, which we will think of as 64bit integers. object names are handed out by the protection system on demand, and their interpretation is up to the programs which operate on the objects. this point point is clarified with an example below.) the object names do not have to be 64 bits; there should, however, be an tremely large set of potential object names, for two reasons. 1) each object must have a unique global name, and an an undergraduate course on operating systems principlescopyright national academy of sciences. all rights reserved.object's name may not be reused after the object ceases to exist. 2) if a system error changes a bit in a name, the sulting bit string should be another valid name only with exceedingly small probability. the multics system, for example, uses the time in microseconds since 1900 as the unique object name. as before, a domain is a protection context; domains are the entities which have access to objects. each domain has potentially different access to objects than other domains. in the system of section 6.2 each domain was defined by a ess, and had exclusive access to its own objects and none to any others. this idea is now being generalized so that objects can be shared among domains. there are two ways to view this generalization: 1. each domain owning objects in the system of section 6.2 agrees by convention that it will do certain things with these objects upon demand from some other domain, provided the other domain has access ing to the rules below. 2. for certain "builtin" objects, at least, the access rules below will be enforced by mechanisms already present in the system for other reasons (whether this is ware, as in the case of memory protection, or software, as in the case of file directories, is not important). this may lead to greater efficiency (memory protection is an extreme example) but it is not general and must be supplemented by conventions as in point 1 above if the system is to be extensible. as far as the protection tem is concerned, it makes no difference whether we assume the existence of such other mechanisms or not. note that domains are objects, not sets. in partir.ular, objects do not "belong to" domains. the access of domains to objects is defined by the access matrix a. its rows are labeled by domain names and its columns by object names. element a{ij] specifies the access which domain i has to objectj. each element consists of a set of strings called access attributes; typical attributes are "read," "write," "wakeup." we say that a domain i has "x" access to an object j if "x" is one of the attributes listed in a{ij]. associated with each attribute is a bit called the copy flag which controls the transfer of that access attribute in a way described below. with the access matrix of the figure, for example, domain 1 has "owner" access to file 1 as well as explicit "read" and "write" access. it has given "read" access to this file to domains 2 and 3. domain 1 domain 2 domain 3 file 1 file 2 process 1 domain 1 łowner '*owner łowner *call łread control control łwrite domain 2 call łread wakeup domain 3 owner read *owner control *copy flag set figure: portion of an access matrix 26 entries in the access matrix are made and deleted accord· ing to certain rules. the following are examples of such rules. a domain d can modify the list of access attributes for main d' and object x as follows (examples assume the access matrix of the figure): 1. d can remove access attributes from a{d',x] if it has "control" access to d'. example: domain 1 can remove attributes from rows 3 and 3. 2. d can copy to a [d',x] any access attributes it has for x which have the copy flag set, and can say whether the copies attribute shall have the copy flag set or not. example: domain 1 can copy "write" toa [domain 2, file 1]. 3. d can add any access attributes to a{d',x], with or without the copy flag if it has "owner" access to x. example: domain 1 can add "write" to a [domain 2, file 2]. the reason for the copy flag is that without it a domain not prevent an undebugged subordinate domain from wan· tonly giving away access to objects. the rules above do not permit the "owner" of an object to take away access to that object. whether this should be permitted is an unresolved issue. it is permitted by most tems; see [78, vanderbilt] for a contrary view, according to which an "owner" has in essence entered a contractual agree· ment to provide services to other domains. if this view is adopted, the following rule might be appropriate. 4. d can remove access attributes from a {d',x] if d has "owner" access to x ,;provided d' does not have tected" access to x. the "protected" restriction allows one "owner" to defend his access from the other "owners." its most important cation is to prevent a program being debugged from taking away the debugger's access; it may be very inconvenient to do this by denying the program being debugged "owner" access to itself. the protection system itself attaches no significance to any access attributes except "owner," "control," and tected." thus the relationship between, say, the filehandling module and the system is something like this. a user calls on the filehandler to create a file. the filehandler asks the tem for a new object name n, which the system delivers from its stock of 2 64 object names. the system gives the handler "owner" access to object n. the filehandler enters n in its own private tables, together with other information about the file which may be relevant (e.g. its disk address). it also gives its caller "owner" access ton and returns n to the caller as the name of the created file. later, when some domain d tries to read from file n, the filehandler will ine a {d,n] to see if "read" is one of the attributes, and fuse to do the read if it is not. 6.4 some implementation techniques since a is sparse, it is not practical to store it in the vious way. the most intuitively simple alternative would be a global table tot triples (d,x,a{d,x]) which is search ever the value of a {d,x] is required. unfortunately, this usually is impractical: an undergraduate course on operating systems principlescopyright national academy of sciences. all rights reserved.1. memory protection is almost certainly provided by hardware which does not use t. this is the major area in which the operating system designer has little trol. (it is discussed in section 6.5.) 2. it may be inconvenient to keep all of tin fastaccess memory, since at any given time most objects and haps most domains will be inactive. an implementation is therefore needed which keeps only currently relevant parts of a readily available in fastaccess memory. 3. objects or domains may happen to be grouped in such a way that tis very wasteful of storage. a simple example is a public file, which would require an entry in tfor every domain. 4. it may be necessary to be able to obtain a list of the objects which a given domain d can access, or at least the objects for which dis responsible or is paying for. an implementation which solves 2 and 4 directly attaches to each domain datable of pairs (x,a{d,x] ). each of these pairs is often called a capability [24, dennis and van horn), [43, iliffe), [52, lampson), [53, lampson), [85, wilkes). if the hardware provides for readonly arrays which can only be generated by the supervisor, then each capability can be plemented as such an array, containing the name of the object, and a suitable representation of the access attributes (perhaps as bit strings). most hardware does not provide the kind of protected arrays we have been assuming, but they can easily be simulated by the supervisor (at some cost in convenience) on any machine with some kind of memory protection. it is usually convenient to group capabilities together into ity lists or clists. a domain is then defined by a clist (and its memory, if that requires special handling; see section 6.5). with this kind of implementation it may be convenient to allow additional information to be stored in a capability, e.g. the disk address of a file, or a pointer to some table entry to save the cost of looking up the object name [53, lampson). (exercise: devise a mechanism for controlling who gets to alter this additional information.) capabilities can also be used to solve problem 3 above. all we have to do is construct a tree of domains, each with a set of capabilities or clist [24, dennis and van horn) , [43, iliffe) , [78, vanderbilt) . everything we know about structured naming schemes can then be applied to economize on storage or share capabilities. a completely different approach to storing a attaches the protection information to the object x rather than the domain, in the form of a list of pairs (d,a {d,x] ). with each object x there will be a procedure ak (d) which returns a [d,x]. the procedure is provided by the owner of the object and can keep its own data structures to decide who should get access. note that at least some of these procedures will have to refrain from accessing any other objects in order to prevent infinite recursion. this is the idea of an access trol list, such as is used in multics. as before, it is essential to note that the procedure ak gets a domain name as argument, and this cannot be forged (see section 6.2). unique names, however, may not be convenient for the procedure to remember; access is likely to be associated with a person or group of people, or perhaps with a program. for example, capabilities can be used as identification, since 27 they have the essential property that they cannot be forged. we will call a capability used for identification an access key; it is a generalization of a domain name [52, lampson). then all the access control procedure ak needs to know is what access keys to recognize. each user (indeed, each entity which needs to be identified by an access control procedure) obtains a unique access key from the supervisor, records it, and transmits it to those who wish to grant him access. they then program their access control procedures to return the desired attributes when that key is presented as an argument. in order to avoid the inconvenience of arbitrary access control procedures, one may attach to each object an access lock list consisting of pairs (key value, access attributes). it works in the obvious way: if the value of the key presented matches the value in one of the locks, the corresponding attribute is returned. alternatively, one may regard this scheme as a generalization of one of the first protection systems, that of ctss, which, instead of a key value, employed the name of the user as identified at login [14, crisman), [52, lampson), [85, wilkes) . one access list per object is likely to be cumbersome. many systems group objects into directories, which in turn are objects, so that a tree structure can be built up. this adds nothing new, except that it introduces another kind of structured naming [85, wilkes) ł observe that a directory is not too much different from a domain in structure. the access key method of obtaining access is, however, quite ferent in spirit from the capability method. since it is also likely to be more expensive, many systems have a hybrid plementation according to which an object can be accessed once by access key to obtain a capability, which is then used for subsequent accesses. this process when applied to files is usually called opening a file [51, lampson), [52, lampson) . 6.5 memory protection memory protection hardware is usually closely related to mapping or relocation hardware. there are two aspects to this: 1. memory which is not in the range of the map cannot be addressed and is therefore protected. 2. in paged or segmented systems (even twosegment ones like the pdp10) each page or segment in the map may have protection information associated with it. the point is: each domain must have its own address space, for otherwise there can be no protection [52, lampson), [53, lampson). it is also desirable for one domain to be able to reference the memory of another, subject to the control of the access matrix. a segmented system in which any segment is potentially accessible from any domain fits well into the framework of sections 6.2 and 6.3, usually with a implemented via capabil· ities. [24, dennis and van horn), [34, graham). it may be an annoyance that a segment capability has a different form than other capabilities, but this problem is minor. some dif· ficulties may arise, however, with transfers of control from one domain to another, since the addressing hardware will not normally allow the tree addressing and software must be used. [34, graham) . an undergraduate course on operating systems principlescopyright national academy of sciences. all rights reserved.in the absence of segmentation either pages or files may be treated as objects to be shared. since the contents of the page map can be changed when changing domains, there is a feasible (though far from elegant) means of sharing memory when necessary while preserving the security of each domain. in the absence of paging, each domain will have to have private memory which is not accessible to any other domain, except through some ugly circumlocution. the naming problems which result have been considered in module 5. there is one exception to this observation for the case of nested domains d1 , ... , dn(i.e. a[d1 x} ::> ... ::>a fdn,xl for all x) on machines with base and bound relocation: simply arrange the memory for the domains contiguously, with d1 nearest to location 0, and set the bound for d1 to the total length of all the memory, for d2 to the total length excluding d1, etc. now only a simple addition is required for d1 to interpret addresses ind;. i<j [38, harrison], [53, lampson]. module 6: protection topic outline 6. 1 motivation keep users under control keep programs under control 6.2 protection domains the idea of different contexts (domains) an idealized system to clarify this idea processes communicating by messages, no sharing calls and returns are possible protection is obtained from the systemsupplied domain name weaknesses of this system no control over errant processes need conventions for cooperation between processes 6.3 objects and access matricesanother idealized system components of this systemdomains, objects, access matrix access attributed olanging access relation of protection to the rest of the system 6.4 implementation techniques storing the sparse matrix as triplesdrawbacks capabilities and clists treestructured naming with capabilities access keys, procedures and lock lists directories hybrid implementations 6.5 memory protection memory as an object to be protected segments as objects pages as objects memory protection without mapping nested domains 28 module 6: protection reference list guide types: c conceptual, d descriptive, e example, t tutorial level: s student, a advanced student, i instructor key author tu! level 14 crisman (sec. ad) e a 4 22 dennis c a 3 24 dennis and van horn c a 1 34 graham ce s 2 37 hansen e s 1 38 harrison e a 3 43 iliffe e a 4 51 lampson e a 4 52 lampson ce s 1 53 lampson ce a 2 55 linde etal. e a 4 62 molhoetal. e a 4 78 vanderbilt c i 4 82 weissman e s 2 85 wilkes (pp 4959, c s 1 75,90) an undergraduate course on operating systems principlescopyright national academy of sciences. all rights reserved.module 7 resource allocation 7.1 introduction and motivation the previous modules have discussed techniques for ess communication, memory management, naming, and tection of objects. little consideration has been given to the effects of different choices on the attitude of the user and on the performance of the system. some of the techniques (e.g., multiprogramming) arise from the desire to have a system which is not only correct, but efficient. every system sists of a set of available resources and a set of users who are constantly demanding to use them. examples of resources clude processor time, memory space, peripherals, channels, and data bases. examples of consumers at different levels include projects, users, programs, and processes. in a well utilized system, some or all of the resources will be scarce, and systems are considered balanced if all resources are equally scarce. in addition to the requirements of balanced resource usage, efficiency, and smooth operations, most tems seek to allocate resources to maximize some measure of "satisfaction" in the user community. the purpose of ing resource allocation is investigating strategies for allocating resources, and understanding their effects on system efficiency service to the users. there are two distinct and conflicting goals for resource allocation. 1) efficiencymeasures of equipment utilization, cost of resources, balance, amount of useful computation, throughput, and so on, are to be optimized. 2) measures of user satisfaction, such as turnaround time, sistency and integrity of the system, flexibility, problem ing ability, are to be optimized. computer center managers have tended to stress zation of throughput in batchprocessing systems. interactive systems are stressing services as well. resources can be allocated in two extreme fashions: 1) a user holds all the resources he requires for the entire time he is active, e.g. batchprocessing. 2) the system expends at least as many resources optimizing the allocation as the opti· mization saves. between ( 1) and (2) there exists a reasonable compromise. the purpose of an investigation of resource cation is to approximate the ideal compromise for a particular system. 7 .2 allocation strategies in a system environment of scarce resources and demands frequently exceeding the supply, some processes will have to wait. the waiting processes are distributed in a system of queues; a particular process, the scheduler. selects processes from the queues to satisfy objectives of efficiency and service. the scheduler determines how processes flow through the queues and which process obtains a resource when it is free. schedulers normally use information from three possible sources in making decisions: 1) from the user according to external priorities, 2) from the compiler according to dicted properties of a program, and 3) from the system it· self according to its state and the observed behavior of the processes. 29 it is a policy decision to choose the source of information for the scheduler and how it is used to regulate the progress of processes. examples of allocation strategies should be sented. there are two areas of particular importance from which they may be drawn. processor allocation: considerable work has been done in allocating processor time to processes, especially in time ing systems [12, coffman] and [48, kleinrock]. processor allocation disciplines should be discussed and their advantages and disadvantages pointed out qualitatively. quantitative analysis of the disciplines should be postponed for later on. memory management: experience shows that memory is one of the most precious resources in modern systems. in module 4 students were introduced to the concept of mem· ory management policies. if he has not already done so, the instructor should review examples of memory management algorithms, both for nonpaging [50, knuth, ch. 2] and for paging environments [18, denning], [21, denning]. the properties of the working set model for program behavior should be discussed [18, denning]. the instructor should point out how most paging systems prepage working sets to a certain extent, viz., upon reinitiation of an interrupted process. although these two problemsprocessor and memory managementhave been studied separately in the literature, the instructor should emphasize that there must be a close working relationship between processor and memory ment policies, if only because each process demands the use of these resources simultaneously. see [20, denning] for one view of this relationship, and [83, wilkes) for another. 7 .3 strategy evaluation common sense and intuition are not sufficient to devise a good resource allocation strategy: the interactions among processes and resources are too complex. at the early stages of time sharing, for example, an optimistic approach was commonplace with respect to memory management, virtual memory being considered the answer to the space squeeze problem. the phenomenon of thrashing has made designers aware of the difficulties [ 19, denning] and [21, denning), and has demonstrated the need for careful investigation of the properties of allocation disciplines. the following is an important trade off between memory utilization and processor utilization, its solution being sented by an optimal degree of multiprogramming. analysis, rather than intuition, must be used to evaluate it. on the one hand, if many processes are kept active (working sets loaded in memory) the processor has little chance of remaining idle. since the amount of memory is fixed, each process has less available main storage, and more page faults will be generated. on the other hand, if few processes are kept active there is more than enough space to contain their working sets, but the processor is likely to be excessively idle due to output waits blocking the processes. to evaluate allocation strategies, one uses analysis, experimentation, or both. analytic models are useful since an undergraduate course on operating systems principlescopyright national academy of sciences. all rights reserved.they typically are computationally convenient to work with, they can be constructed even though the systems being modelled do not exist, and they can be used to predict optimal results. two classes of models are in use. probability models probabilistic assumptions are made for the interarrival times and magnitudes of demands on a system. the system is analyzed to determine various quantities of est, such as lengths of queues, waiting times in queues, or ficiency. probability models have been used most extensively in analyzing queues awaiting service on a processor [60, mckinney i . for analyzing the operation of rotating like) storage devices [1, abate), [17, denning), and for analyzing certain aspects of program behavior [21, denning). many of the queueing models for processor scheduling prob· lems have lost their applicability to modern systems: whereas modern systems induce a flow of jobs through a network of queues with many points of congestion (processor, output, etc.), the "classical" analyses deal with systems taining only a single point of congestion (processor). no literature on queueingnetwork models for contemporary tems was available at the time of this writing, but the tor may wish to investigate the recent i iterature for such models. since many analyses are carried out under the assumption that important probability distributions are exponential, the instructor should review the experimental verification of uations in which exponential assumptions are valid [32, fuchs). deterministic and discrete models: models which do not depend on probability assumptions have been used to analyze resource allocation problems. these include analyses of the deadlock problem [11, coffman), [35, habermann), analyses of paging algorithm behavior [58, mattson) , and various analyses of deterministic scheduling problems [57, manacher). since they must be simple to be tractable, analytic models have limitations. there often is a conflict between simplicity on the one hand and realism on the other. thus, experimental testing and verification is of great importance in dealing with complex situations, though often at considerable expense. there are two kinds of experimental techniques: simulation and a posteriori evaluation. from a practical point of view, the chief difference between the two techniques is that lation results can be obtained prior to the implementation of a system; in contrast, a posteriori evaluation allows one to obtain results under actual working conditions. in either case, the effects of various resource allocation strategies can be tested and compared [3, arden), [56, macdougall), [73, saltzer), [87, wulf). analytic models and experimental results are often plementary. experiments are used to verify assumptions for use in the models. a model can be used to obtain imate results for checking the reasonableness of simulation results. no experimental work can succeed without some herent model of system behavior: the presupposed modal influences the experimenter in his choice of experiments, level of detail, or choice of parameters. 7.4 balancing resources against demands balanced usage of resources has been found important, since an imbalance (e.g. overload) in the use of one resource 30 can generate an imbalance in the use of others. for example, an overloaded inputoutput channel can make it impossible to keep the most useful information in main memory. or, attempted overcommitment of main memory can generate serious under utilization of processor [19, denning). or, a process cannot effectively utilize a processor unless it has a "workingset amount" of memory allocated to it [18, denning) . these are examples of the general principle that there often exists a critical amount of resource a to make fruitful the allocation of another resource b. a balanced resource allocation policy implements this principle by regulating membership in the set of active esses such that the total demand of that set matches the available equipment, and the probability of overloading any type of resource is controlled. a wide range of service tives is implementable within the constraint of a balanced resource allocation policy. specifying the equipment ration (relative capacities of the various resource types) is straightforward when a balanced resource allocation policy is used. see [20, denning). module 7: resource allocation topic outline 7 .1 introduction and motivation 7.2 allocation strategies source and nature of priorities processor allocation memory allocation unified approaches to processormemory allocation 7.3 strategy evaluation probability models deterministic and discrete models simulation . a posteriori evaluation 7 .4 balancing resources against demands critical amount of one resource needed to allocate another balanced resource allocation policy equipment configuration module 7:resource allocation reference list guide types: c conceptual, d descriptive, e example, ttutorial level: s student, a advanced student, i instructor !!y author !l2! leval lml!211anca 1 abate and dubner c a 3 3 arden and boettner e a 3 11 coffman, et al. ct s 1 12 coffman and kleinrock d s 2 17 denning e i 3 18 denning c a 1 19 denning d s 2 20 denning c a 3 21 denning d s 1 32 fuchs and jackson ce i 2 35 habermann c a 2 48 kleinrock c i 3 an undergraduate course on operating systems principlescopyright national academy of sciences. all rights reserved.!!y author hj!! level i ml!ortance 50 knuth de a 3 56 macdougall cd s 2 57 manachar c a 2 58 mattson at al c a 3 60 mckinney c s 1 73 seltzer and gintell c a 2 83 wilkes c a 3 87 wulf e a 2 31 an undergraduate course on operating systems principlescopyright national academy of sciences. all rights reserved.module 8 pragmatic aspects this final module treats the aspects of operating systems which are not yet well enough understood to warrant separate treatment. most of these aspects concern the design, the im· plementation and the maintenance of systems. because they are relegated to an inferior position at the end of the course, the instructor should not lead the students to believe that these topics are of less importance. quite the opposite: pragmatic aspects of system design can make the difference between success and fai.lure. the students, however, can hardly be expected to appreciate what is yet unclear to the expert and unfamiliar to the average lecturer. as the field of operating systems matures, one would expect these topics to become structured and well stood. it then will be possible for the instructor to treat these topics by means of abstractions, even as the topics of mod· ules 28 have been treated. 8.1 design the instructor should review and illustrate several of the current viewpoints on the methodologies of system design, comparing their pros and cons. more than one of the views outlined below may apply to a given system. the level approach. this methodology is exemplified in the design of the the system [28, dijkstra] . one may imagine a series of machines m0,m1, łłł mk, ... and grams p 1, p 2 ł... ,pk, ... such that m 0 is the given system hardware and mk is an extension of mk.f produced by pk. the extended machines m1,m2, ... .mkł łłł are called the "levels" of the system. note that a process existing in level k may invoke the services of any process in levels k or lower, but not in any level above k. if the levels are carefully chosen, this approach can have decided advantages with respect to clar· ity of description and elegance of design. most important of all, however, this approach lends itself to proving a priori the correctness of the design: one proves by induction that the correctness of mk. f and pk implies that of mk. this has clear advantages in the stepbystep construction and debugging of the system. the greatest difficulty with this approach is the problem of choosing what the levels should be. the topdown approach. the design starts from a general description of the system and, by steadily adding detail, tually is sufficiently detailed that it can be run on a machine. conceptually. the design proceeds by successive refinements of system modules, each module being described by its minal behavior; having proceeded k steps into the design, one proceeds to the (k+t)st step by subdividing some module into a network of simpler modules. eventually, each module is a simple macro which can be programmed directly on the chine. in practice, this design process consists of successively detailed simulation programs; when the last step is reached the final simulation program is the complete operating tem [88, zurcher). the advantage of this approach is: the presence of the actual hardware is not required at the ning; the designer needs only to know its properties. the disadvantage of this approach is a tendency toward infinite regression in the successive refinements of modules, coupled 32 with the possibility that the final set of simple modules may not interface efficiently with the existing hardware. (the task force is not aware of any successful system that has been constructed using this approach alone.) the nucleusextension approach. one identifies the mini· mal elements of an operating system and provides a "nu· cleus" of programs providing these elements. it is then the responsibility of programmers to add to thisextend itin ways that meet their requirements. in the rc4000 system, the nucleus was taken to be the interprocess message mission facility [36, hansen], [37, hansen). the principal advantage is the ability to get a minimal system operating in a short time; the disadvantage is that more systemdevelopment work is placed on the system's users. there is, of course, an analogy between the nucleus of this type system and the lowest levels of a levelstructured system. the modulesinterface approach. the system is partitioned as finely as possible into its constituent functions, each tion then being implemented as an operating system module. the system designer's task is to identify the modules and specify their interfaces [42, ibm). this is the method most widely used in systems design. its chief attraction is that it does not require a great deal of initial planning, as would be required in the three approaches discussed earlier. experience seems to be quite clear on this point: by allowing the design to be started without adequate preplanning, serious slippage of design deadlines may be the result. (the problems with os/360, multics, and other large systems are cases in point.) more specifically, designers tend to minimize the complexity of their modules and pay little attention to the complexity of the interfaces. in practice, the resulting faces are so complex as to be incomprehensible; worse still, the entire system may be extremely sensitive to change, be unstable, or exhibit bottlenecks in unforeseen places. in other words, it is very hard to predict in advance exactly how the system will behave. data base or transaction oriented systems. in certain cases (e.g. reservation or telephoneswitching systems) the data base or the transactions to be performed on the system are specified well in advance. the designer has little flexibility, being constrained to build the system to accommodate the existing data base or transaction structures. as an example the bell telephone ess system may be discussed [46, keister). finally there is a collection of ad hoc "seat of the pants" techniques used quite often out of expediency to design and implement systems. they are almost always never successful since they attempt to design a complex system without thought. the following two can be cited as examples: the iteration method. build a version of the system and continuously iterate and modify it to meet the demands and rectify complaints. when this has been done, the result has always been utter confusion for designers, programmers and users. the deadline method. get started in an arbitrary fashion, making ad hoc decisions as necessary so that parts of the an undergraduate course on operating systems principlescopyright national academy of sciences. all rights reserved.system are running by specified dates, no matter what. when this has been done, it has normally been necessary to start over again once the deadline is met and the demonstration is given. 8.2 reliability logical correctness and tolerance to error are prime siderations in operating systems design. the reliability quirements placed on many contemporary systemsespecially when users become dependent on the systemoften mean that the system must be more reliable than the hardware on which it is built. logical correctness, together with the ability to test and verify correctness, can be invaluable in solving the reliability problem, since then errors can be attributed to hardware failure only. (the the system is the only system known to the committee which was designed for ness" (28, dijkstra], (29, dijkstra).) one important design consideration is that the effect of an error should be localized, so that the fewest users are affected by it and that recovery may be as rapid as possible. the gest single reliability problem is integrity, i.e., protection against loss of information when an error occurs. four tech· niques are commonly used to provide integrity. 1) as the importance of data increases, so the probability that an error destroys it should decrease; many designers use the rule of thumb that the fraction of time a given data base is being accessed is inversely proportional to its importance. 2) as the importance of data increases, so should its redundancy. thus, important system tables can be reconstructed from formation in other system tables. the redundant copies should reside in different physical parts of the system. 3) critical data is checked from time to time for consistency. 4) mental dumping is used to copy files into archives, shortly after those files are updated. thus the archives contain cent copies of all files, should one of the files in the system proper be destroyed. (see (85, wilkes, pp 86, 90) .) finally, recovery and restart facilities are an important design consideration and should never be an afterthought. hardware failure should be considered realistically. the weaknesses of each piece of equipment should be stood clearly. the system should overcome, not enhance, the hardware difficulties (65, nato, pp 149153). 8.3 implementation material covering the difficulties encountered during implementation of large software systems can be drawn from the two nato reports on software engineering (65, nato], (66, nato]. management aspects, and production aspects as well, of large software systems can be emphasized. planning. the problems common in the design and plementation of large software packages include personnel, project organization, and human factors (61, mealy), (65, nato pp 7289). choice of implementation language. the advantage of a higher level language like pl/1, bcpl, pl/360 cannot be overstated (65, nato pp 5559). portability. the production of software as machine pendent as possible will eventually enable to be transported from one installation to another. (66, nato pp 2833). 33 debugging. debugging facilities and checkout procedures are invaluable to programmers and implementors. (66, nato pp 2325). documentation. good documentation on production and service is extremely important (65, nato pp 116117, pp 209211). automatic flowcharting techniques are often used to assist in documenting programs (2, abrams]. 8.4 performance monitoring and evaluation the field of measurement, evaluation, and tuning of ating systems is progressing rapidly (9, calingaert], (39, hart), (65, nato pp 200203). the relative advantages of ware versus software measuring tools should be discussed, (79, warner], but the problem of data reduction is beyond the scope of this course. techniques for regulating progress of processes and for "tuning" the system are related both to performance monitoring and to resource allocation (88, wulf] , (20, denning) . again we stress that the students should realize that these problems are very important. that there are no unifying stractions to be presented does not necessarily mean that the topics should be ignored. the students should be aware of the difficulties and the existence of limited solutions, even ad hoc ones. module 8: pragmatic aspectstopic outline 8.1 design levels approach topdown approach nucleusextension approach modulesinterface approach data base or transaction oriented "seat of the pants" techniques 8.2 reliability design for reliability system integrity 8.3 implementation personnel and project organization implementation languages portability debugging documentation 8.4 performance measurement and evaluation measurement evaluation and tuning module 8: pragmatic aspects reference list guide types: c conceptual, d descriptive, e example, t tutorial level: s student, a advanced student, i instructor an undergraduate course on operating systems principlescopyright national academy of sciences. all rights reserved.!id author !y.2! level i ml!!!rtance 2 abrams d s 4 9 calingaart d a 3 20 denning c i 3 28 dijkstra d s 1 29 dijkstra c a 1 36 hansen d a 2 37 hansen d s 1 39 hart d s 3 42 ibm d i 3 46 keister d s 2 61 mealy d a 3 65 nato d s 2 66 nato d s 2 79 warner d s 3 85 wilkes t s 1 87 wulf d a 3 88 zurcher and randell c a 2 34 an undergraduate course on operating systems principlescopyright national academy of sciences. all rights reserved.bibliography the following abbreviations are used in the bibliography. acm association for computing machinery ieee institute for electrical and electronics engineers iee etc ieee transactions on computers cacm jacm cs fjcc sjcc 2sosp communications of the acm journal of the acm computing surveys (acm) fall joint computer conference spring joint computer conference second symposium on operating systems principles (proceedings available from acm, 1133 avenue of americas, new york, n.y. 10036) 1. abate, j., and dubner, h. optimizing the performance of a drumlike storage. ieee trans. c18, 11 (nov. (nov. 1969), 992997. 2. abrams, m. a comparative sampling of the systems for producing computerdrawn flowcharts. proc. 1968 acm nat. conference. 3. arden, b. and boettner, d. measurement and ance of a multiprogrammed system. proc. 2sosp (oct. 1969). 4. belady, l.a. a study of replacement algorithms for virtual storage comf>uters. /bm sys. j. 5, 2 (1966), 78101. 5. bell, c.g. and newell, a. computer structures: ings and examples. chapt. 3, mcgraw hill (1971). 6. bensoussan, a., clingen, c.t., and daley, r.c. the multics virtual memory. proc. 2sosp (oct. 1969). 7. bernstein, a.j. et al. process control and tion. proc. 2sosp (oct. 1969). 8. betourne, c., et al. process management and resource sharing in the multiaccess system 'esope'. cacm 13, 12, (dec. 1970). 9. calingaert p. system performance evaluation survey and appraisal. cacm (jan. 1967). 10. clark, w.a. the functional structure of os/360, part ill: data management. /bm sys. j. 5, 1 (1966), 3051. 11. coffman, e.g., elphick, m., and shoshani, a. system deadlocks. cs 3, 2 (june 1971 ). 12. coffman, e., and kleinrock l. computer scheduling measures and their countermeasures. af/ps conf. proc. 32 (1968 sjcc). 13. corbato, f.j. and vyssotsky, v.a. introduction and overview of the multics system. af/ps conf. proc. 27 1965 fjcc), 185196. 14. crisman, p.a. the compatible timesharing system; a programmer's guide. mit press, 2nd edition, bridge, mass. (1965). 35 15. daley, r.c., and dennis, j.b. virtual memory, esses, and sharing in multics. cacm 11, 5 (may 1968), 306312. 16. daley, r.c., and neumann, p.g. a generalpurpose file system for secondary storage. af/ps conf. proc. 27 (1965 fjcc), 213229. 17. denning, p.j. effects of scheduling on file memory operations. af/ps conf. proc. 30 (1967 sjcc), 922. 18. denning, p.j. the working set model for program behavior. comm. acm 11, 5 (may 1968), 323333. 19. denning, p .j. thrashing: its causes and prevention. af/ps conf. proc. 33 (1968 fjcc), 915922. 20. denning, p.j. equipment configuration in balanced computer systems. /eeetc c18 (nov. 1969), 10081012. 21. denning, p.j. virtual memory. cs 2, 3 (sept. 1970), 153189. 22. dennis, j.b. segmentation and the design of programmed computer systems.jacm 12, 4 (oct. 1965), 589602. 23. dennis. j.b. a position paper on computing and munications. cacm 11, 5 (may 1968), 370377. 24. dennis, j.b., and van horn, e.c. programming tics for multiprogrammed computations. cacm 9, 3 (mar. 1966), 143155. 25. dennis, j.b. et. al. computation structures. chapt. 8, class notes for subject 6.232, mit (1970). [available from: mit, rm. 4213, cambridge, mass. 02139.) 26. dijkstra, e.w. solution of a problem in concurrent programming control. cacm 8, 9 (sept 1965), 569. 27. dijkstra, e.w. cooperating sequential processes. programming languages (f. genuys, ed.), academic press (1968), 43112. 28. dijkstra, e.w. the structure of the multiprogramming system. cacm 11, 5 (may 1968), 341346. 29. dijkstra e. a constructive approach to the problem of program correctness. bit 8 (1968). 30. fano, r.m. and corbato, f.j. time sharing on puters sci. amer. 215, 3 (sept. 1966), 129140. 31. foster, j.m. list processing. macdonald and co., london ( 1967 ). 32. fuchs, e., and jackson, p.e. estimates of random variables for certain computer communications traffic models. cacm 13, 12, (dec. 1970). 33. gear, c. w. computer organization and programming. mcgraw hill (1969). 34. graham, r.m. protection in an information processing utility. cacm 11, 5 (may 1968),368. 35. habermann, n. prevention of system deadlocks. cacm 12, (july 1969). an undergraduate course on operating systems principlescopyright national academy of sciences. all rights reserved.36. hansen, p.b. (ed.) rc4000 software multiprogramming 59. mccarthy, j., corbato, f.j., and daggett, m.m. the system, a/s regnecentralen, april 1969, falkoner linking segment subprogram language and linking alie 1, copenhagen f. denmark. loader. cacm 6, 7 (july 1963), 391395. in rosen, s. 37. hansen, p.b. the nucleus of a multiprogramming sys(ed), programming languages and systems, mcgraw tem, cacm 13 (april 1970), 238. hill (1967). 38. harrison, m.c. implementation of the sharer2 time60. mckinney, j.m. a survey of analytical timesharing sharing system.cacm 11, 12 (dec.1968),845. models. cs 1, 2 (june 1969) 105116. 39. hart, le. the user's guide to evaluation products, 61. mealy, g. the system design cycle. proc. 2sosp. datamation 17, 1 (dec. 1970). (oct. 1969). 40. hellerman, h. digital computer system principles. 62. molho, l. hardware aspects of secure computing. mcgraw hill (1967). proc. af/ps conf. 36 (1970 sjcc), 135. 41. horning j.j., and randell, b. structuring complex 63. morris, r. scatter storage techniques. cacm 11, 1 processes, ibm research apt. rc2459 (may 2, 1969), (jan. 1968), 3844. ibm research center, p.o. box 218, yorktown 64. murphy, j.e. resource allocation with interlock detecheights, n.y. 10598. tion in a multitask system. af/ps conf. proc. 33 42. ibm. os/360 concepts and faciiities. in programming (1968 fjcc), 11691176. languages and systems. (s. rosen, ed.), mcgrawhill 65. nato report on software engineering, (1967), 598. garmish, oct. 1968. available free of charge through 43. iliffe, j.k. basic machine principles. american elsevier nato, dr. h. arnthjensen, scientific affairs division, (1968). ot an/nato, 1110 bruxelles, belgium. 44. iliffe, j.k., and jodeit, j.g. a dynamic storage allo66. nato report on software engineering, rome, cation scheme. the computer journal (oct. 1962), oct. 1969. available free of charge through nato, 200209. dr. h. arnthjensen, scientific affairs division, 45. jodeit, j.g. storage organization in programming ot an/nato, 1110 bruxelles, belgium. systems, cacm 77, 11(nov.1968),741746. 67. naur, p., et al. revised algol report. cacm 6, 1 46. keister, w. et al. no. 1 ess: system organization and (jan. 1963), 117. in rosen, s. (ed.), programming objectives. bell system technical journal 43, 5 (sept. languages and systems, mcgraw ( 1967). 1964), 18311844. 68. pankhurst, r.j. program overlay techniques. cacm 11, 47. kilburn, t. et al. onelevel storage system. ire 2 (feb. 1968), 119125. trans. ec11, 2 (apr. 1962), 223235. 69. parkhill, d. challenge of the computer utility. 48. kleinrock, l. a continuum of time sharing algorithms. addison wesley (1966). proc. af/ps conf. 36 (1970 sjcc) 70. randell, b., and kuehner, c.j. dynamic storage allo49. knuth, d.e. additional comments on a problem in con· cation systems. comm. acm 11, 5 (may 1968), 297current programming. cacm 9 (may 1966), 321323. 305. 50. knuth, d.e. the art of computer programming 71. randell, b. and russell, l.j. algol 60 implements(vol. 1). addisonwesley (1968), ch. 2. tion. academic press (1964). 51. lampson, b.w., et al. a user machine in a timesharing system. proc. ieee 54, 12 (dec. 1966). 72. saltzer, j.h. traffic control in a multiplexed computer 52. lampson, b.w. dynamic protection structures. system. mit project mac apt mactr30 (1966), proc. afipsconf. 35 (1969 fjcc). project mac, 545 technology square, cambridge, mass. 02139. 53. lampson, b.w. on reliable and extensible operating systems. /nfotech stateoftheartproceedings (1970). 73. saltzer, j., and gintell, j. the instrumentation of 54. lanzano, b.c. loader standardization for overlay multics. cacm 13, (aug. 1970). programs. cacm 12, (oct. 1969), 541550. 74. sayre, d. is automatic folding of programs efficient 55. linde, r.r., et al. the adept50 time sharing sysenough to displace manual? cacm 12, 12 (dec. 1969), tem. proc. af/ps conf. 35 (1969 fjcc). 656660. 56. macdougall, m.h. computer system simulation: an 75. sharpe, w.f. the economics of computers. (chapt. introduction. cs 2, 3 (sept. 1970), 191210. 10). columbia university press (1969). 57. manacher, g.k. production and stabilization of real76. spier, m.j., and organick, e.1. the multics intertime task schedules. jacm 14, 3 (july 1967) process communication facility. proc. 2sosp. 439465. (oct. 1969). 58. mattson, r.l., gecsei, j., slutz, d.r., and traiger, l.l. 71. subcommittee of the american standards association evaluation techniques for storage hierarchies. ibm sectional committee x3, computers and information sys. j. 9, 2 (1970), 78117. processing. fortran vs. basic fortrana pro36 an undergraduate course on operating systems principlescopyright national academy of sciences. all rights reserved.11amming language for information processing on automatic data processing systems. cacm 7, 10 (oct. 1964), 591624. 78. vanderbilt, d.h. controlled information sharing in a computer utility. mac·tr67, mit, october 1969, document room, project mac, 545 technology square, cambridge, mass. 02139. 79. warner, c.d. monitoring: a key to cost efficiency. datamation 16, 17 (jan. 1971). 80. wegner, p. communication between independently translated blocks. cacm (july 1962), 376381. 81. wegner, p. programming languages, information structures and machine organization. (sections 4.1 · 4.7), mcgraw hill (1968). 82. weissman, c. security controls in the adept50 timesharing system. proc. af/ps conf. 35 (1969 fjcc), 119. 83. wilkes, m.v. a model for core space allocation in a time sharing system. af/ps conf. proc. 34 (1969 sjcc), 265271. 84. wilkes, m.v. slave memories and dynamic storage allocation./£££ trans. ec14 (apr. 1965), 270271. 85. wilkes, m.v. timesharing computer systems. am. elsevier (1968). 86. wirth, n. on multiprogramming machine coding and computer organizations. cacm 12, 9 (sept. 1969), 489498. 87. wulf, w.a. performance monitors for multipro· gramming systems. proc. 2sosp (oct. 1969). 88. zurcher, f. and randell, b. iterative multilevel modelling. a methodology for computer system. /f/p congress 68, edinburgh, scotland, (aug. 1968). 37 an undergraduate course on operating systems principlescopyright national academy of sciences. all rights reserved.an undergraduate course on operating systems principlescopyright national academy of sciences. all rights reserved.