detailsdistribution, posting, or copying of this pdf is strictly prohibited without written permission of the national academies press. (request permission) unless otherwise indicated, all materials in this pdf are copyrighted by the national academy of sciences.copyright © national academy of sciences. all rights reserved.the national academies pressvisit the national academies press at nap.edu and login or register to get:œ œ 10% off the price of print titlesœ special offers and discountsget this bookfind related titlesthis pdf is available at sharecontributorshttp://nap.edu/5463ada and beyond: software policies for the department ofdefense116 pages | 8.5 x 11 | paperbackisbn 9780309055970 | doi 10.17226/5463committee on the past and present contexts for the use of ada in the departmentof defense, national research councilada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.ada and beyondsoftware policies for the department of defensecommittee on the past and present contexts for the use of ada in the department of defensecomputer science and telecommunications boardcommission on physical sciences, mathematics, and applicationsnational research councilnational academy presswashington, d.c. 1997iada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.notice: the project that is the subject of this report was approved by the governing board of the national research council, whose members are drawn from the councils of the national academy of sciences, the national academy of engineering, and the institute of medicine.the members of the committee responsible for the report were chosen for their special competences and with regard for appropriate balance.this report has been reviewed by a group other than the authors according to procedures approved by a report review committee consisting of members of the national academy of sciences, the national academy of engineering, and the institute of medicine.the national academy of sciences is a private, nonprofit, selfperpetuating society of distinguished scholars engaged in scientific andengineering research, dedicated to the furtherance of science and technology and to their use for the general welfare. upon the authority ofthe charter granted to it by the congress in 1863, the academy has a mandate that requires it to advise the federal government on scientificand technical matters. dr. bruce alberts is president of the national academy of sciences.the national academy of engineering was established in 1964, under the charter of the national academy of sciences, as a parallelorganization of outstanding engineers. it is autonomous in its administration and in the selection of its members, sharing with the nationalacademy of sciences the responsibility for advising the federal government. the national academy of engineering also sponsors engineering programs aimed at meeting national needs, encourages education and research, and recognizes the superior achievements of engineers.dr. william a. wulf is interim president of the national academy of engineering.the institute of medicine was established in 1970 by the national academy of sciences to secure the services of eminent members ofappropriate professions in the examination of policy matters pertaining to the health of the public. the institute acts under the responsibilitygiven to the national academy of sciences by its congressional charter to be an adviser to the federal government and, upon its own initiative, to identify issues of medical care, research, and education. dr. kenneth i. shine is president of the institute of medicine.the national research council was organized by the national academy of sciences in 1916 to associate the broad community of science and technology with the academy's purposes of furthering knowledge and advising the federal government. functioning in accordancewith general policies determined by the academy, the council has become the principal operating agency of both the national academy ofsciences and the national academy of engineering in providing services to the government, the public, and the scientific and engineeringcommunities. the council is administered jointly by both academies and the institute of medicine. dr. bruce alberts and dr. william a.wulf are chairman and interim vice chairman, respectively, of the national research council.support for this project was provided by the department of defense (under contract number dasw0196c0028). the views, options,and findings contained in this report are those of the authors and should not be construed as an official department of defense position, policy, or decision, unless so designated by other official documentation.library of congress catalog card number 9671960international standard book number 0309055970additional copies of this report are available from: national academy press 2101 constitution avenue, nw box 285 washington, dc20055 800/6246242 202/3343313 (in the washington metropolitan area) http://www.nap.educopyright 1997 by the national academy of sciences. all rights reserved.printed in the united states of americaiiada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.committee on the past and present contexts for the use of ada inthe department of defensebarry boehm, university of southern california, chairtheodore baker, florida state universitywesley embry, silicon graphics inc.joseph fox, template softwarepaul hilfinger, university of california at berkeleymaretta holden, boeing corporationj. eliot b. moss, university of massachusetts at amherstwalker royce, rational software corporationwilliam scherlis, carnegie mellon universitys. tucker taft, intermetrics inc.rayford vaughn, electronic data systems corporationanthony wasserman, interactive development environments inc.special advisorbarbara liskov, massachusetts institute of technologystaffpaul d. semenza, study directorgloria p. bemah, administrative assistantiiiada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.computer science and telecommunications boarddavid d. clark, massachusetts institute of technology, chairfrances e. allen, ibm t.j. watson research centerjeff dozier, university of california at santa barbarasusan graham, university of california at berkeleyjames gray, microsoft corporationbarbara grosz, harvard universitypatrick m. hanrahan, stanford universityjudith hempel, modeling simulations inc.deborah a. joseph, university of wisconsinbutler w. lampson, microsoft corporationedward d. lazowska, university of washingtonbarbara liskov, massachusetts institute of technologyjohn major, motorolarobert l. martin, lucent technologiesdavid g. messerschmitt, university of california at berkeleycharles l. seitz, myricom inc.donald simborg, knowmed systemsleslie l. vadasz, intel corporationmarjory s. blumenthal, directorherbert s. lin, senior program officerpaul d. semenza, program officerjerry r. sheehan, program officerjean e. smith, program associatejohn m. godfrey, research associateleslie m. wade, research assistantgloria p. bemah, administrative assistantgail e. pritchard, project assistantivada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.commission on physical sciences, mathematics, and applicationsrobert j. hermann, united technologies corporation, cochairw. carl lineberger, university of colorado, cochairpeter m. banks, environmental research institute of michiganlawrence d. brown, university of pennsylvaniaronald g. douglas, texas a&m universityjohn e. estes, university of california at santa barbaral. louis hegedus, elf atochem north america inc.john e. hopcroft, cornell universityrhonda j. hughes, bryn mawr collegeshirley a. jackson, u.s. nuclear regulatory commissionkenneth h. keller, university of minnesotakenneth i. kellermann, national radio astronomy observatorymargaret g. kivelson, university of california at los angelesdaniel kleppner, massachusetts institute of technologyjohn kreick, sanders, a lockheed martin companymarsha i. lester, university of pennsylvanianicholas p. samios, brookhaven national laboratoryl.e. scriven, university of minnesotashmuel winograd, ibm t.j. watson research centercharles a. zraket, mitre corporation (retired)norman metzger, executive directorvada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.viada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.prefaceit is increasingly important for the department of defense (dod) to implement effective informationsystems policies and strategies, as future battles will be decided as much in "cyberspace" as in physical space. theuse of effective computer programming languages and more broadly, of software engineering technology andpolicy designed for optimal support of dod requirements is key to dod's strategy of achieving informationdominance for warfighting. for the past two decades, dod has used programming language policy as a vehiclefor obtaining costeffective, highperformance information systems. however, the process of softwaredevelopment has changed considerably during this period, as has the computer industry itself. these changes havealtered the environment in which dod develops and produces information systems.it is in this context that assistant secretary of defense (command, control, communications, andintelligence) emmett paige, jr., requested that the national research council's computer science andtelecommunications board (cstb) review dod's current programming language policy. convened by cstb,the committee on the past and present contexts for the use of ada in the department of defense was asked to:1. review dod's original (mid1970s) goals and strategy for the ada program;2. compare and contrast the past and present environments for dod software development; and3. consider alternatives and propose a refined set of goals, objectives, and approaches better suited tomeeting dod's software needs in the face of ongoing technological change.although the committee focused on programming language issues, it also considered them in the context ofsoftware architectures, components, and lifecycle processes, consistent with the realization that successfulsoftware engineering strategy involves several elements that are at least as important as the programming languagecomponent.throughout its deliberations, the committee was sensitive to the fact that the issues surrounding ada and dodprogramming language policy have been the source of vigorous debate among dodprefaceviiada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.policymakers, program managers, government contractors, and the software community at large. thus thecommittee made a concerted effort to collect a variety of views, and it received numerous briefings, positionpapers, and analyses from representatives of government agencies, as well as the defense, aerospace, andcommercial industries. the committee membership included many different organizational viewpoints andpersonal experiences; as it reflected the larger community, so also did it engage in vigorous debate during its owndeliberations. in the process of reaching conclusions and formulating recommendations, however, the committeeagreed on the importance of dod adopting software policies that better reflect ongoing significant changes in thediscipline of software engineering, while retaining the benefits of prior investment and policy decisions.the committee also understood the desire on all sides to bring closure to a policy debate that has continuedfor many years. several briefings to the committee included requests that the committee not suggest further studieson the topic. the committee found these requests compelling and has attempted to frame its recommendations sothat they can be acted on directly by dod policymakers. thus, for example, in addition to makingrecommendations in the main text of the report concerning the appropriate scope of and criteria for dod softwarepolicy, the committee found it useful to propose a revised statement of the current policy as embodied in doddirective 3405.1. the committeemodified form of the dodrevised draft (may 15, 1996) of the directive isoffered in appendix a for consideration as a template for further revision. the committee was aware that dodhas been conducting an effort to revise this policy; indeed, the committee was provided copies of two differentdraft revisions.in addition to the individuals and organizations who participated in committee meetings and wrote positionpapers for the study (listed in appendix e), the committee would like to acknowledge the numerous anonymousreviewers for their constructive comments on a draft version of this report. the committee would also like toacknowledge the efforts of assistant secretary paige and his staff, including cynthia rand and connie leonard,for assisting the committee in locating individuals and materials to consult.finally, the committee would like to acknowledge the support provided by the computer science andtelecommunications board and staff. several board members took an active interest in the project and offerednumerous suggestions that helped to strengthen the report. the cstb staff were instrumental in organizing thecommittee meetings and coordinating briefings, reviews, and interactions with board members. in particular,cstb's administrative assistant, gloria bemah, provided excellent administrative support, and its director,marjory blumenthal, played a key role in overseeing the study on behalf of the cstb. susan maurizi edited thereport under a compressed schedule, and gail pritchard and jean smith of cstb assisted in production of thefinal draft. finally, paul semenza, the study director, worked closely with the committee in every phase of thestudy.prefaceviiiada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.contents executive summary 11 the changing context for dod software development 7 growth in the commercial software industry, 8 obstacles to broad adoption of ada, 8 low commercial awareness and limited sponsorship, 9 limited extent of academic instruction in ada, 9 limited availability of ada tools and compilers, 10 assumption that ada has to control everything, 11 need for adacompatible application programming interfaces, 11 labor market forces, 12 dod programming language policy, 12 policy history, 12 ada's place in current dod programming language policy, 14 implementation of policy on waivers, 14 importance of appropriate expertise, 15 level of applicability, 15 implications, 15 dod investment strategy, 16 summary of ada trends, 16 critical questions, 17 notes, 182 software engineering and the role of ada in dod systems 19 software engineering process and architecture, 19contentsixada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved. economics of software engineering, 21 reducing the complexity of software products, 21 improving software processes, 22 influence of software environments, tools, and languages on the software engineeringprocess, 23 technical evaluation of ada 95 and other thirdgeneration programming languages, 24 available comparisons of ada 83 and other thirdgeneration programming languages, 26 analyses of language features, 26 comparisons of empirical data, 26 anecdotal experience from projects, 30 the need to institute collection of data for software metrics, 30 notes, 323 dod software policy: analysis and recommendations 34 policy objectives and criteria relevant to meeting them, 35 relating criteria to objectives, 35 critical criteria in dod's selection of a programming language, 35 warfighting and commercially dominated applications, 36 ada businesscase analysis, 37 criteria for evaluation of ada, 37 conclusions, 40 findings and recommendations, 42 ada competitive advantage, 42 applicability of policy to dod domains, 42 scope of policy, 43 policy implementation, 43 investment in ada, 43 software metrics data, 44 assessment of policy alternatives, 44 conditions for requiring ada, 44 ada requirement, 47 language choice process, 48 investment in ada infrastructure, 49 economic analysis of investment in ada infrastructure, 50 notes, 524 implementation of recommended dod software policy 53 recommended policy for choice of programming language, 53 goals of software development, 54 guidelines for choice of programming language, 55 recommended policy for requiring the use of the ada programming language, 55 software engineering plan review process, 56 policy framework, 57 stakeholder role, 58contentsxada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved. approval authority and milestones, 59 submission of software engineering plans, 59 software engineering codes, 60 notes, 615 implementation of recommended strategy for investment in ada 62 goals of the investment strategy, 62 ada investment strategy, 63 language maintenance and enhancement, 64 support for ada compilers, tools, and application programming interfaces, 64 curriculum development, 66 centralized support organization, 66 detailed plan for investments in ada technology and support, 66 conclusion, 67 notes, 68 bibliography 69 appendixes a dod draft software management policy directive with further modifications suggested bythe committee, 75b technical descriptions of ada and other thirdgeneration programming languages, 80c glossary, 88d detailed comparisons of ada and other thirdgeneration programming languages, 92e briefings and position papers received by the committee, 101contentsxiada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.contentsxiiada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.executive summarywhat should the department of defense do about the ada programminglanguage?ada was developed in the 1970s by the department of defense (dod) and adopted in some dod programsuntil its use was required for new software development in 1987. it has been employed as a tool for developingquality software and as a dod policy lever to encourage dod organizations and programs to adopt modernsoftware engineering principles. changes within dod, the software engineering community, and the commercialsoftware industry have led dod to reassess its programming language policy.the committee on the past and present contexts for the use of ada in the department of defense wascreated by the national research council's computer science and telecommunications board to review dod'sprogramming language policy and the question of ada's role in it. this study presents findings andrecommendations developed by the committee for dod's consideration in efforts to revise its current policy.the committee concluded that a vigorous ada program would enhance the reliability and performance ofdod warfighting systems, and it recommends that dod continue the use and promotion of ada in such systems.however, the committee found significant problems with the two primary components of dod's current strategyfor ada. first, there are problems in the scope, design, and implementation of the current programming languagepolicy, which requires the use of ada for all software to be maintained by dod; the committee recommendsseveral modifications. second, dod's plan to discontinue investments in ada technology and usercommunitysupport by the end of 1997 will weaken the ada infrastructure and work against any requirement for dod systemsto use ada in the future; given the large installed base of ada code in warfighting systems, targeted investments inada are justified.in the course of this study, the committee also concluded that the currently available data on effects ofprogramming language on project outcomes are insufficient, on their own, to serve as a basis for strongdeterminations of the impact of programming language choice on the outcome of dodexecutive summary1ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.programs. briefings received by the committee also highlighted the difficulty that dod managers have in gainingaccess to data that can support informed decisions. the committee did find that trends in the data, anecdotalevidence, and expert judgment provided a basis for its finding that ada provides benefits in warfighting systems.however, based on its experience with the limitations of currently available data, the committee makes anadditional recommendation that dod institute a corporate data collection effort and develop metrics as a soundbasis for evaluating software so as to guide future policy and management decisions.context and trendsdod's policy preference for ada had some merit a decade ago. most software at the time was entirelycustom, and ada had a good track record in delivering custom software with higherquality and lower lifecyclecosts. however, a custom ada solution is no longer the best approach in many application areas, due to thefollowing major trends:ł cots as a source of information infrastructure for applications. software solutions increasingly dependon commercial offtheshelf (cots) software, which provides much of an application's informationinfrastructure: operating system, database management, networking, user interface, and distributedprocessing functions. much of this software is written in programming languages other than ada thatoften do not have readily available interfaces to programs written in ada. developing these interfaces isnot a major technical problem, but, particularly in the area of commercial internet applications, cotssoftware is evolving rapidly, making it hard for ada solutions to keep current. productline solutions and production factors. software for many application areas is achievingeconomies of scale through the development of productline architectures, enabling software assets to bereused across families of applications. these productline solutions are driven by strongly coupled"production factors," including software components, processes and methods, human resources, andexpertise in particular domains. in warfighting application areas such as weapon control and electronicwarfare, there is little commercial development, and dod has established a strong community ofwarfighting software developers whose production factors are oriented to ada. however, for thenumerous dod applications in which the market is dominated by commercial solutions, such as financeand logistics, production factors have been built around programming languages other than ada, puttingada solutions at a disadvantage.additional conditions that strongly influenced the committee's findings and recommendations includethe following: dod emphasis on achieving information dominance. according to secretary of defense william perry,". .. our warfighting strategy sustains and builds on ... the application of information technology to gaingreat military leverage to continue to give us [an] unfair competitive advantage" (perry, 1996a). thisassertion highlights the importance of a capability for enhancing military competitive advantage as acriterion for the choice of programming language. large and increasing inventory of dod ada software. dod now has over 50 million lines of operationalada weapon systems software, with a great deal more under development. most of this software is incritical warfighting application areas, and there are no quick and cheap ways to translate it into otherlanguages. dod policies and investment strategies that weaken ada support for this software are veryrisky because of the role warfighting software plays in maintaining national security.executive summary2ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved. proliferation of programming languages has decreased, but polylingualism is here to stay. one goal ofdeveloping ada was to reduce the proliferation of programming languages used in dod systems,estimated to be approximately 450 in the 1970s. the number of languages used throughout dod hasindeed decreased: the use of machine and assembly languages has diminished, and the number of thirdgeneration languages in use has been reduced. however, there has been a rapid increase in developmentof fourthgeneration languages by the commercial sector (there are now more than 100 different suchlanguages), and use of these languages by dod is increasing. thus, dod cannot expect to avoidpolylingual software solutions. however, support for multilanguage applications has improvedsignificantly. programming language choice is one of several key software engineering decisions. the requirement touse ada and the process for obtaining a waiver isolate programming language decisions from other keysoftware engineering decisions (e.g., choices of computer and software architectures, decisions about useof cots components, and milestone schedules). these decisions are also currently made at the systemlevel, rather than at the component or subsystem level. this arrangement creates an incentive for dodprograms to make decisions that are not optimal for dod as an organization. future programminglanguage decisions need to be made as part of an integrated software engineering process.findings and recommendationsthe committee developed the following set of findings and recommendations for future dod software policyand strategy. the recommendations address the use of ada in warfighting software, the application in which thecommittee finds ada to have demonstrated benefit; the proper scope and implementation of software policy;investment in ada; and collection of data as a basis for assessing the effectiveness of software and softwarepolicy.ada competitive advantagefinding. ada gives dod a competitive advantage in warfighting software applications, including weaponcontrol, electronic warfare, performancecritical surveillance, and battle management.recommendation. continue vigorous promotion of ada in warfighting application areas.rationale. available project data and analyses of programming language features indicate that, comparedwith other programming languages, ada provides dod with higherquality warfighting software at a lower lifecycle cost. dod can increase its advantage by strengthening its adabased production factors (involving softwaretools, technology, and personnel) for warfighting software (see chapters 2 and 3).applicability of policy to dod domainsfinding. dod's current requirement for use of ada is overly broad in its application to all dodmaintainedsoftware.recommendation. focus the ada requirement on warfighting applications, particularly critical, realtimeapplications, in which ada has demonstrated success. for commercially dominated applications, such as office andmanagement support, routine operations support, asset monitoring, logistics, and medicine, the option of usingada should be analyzed but should not be assumed to be preferable.executive summary3ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.rationale. for warfighting software, supporting adabased production factors (involving software tools,technology, and personnel) gives dod a competitive advantage. in this domain, eliminating the use of ada wouldboth compromise this advantage and diminish the capabilities for maintaining dod's existing 50 million lines ofada. in commercially dominated areas, pushing applications toward ada would create a disadvantage for dod(see chapters 2 and 3).scope of policyfinding. dod's current requirement for use of ada overemphasizes programming language considerations.recommendation. broaden the current policy to integrate the choice of programming language with otherkey software engineering concerns, such as software requirements, architecture, process, and quality factors.rationale. the current policy isolates the ada requirement and the waiver process from other softwareengineering decisions, causing programs to make premature or nonoptimal decisions (see chapter 1). dod hasalready taken steps to broaden the policy focus in its draft revision of its programming language policy, doddirective 3405.1; this report recommends modifications to that draft policy (appendix a).policy implementationfinding. dod's current ada requirement and the related waiver process have been weakly implemented.many programs have simply ignored the waiver process. other programs make programming language decisionsat the system level, but often a mix of ada and nonada subsystems is more appropriate (see chapter 1).recommendation. integrate the ada decision process with an overall software engineering plan review(sepr) process. passing such a review should be a requirement for entering the system acquisition milestone i andii reviews covered by dod instruction 5000.2. it should also be required for systems not covered in 5000.2, andrecommended by dod for doddirected software development and maintenance of all kinds.rationale. the sepr concept is based on the highly successful commercial architecture review boardpractice. the sepr process involves peer reviewing not only the software and system development plans, but alsothe software and system architecture (building plan) and its ability to satisfy mission requirements, operationalconcepts, conformance with architectural frameworks, and budget and schedule constraints; the process alsoinvolves reviewing other key decisions such as choice of programming language (see chapter 4).investment in adafinding. for ada to remain the strongest programming language for warfighting software, dod mustprovide technology and infrastructure support.recommendation. invest in a significant level of support for ada, or drop the ada requirement. the strategydeveloped by the committee recommends an investment level of approximately $15 million per year.rationale. with investment, dod can create a significant adabased complex of production factors(involving software tools, technology, and personnel) for warfighting application domains.executive summary4ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.without such support, ada will become a secondtier, niche language such as jovial or cms2 (seechapter 5).software metrics datafinding. dod's incomplete and incommensurable base of software metrics data weakens its ability to makeeffective software policy, management, and technical decisions.recommendation. establish a sustained commitment to collect and analyze consistent software metrics data.rationale. the five sets of findings and recommendations above are based on a mix of incomplete andincommensurable data, anecdotal evidence, and expert judgment. for this study, the patterns of consistency inthese sources of evidence provide reasonable support for the results but not as much as could be provided byquantitative analysis based on solid data. a few organizations within dod have benefited significantly fromefforts to provide a sound basis for software metrics; a dodwide data collection effort would magnify the netbenefits (see chapter 2).what the department of defense should do about adain summary, the committee concluded the following regarding dod and ada:1. dod should continue to require ada for its warfighting software and should drop the adarequirement for its other software.2. dod should provide roughly $15 million per year for ada infrastructure support, or drop therequirement to use ada entirely.3. dod should make programming language decisions in the context of a software engineering planreview process.the rationale for the above statements is as follows:1. in commercially dominated areas, although ada may offer some advantages for custom softwaredevelopment, the preponderance of existing commercial activity and solutions in other languagescounters these advantages, thereby shifting the businesscase away from mandating ada in theseareas.2. in warfighting applications, ada's technical capabilities for building realtime, highassurance customsoftware are generally superior to those of other programming languages. dod's investments in adato date have provided dod systems with a competitive advantage in these areas.3. the commercial marketplace alone will not sustain a robust ada infrastructure.4. a relatively modest ($15 million per year) dod investment at the margin would be sufficient tosustain a robust ada infrastructure for warfighting applications.5. dod's inventory of more than 50 million lines of ada warfighting software will become a liabilitywithout a robust ada infrastructure.6. dod's current ada waiver procedure can be effectively replaced by adoption of the commerciallyestablished practice of using architecture review boards, a process that can also strengthen dod'soverall software engineering capability.executive summary5ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.organization of this reportchapter 1 describes the past and present contexts for ada and dod software development and programminglanguage policy and points out problems with the current approach. chapter 2 relates issues in decisions aboutprogramming language to other software engineering decision issues and evaluates ada's support for softwareengineering processes. it also summarizes the results of comparing the relative costeffectiveness of ada and otherprogramming languages, based on analyses of language features and empirical data from software projects.chapter 3 presents a businesscase analysis for the use of ada within dod, gives the committee's findingsand recommendations, and analyzes them along with alternatives.the software policy recommended by the committee for dod is elaborated in chapter 4, which also providesadditional details on programming language selection criteria and explains the basic elements of the softwareengineering plan review process recommended by the committee. chapter 5 discusses the committee'srecommended strategy for investment in infrastructure for ada.appendix a reproduces a draft revision of dod directive 3405.1 on programming language policy (dod,1987a), a document to which the committee has added further suggested modifications that reflect itsrecommendations in this report. appendix b presents detailed descriptions of ada and other programminglanguages; a glossary of terms used in the report is contained in appendix c; appendix d compares ada's featureswith those of other thirdgeneration programming languages; and appendix e lists briefings and position papersreceived by the committee during the course of its study.executive summary6ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.1the changing context for dod software developmentfor nearly two decades, the ada programming language has been a cornerstone of efforts by the departmentof defense (dod) to improve its software engineering practices. dod created ada in the 1970s to serve as adepartmentwide standard that would satisfy its special requirements for embedded and missioncritical software,and would also encourage good software engineering. both the new language and the new software engineeringideas associated with it met with some criticism, and both have evolved as a result. today, ada is the mostcommonly used language for missioncritical defense software, which includes weapon systems andperformancecritical command, control, communications, and intelligence (c3i) systems. dod's inventorycontains nearly 50 million lines of ada code in these applications (hook et al., 1995). given the long operationallife of such systems, dod has made a significant investment in ada technology. ada is the second mostcommonly used language (after cobol) for dod automated information systems, which include payroll andlogistics programs. the dod inventory contains more than 8 million lines of ada code in these applications(hook et al., 1995).hopes for broad commercial adoption of ada have not been realized, however. its commercial use has beeneclipsed by other languages, such as c, then c++, and, most recently, java. dod's inclusive approach in thedevelopment of the language, as well as its promotional campaigns in support of ada, do not appear to have beensuccessful in fostering adoption of the language beyond defense and other missioncritical applications.during ada's lifetime, dod's position in the software market has shifted. although dod still has aninfluence, its share of the market has diminishednot because dod's need for software has decreased, but ratherbecause the size of the commercial software market has exploded, generating a corresponding increase ininvestments in commercial software technology. dod made significant investments to develop ada (both ada 83and ada 95)1 and mandated its use on certain dod projects. the dod requirement to use ada appears to havebeen beneficial for custom software that has no commercial counterparts (e.g., weapon systems and performancecritical c3i software). on the other hand, this policy has frequently been counterproductive in application areasthat have strong commercial support. in these areas, dod's policy has inhibited dod from taking advantage ofexisting commercial infrastructure written in or for other languages.the changing context for dod software development7ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.growth in the commercial software industrycommercial software includes a great deal of powerful infrastructure software such as development tools,operating systems, database management systems, networking software, user interfaces, and transaction processingprograms. it also includes rich and growing sources of software for applications that are similar to some dodapplications, such as management information systems; geographic information systems; and logistics, medical,engineering and scientific, and officesupport systems. with the exception of some aerospace, transportation, andsafetycritical applications software, little of this commercial software is written in ada.in the 1990s, the computing field has been transformed by technological advances, particularly in networkingand in lowcost personal computing with associated tools. while these advances have had relatively little impacton traditional realtime embedded systems, they have completely altered the character of commercial informationsystems and the processes used to develop them. information systems are now commonly built with a two orthreelevel clientserver architecture, and with a graphical user interface that is logically separated fromcomputational steps and from a relational database. specialized tools and fourthgeneration programminglanguages (4gls; see glossary, appendix c) have been developed for building this class of applications. suchtools and languages, exemplified by visual basic and powerbuilder, are extremely efficient for building small andmedium sized applications, particularly where the demands for reliability and availability are less stringent thanthose for realtime embedded systems. similar tools are now becoming available for the deployment ofinformation systems across organizational intranets and the world wide web. because in certain domains thesetools and languages operate at a higherlevel than does any traditional programming language (including ada),they are often the most appropriate way to prototype and develop information systems. finally, growth ininternetbased software has increased the already rapid pace of product development in the commercial softwareindustry.obstacles to broad adoption of adaone goal of the inclusive and extensive process undertaken to develop ada was to create a language thatwould be widely adopted by the software community, beyond dod. utilizing commercial technology has becomemore important to dod in recent years, as a combination of declining financial resources for dod and greatstrides in commercial developments across all areas of advanced technology has led to an increasing emphasis onleveraging commercial technology in developing defense systems (dod, 1994b, 1995b).ada has taken its place among the better known and widely used thirdgeneration programming languages(3gls; see glossary, appendix c); however, it has not become as popular as its proponents had hoped. one studyof programming language use estimated that ada 83 applications constitute only 2 percent of all computerapplications in u.s. inventories, and slightly more than 3 percent of all function points (jones, 1996b). ada is usedprimarily within the dod community. beyond that community, it has been adopted by some software developersfor the civilian market, especially where there is potential defense market crossover or where there are similarrequirements, such as in commercial aviation, process control, and medical instrumentation.2 however, thiscommercial use is a small fraction of the total commercial software market.another indicator of ada's limited market penetration is the supply of and demand for adatrainedprogrammers. jones (1996b) estimates that of the 1.92 million professional programmers in the united states,90,000, or less than 5 percent, are ada 83 programmers.3 in an informal review of software engineeringemployment opportunities advertised in two major newspapers, the committee noted that of more than 1,000references made to individual programming languages and tools,4 fewerthe changing context for dod software development8ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.than 3 percent of the citations referred to ada; in comparison, c and c++ each accounted for more than 23 percentof the references. 5 while there are many ways to look at ada's current market share, employment opportunitiesand professional growth were recurring concerns expressed in many of the presentations made to the committee.given current conditions and probable trends, it is unlikely that the use of ada, including the recent ada 95version, will grow significantly beyond the doddominated and related commercial niche of highassurance,realtime systems where it is already strong. some of the principal reasons for this conclusion are discussed in thefollowing sections.low commercial awareness and limited sponsorshipada has never attained the broad following associated with languages such as c++ and, most recently, java.market research indicates that nearly all programming language decision makers in nondefense industries areaware of cobol, c, c++, fortran, and pascal, but only twothirds are aware of ada; only onefifth are familiar withada's characteristics (telos, 1994).6in decisions affecting adoption of programming languages, nontechnical factors often dominate specifictechnical features. these factors include the broad availability of inexpensive compilers and related tools for awide variety of computing environments, as well as the availability of texts and related training materials. inaddition, grassroots advocacy by an enthusiastic group of early users, especially in educational and researchinstitutions, often has broad influence on adoption of programming languages. these advantages were largelyabsent when ada was introduced in 1980. in contrast, c++ and java both have achieved widespread acceptanceand use. the strong military orientation of the publicity generated for ada also may have served to alienatesignificant portions of the academic and research communities.historically, dod has been ada's only sponsor, and ada has been focused almost exclusively on the militaryniche occupied by dod and its contractors. in the past, ada technology was subject to export control restrictions.the development of tools and components funded by dod was targeted to dod organizations and defensecontractors. people and institutions outside dod who were interested in ada found it difficult to acquirecompilers and training resources.many technical organizations evaluated ada and its associated tools in the mid1980s and decided not to useit. most of those organizations have committed significant resources to other languages and technologies; thus theyare unwilling to reconsider ada, even though ada 95 is significantly different from ada 83 and the tools are farmore advanced. beyond the doddominated niche, some organizations are unwilling to reconsider ada becausethey continue to view ada as a language that is suitable only for military applications.recently, dod's ada joint program office has begun to promote the academic use of ada by awardingeducational grants and making lowerpriced compilers available. while these activities have had an impact (seethe next section), by themselves they are unlikely to be enough to make ada popular. they have not been matchedby development of infrastructure to make it attractive to the research community, where advanced softwaredevelopment is carried out and graduate students are trained.limited extent of academic instruction in adathe popularity of a programming language in the academic world and its use in industry are often linked.schools feel pressure to teach the languages that appear to be demanded most by the labor market. at the sametime, the adoption of computer languages in the classroom can lead to commercial use.7 a manager who has beenexposed to a language in school is more likely to be confident aboutthe changing context for dod software development9ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.trying it out, and even more confident if it is one that many recent graduates appear to know. university researchand development groups are also influential, since the advanced software concepts they develop tend to influencethe next generation of commercial products. a language that is widely taught is more likely to be widely adopted.ada has not been widely taught in colleges and universities, particularly compared with pascal, c, and c++;until recently, even the military academies taught programming in languages other than ada. a survey of morethen 2,300 colleges and universities worldwide that have computer science curricula identified only 285institutions that offer any courses in ada; 237 of them are in the united states (iitri, 1996), and they includemany small institutions, among them community colleges and technical institutes. few of the leading computerscience programs in the united states, as ranked by the national research council's assessment of graduateresearch programs (nrc, 1995), provide instruction in ada: only 6 of the top 53 programs (and 1 of the top 10)were identified by the 1996 survey as offering ada courses.however, the iit research institute's 1996 survey of ada instruction also found that in fewer than 3 years,there was a 47 percent increase in institutions offering courses in ada and a 43 percent increase in the number ofada courses offered (both measured worldwide). a survey of institutions adopting ada as a foundation languagefound that from 1993 to 1996 the number increased from 57 to 147 (feldman, 1996).8 yet the total is stillcomparatively small, and it is unclear how long this trend might continue without the strong sponsorship providedby dod.limited availability of ada tools and compilershistorically, compilers and other languagespecific tools for ada have been significantly more costly andslower in coming to market than those for c and c++. initially, this was a matter of technology. since adaembodied new technology that provided technical challenges for compiler writers, productionquality adacompilers were not available for several years after ada's official debut in 1980. when they became available, theywere large, slow, unreliable, and expensive. this slowed dod contractors' transition to ada from other languagesand soured some early users. because c compilers are much easier to build and have a higher expected salesvolume, they have typically been the first available compilers for new microprocessors; c++ compilers haveusually followed, and ada compilers have often been the last to be available. the problems with ada compilersalso impeded the use of ada in education. thus, organizations seeking to adopt ada faced nearterm costs for newtools, especially the highpriced compilers, in addition to the cost of training people in a language that was notwidely taught in academic institutions.currently, ada compilers are comparable in quality to those of other 3gls, and the increased hardwareresources needed to run popular software, such as windows 95, make the requirements of ada compilers appearmore modest. in addition, the availability of the gnu nyu ada 95 translator (gnat) has reduced the cost andimproved the availability of ada compilers. gnat is a component of the gnu compiler suite, sharing codegeneration facilities with the gnu c and c++ compilers. the gnu c compiler is generally recognized as a highquality compiler. the gnu technology makes it comparatively easy to support new processors; therefore, the gnucompiler is likely to be one of the first available when a new processor appears. a nontechnical but important sidebenefit is the association of gnat with the free software foundation, which should help gnat to shed some ofada's military only stereotype. the entire gnu compiler suite is distributed widely over the internet, withoutcharge, and is also distributed by some hardware vendors. in addition to the freely available gnat, the maincompiler vendors (see below) also offer academic compilers to students at reduced prices.the changing context for dod software development10ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.the market for ada compilers and tools has been estimated at $200 million annually.9 the modest size of thismarket has resulted in significant consolidation of ada compiler and tool vendors over the past few years.10 thereare now two dominant suppliers: rational software corporation (which was formed by the merger of rationalwith verdix, which had previously acquired meridian) and aonix (previously thomson software products, whichacquired alsys and telesoft). in addition, there are several other vendors that focus mainly on niche markets.these suppliers include the texas instruments unit that was previously tartan, tld, oc systems, ddci, rrsoftware, intermetrics, green hills, icc, and ada core technologies (which was formed to support andcommercialize gnat). several of the vendors, including the two largest, have productlines other than ada. it isnot clear how this consolidation will affect the availability and price of commercial ada compilers in the longterm.assumption that ada has to control everythingada provides some services, such as input/output, multitasking, time keeping, and interrupt handling, that aretraditionally in the domain of an operating system. early ada implementations were designed with the assumptionthat ada was in complete control of the hardware, with no operating system, and that all the software on a machinewas written in ada. this approach is effective for the programming of embedded systems, in which theapplications need to run without an operating system. since ada hides differences between operating systems,these characteristics make applications more portable.however, these features also mean that, when compared with a language in which services are obtained byoperating system calls, it is harder to write an ada runtime system. it is also more difficult to port it to a newoperating system, although this cost can be balanced by the benefit of reduced effort in writing and porting adaapplication programs. in early ada applications, when compiler vendors lacked expertise in realtime kernelbuilding, the runtime systems were a frequent cause of complaints related to the closed nature of the interface.developers of embedded systems applications wanted to have more direct control over the hardware resources.developers of conventional operating system applications were hampered by the lack of access to the fulloperating system functionality, and by the incompatibility of libraries written in other languages with the adaruntime system. the situation has improved in recent years; ada vendors have adopted a more "open systems"approach in which the ada runtime system is layered over a commercial realtime kernel or a traditional operatingsystem, and ada 95 supports interfaces to other languages.need for adacompatible application programming interfacesan application programming interface (api) is a set of procedure and function specifications that providesaccess to the capabilities of a reusable software component, such as an operating subsystem for "windows" ornetwork communications. the vendors of most commercial offtheshelf (cots) software components typicallyprovide a c language api. for the cots component to be usable by an ada application, an adacompatible apimust be provided; this does not mean, however, that the cots product itself needs to be written in ada (amisconception that was evident in several presentations to the committee). a vendorprovided ada api often lagsthe c version by months or years (a very long time in the computer industry), and often costs more. an adadeveloper can create an interface to a c language api without vendor support, but doing so can require intimateknowledge of the particular cots product and/or the ada language implementation. the earlier implementationof nonada apis, and greater vendor involvement, also have led to earlier standardization. thus, the time delayand extra cost or effort of obtaining an ada api, and the delay in standardization, have become disincentives forthe changing context for dod software development11ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.the use of ada. an added disincentive is the challenge of keeping ada apis current with the frequent changes incots product features.labor market forcessoftware engineers are likely to be interested in enhancing skills that they expect to be most valuable in thesoftware engineering marketplace, which is now dominated by commercial opportunities. thus, programmers havemoved quickly to learn java and hypertext markup language (html; used to develop pages for the world wideweb) because they see these as the next wave, which can carry them to new career opportunities. similarly,software engineers might avoid using ada if they see it as limiting their careers. given the cyclical nature of dodspending, recent downsizing, and layoffs, defense software engineers have reasons to consider preparing for amove to the commercial sector. even those who believe ada is technically the best solution for a given programmay face conflicting incentives in choosing a programming language.on the other hand, the committee heard testimony that, for developing the specialized software that is mostcritical to the dod mission, knowledge of the application domain is harder to obtain and more valuable thanknowledge of a particular programming language, or even of software engineering itself. thus, software engineerswho have expertise in defenseoriented applications are likely to be in greater demand in that sector than in thecommercial marketplace, where their domainspecific skills would be less applicable. likewise, employers in thedod sector are highly motivated to keep experienced engineers because of the expense of training new ones in therelevant applications, as well as the cost and delay of obtaining a security clearance for a person entering from thecommercial market. these dynamics contribute to the separation of the military and commercial markets forsoftware engineers, which is similar to the separation of those same markets for aerospace engineers.dod programming language policypolicy historydod's decision to design ada as a new programming language for embedded applications was a reaction toboth the "software crisis" of the late 1960s and early 1970s and the advent of software engineering concepts. itwas also a response to the fact that each of the military services had developed separate programming languagesthat each was planning to independently standardize, upgrade, and improve. within dod, software problems werecontributing to project cost overruns and lengthy delays in system deployment. from 1968 to 1973, the total costof dod's computer systems increased by 51 percent, even though hardware costs were decreasing dramatically(fisher, 1976). while some have argued that this increase could be interpreted as the legitimate cost of obtainingnew functionality, at the time it was viewed as symptomatic of software development problems.one visible aspect of dod's software crisis was that systems were being developed in many differentprogramming languages for many different computers, diluting resources and increasing the cost and complexityof maintenance. many of the systems were written in assembly language for specialized, proprietary processors, orwritten in programming languages unique to a particular project or contractor. there was never a thorough countof the number of languages in use, but a widely cited estimate is "at least 450 generalpurpose languages anddialects" (hook et al., 1995). the abundance of languages made it uneconomical to develop highquality softwaretools and was an obstacle to using programmers and software across projects. it was also a major source of postdeployment problems in areas such as interoperability, operations, and maintenance, and it hindered effectiveproductlinethe changing context for dod software development12ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.management. maintenance of compilers, assemblers, linkers, and other tools for all these languages was asignificant burden, as were the hiring and training of programmers. in many cases, a system could be maintainedonly by its original developer; such vendor "lockin" added to maintenance expenses.for these reasons, it appeared desirable for dod to converge on a minimal set of programming languages.representatives of various dod and allied defense organizations worked together to define the dodrequirements for highorder languages. an early outcome was the release of dod directive 5000.29 (dod,1976). the directive required the use of an approved highorder language, unless another choice could be shown tobe more costeffective, and it established a single point of control for each language. however, it was determinedthat none of the existing languages met the requirements for embedded systems, which were estimated torepresent more than half of all dod software costs in 1973 (fisher, 1974).dod decided to design a new language that would serve as the single, common, highorder language. whiledod had other software problems that went deeper than those associated with programming languages, itappeared that programming language problems were amenable to a technical solution. moreover, the conversion to anew, common, highorder programming language was viewed by some as a vehicle for dodwide efforts toimprove software engineering. the new dod language, which eventually became ada, was intended to be amodern programming language that would reflect the accumulated knowledge of programming language designand provide the appropriate set of concepts and features for implementing embedded systems.representatives of key stakeholders, including organizations within dod, its contractors, and many of theworld's software engineering and programming language experts, were involved in the identification ofrequirements, the design and evaluation of the early prototype languages, and the refinement of the preliminaryada design. the end product, eventually named ada 83, was officially released in 1980 and became a standard in1983. it was recognized as a powerful, modern programming language that addressed dod's stated requirementsfor embedded systems. however, ada's adoption within dod and by its contractors did not proceed as quickly asanticipated.in 1983, undersecretary of defense richard delauer established a policy mandating the use of ada for allnew missioncritical applications. the policy specified a waiver process, whereby other dod authorizedlanguages (cms2m/y, jovial j3/j73, fortran, cobol, tacpol, spl/1, and c/atlas) could also be used.while the preferential treatment for ada helped, ada support software was not yet mature, and there were stillmany contract awards across the services where ada was not selected. as a result, systems developed in adacontinued to be in the minority. that situation led to the establishment, in 1987, of the current policy, specified bydod directive 3405.1 (dod, 1987a), which prescribes the use of ada for most dod procurements and internaldevelopments. the original list of approved highorder languages was expanded to include minimal basic andpascal.the proliferation of programming languages within dod systems, one of the original reasons for mandatingthe use of ada, appears to have diminished over time. most new dod software is written in ada or one of a fewother languages. as of 1994, 79 percent of all dod missioncritical software was written in 3gls; of this code, 33percent was written in ada, 37 percent in the other approved highorder languages, 22 percent in c, and 3 percentin c++ (hook et al., 1995). it is difficult to tell how much of this consolidation of language use is a result of therequirement to use dodapproved languages, given that cthe second most widely used language in dodhasnever been on dod's list of approved languages. certainly larger market and industry forces have also been atwork. for example, growing standardization in the computer industry has resulted in fewer new computerarchitectures being introduced, particularly when compared with 20 years ago, resulting in fewer assemblylanguages in use. similarly, the rate of growth in new 3gls has diminished since the 1970s and has beenovertaken by development of the infrastructure and culture needed to build software involving components indifferent programming languages.the changing context for dod software development13ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.however, the growth of 4gls indicates a potential for a new proliferation of programming languages. forexample, one study lists 115 languages (out of a total of 455 currently active languages) that meet one definitionof a 4gl, i.e., that the language requires 30 or fewer statements to encode one function point (jones, 1996c). 4glstypically are not intended to serve as generalpurpose programming languages, but they may include a lowerlevelsublanguage that is more general and allows users to program functionality that is not built into the 4gl. hook etal. (1995) found that 4gls are used increasingly for dod automated information systems applications; thecommittee also heard from dod representatives that 4gls increasingly are being used for rapid developmentspecial applications. thus, it appears that dod will continue to operate in a "polylingual" world.11ada's place in current dod programming language policydod policy states that ada is to be the "single, common, computer programming language for defensecomputer resources used in intelligence systems, for the command and control of military forces, or as an integralpart of a weapon system" (dod, 1987a). the policy allows for the use of other, previously authorized languagesin deployment and maintenance, but not for redesign or addition of more than onethird of the software. ada is tobe used "for all other applications, except when the use of another approved higher order language [hol] is morecosteffective over the application's lifecycle." it ranks as preferences (1) offtheshelf applications packages andadvanced software technology, (2) adabased software and tools, and (3) approved standard hols. exceptions areallowed only by the granting of a waiver, which requires that the alternative language be more costeffective andthat it be chosen from the list of dodapproved languages. neither ada use nor a waiver is required for cots orcontractormaintained software developments or for vendorprovided updates.implementation of policy on waiversrequests for waivers to develop systems in different languages are handled at a very high managementlevelthe offices of the assistant secretary (c3i) or the service acquisition executivesšand are reviewedindependently from the requesting program's other key decision milestones (such as the defense acquisitionboard and major automated information systems review council). in practice, such waivers have rarely beenrequested. the committee was informed that 31 waivers had been granted since 1992 across the services (3 by thearmy, and 14 each by the navy and the air force). because most requests for a waiver have been granted, thisrelatively small number of approved waivers suggests that only a very small percentage of the many projects thatdid not use ada actually submitted a waiver request.12based on briefings and testimony to the committee and the information discussed above, the committeeconcluded the following about the implementation and some of the effects of the ada waiver policy:1. many projects have ignored or manipulated the policy on waivers, employing languages other thanada without the required waiver.2. many project managers fear that requesting a waiver will reflect badly on them; this has caused someto employ ada where it is not costeffective.3. the dod and services' authorities generally have the capability to grant waivers that are justified,given the small number of waiver requests.the changing context for dod software development14ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.4. the granting authorities do not have the capability and expertise to evaluate the technical merits andlongterm consequences of the full number of ada waiver requests that would be made if there werefull compliance with the policy.in organizations with a high level of understanding of software, similar waiver processes can work reasonablywell. waivers are requested by developers where they make sense; waivers are granted by managers where theymake sense; and the developers and managers know enough about software to reconcile differences of opinion onwhat makes sense. one of the recurring themes in successful dod projects using ada was that ada was selectedfor appropriate technical and economic reasons. however, selection of ada solely to satisfy dod's overall policyon programming languages has not been a guarantee of project success.importance of appropriate expertisecustodians of mandates on software use who do not possess sufficient knowledge of software tend to rely toomuch on narrow interpretation of the mandates, and dod historically has not had a high level of softwareexpertise. the defense science board found in 1987 that dod lacked adequate career paths for softwareprofessionals and had long ignored its software personnel problems (dod, 1987b). testimony heard by thiscommittee indicated that although the level of software training has increased, such problems persist. forexample, cutbacks in several dod organizations in the early 1990s appear to have caused numerous softwareexperts to leave dod for industry. the approach that the defense science board recommended was, "do notbelieve dod can solve its skilled personnel shortage; plan how best to live with it, and how to ameliorate it."level of applicabilityanother recurring issue and ambiguity in current dod policy on programming languages is that it reflects asystemlevel view of software that does not consider subsystems independently. for example, for a project withthree subsystems(1) an operational flight program (all new software), (2) a simulator (based on an existingsimulator written in c), and (3) a groundbased test capability (combining new and legacy components in multiplelanguages)current dod policy encourages project managers to either write all subsystems in ada or apply for awaiver for all subsystems. this approach leads to a simplistic choice between two options, neither of which isoptimal. a clear, more flexible policy is needed that allows project managers to optimize programming languageuse at the subsystem and component level, without incurring a penalty of additional administrative overhead forthe division into components.implicationsto be effective, dod's policy requiring the use of ada must include positive incentives for doing so, and itmust be implemented closer to the project level within dod. the current policy fails on both accounts. it has oftenhad negative effects on dod software engineering processes, in particular because dod's policy on waivers foruse of alternative programming languages has been implemented unevenly by dod staff who lack the necessarytechnical knowledge, understanding of the relevant details of system design, or the motivation to consider longterm and servicewide objectives. many dod personnel testified to the committee that waivers are perceived asdifficult to defend (even thoughthe changing context for dod software development15ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.it appears that most requests are actually granted). this perception frequently has led to manipulation, bypassing,or simply ignoring of the waiver process. narrow interpretation of the policy has led to a number of poor decisionsto use ada, even when other solutions offered significant improvements in capability. for example, certaingraphical user interface development tools have frequently not been used simply because they did not generateada or were not written in ada.dod investment strategydod weapon systems programs and commercial organizations both understand that significant postdevelopment investments are needed to keep software systems functioning effectively. for example, citibankspends 80 percent of its software budget on sustaining and enhancing existing code.13 in the programminglanguage area, eric schmidt, chief technology officer at sun microsystems, has stated that "several years" liebetween java and black ink (aley, 1996). it is reasonable to assume that ada 95 will also require ongoinginvestment.dod has assigned the responsibility for sustaining ada to the defense information systems agency (disa),under the assistant secretary of defense (c3i). it is the committee's understanding that disa's current plan is toshrink the originally planned budget of $10 million in annual support for ada 95 to nearly zero by the end of1997. the committee does not believe that ada 95 is an exception to the general rule that software requirescontinuing investment to remain effective; briefings from disa indicated that it has made an assumption to theeffect that "the language exists and is mature," meaning that the commercial sector will provide support. thecommittee disagrees with this assessment.the barriers to commercial adoption of ada discussed above in this chapter are a significant concern, becausewithout support and promotion by critical customers such as dod and the commercial safetycritical community,there is a serious danger that the ada tool and compiler industry will shrink to the point that it can no longerprovide widespread support to warfighting systems. this will ultimately increase dod's costs, because it will haveto take over full maintenance and development for ada tools. dod may also have to use programming languagesthat will result in more costly development and maintenance for its missioncritical systems. in addition toincreased cost, any decrease in quality or increase in schedule could threaten dod's warfighting adaptability andreadiness.dod remains the key customer for ada technology. although ada 83 is being used outside dod for thedevelopment of critical applications, the ada tool and compiler market remains dependent on robust support fromdod. even the perception of dod pulling away from its support for ada could dramatically affect ada vendors,at a time when the industry is in the process of assimilating ada 95. uncertainty over dod's programminglanguage policy and investment strategy is already affecting the ability to find capital to invest in adarelateddevelopment.the most critical impact of not sustaining ada is the consequent reduction in support for dod's 50 millionexisting lines of ada missioncritical software. without dod support, ada will begin to resemble otherunsupported dod languages such as jovial and cms2. missioncritical programs relying on ada code will beforced to choose between spending time and money to keep their ada support current and spending even greaterresources to convert their software to another language.summary of ada trendstables 1.1 and 1.2 summarize the differences between the past context (1970s and early 1980s) in which thecurrent ada policy was developed, and the current environment. the change in context is sufficient to warrant arestructuring of dod's policy and strategy for ada.the changing context for dod software development16ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.table 1.1 past and present contexts for ada: generalpastpresentsome chance for ada to be a leading commercial languagevirtually no chance for ada to achieve a commercial lead,except in niche areassome chance that ada could drive other software practicesvirtually no chance for ada to become a driver of othersoftware practicesfair chance that ada could become the leading highassurance, realtime (ha/rt) languageada generally considered the strongest (ha/rt) languagein this area, but others widely usednew software mostly custom, requirementsdrivennew software mostly (nonada) cotsdriventable 1.2 past and present contexts for ada: department of defensepastpresentdod a dominant software playerdod a large software playersecondary role in dod for softwareprimary role: key to dod goal of information dominanceno dod ada legacy code50 million lines of dod weapon systems ada legacy codedod committed to major ada development investmentdod preparing to drop its investment in sustaining adacritical questionsthe discussion above indicates that there are serious problems with dod's current policy regarding ada,including the lack of guidance provided to dod personnel and contractors for use of ada, uneven implementationof the waiver process, and unrealistic investment strategies. in the course of responding to its charge to recommendways for improving dod software policies and strategies regarding ada, the committee identified several criticalquestions; they are summarized below and addressed in the remainder of this report. what is the relationship between programming languages and software engineering practices? asembodied in dod directive 3405.1 (dod, 1987a), dod's current policy for software development is aprogramming language policy. however, the choice of ada as the programming language is insufficientto ensure the development of highquality, reliable software systems for defense missions. chapter 2addresses the importance of software engineering practices and their relationship to programminglanguages, and points out connections that dod policy should take into account; chapter 4 discussesimplementation of a broader dod software policy. are there application areas where using ada makes an appreciable positive difference? in applicationareas where powerful nonada commercial software support is available, ada is unlikely to be costeffective. however, for some dod software applications, there are few commercial counterparts, andada may have advantages. these issues are discussed in chapters 2 and 3.the changing context for dod software development17ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved. if ada is superior in some areas, is a policy requiring its use appropriate? this issue and a number ofother policy alternatives are discussed in chapter 3. for whatever policy requirements are appropriate, can dod establish a workable set of criteria andprocesses for recognizing exceptions?  these issues are discussed in chapter 4 and are addressed incommitteesuggested modifications of a may 1996 dod draft software management policy presented inappendix a. what specific investment strategies are needed to keep ada strong? this issue is discussed in chapter 5.notes1. the cost to dod of developing ada 95 has been estimated by the ada 95 program manager, christine anderson, as being in the rangeof $29 million to $35 million (personal communication, july 5, 1996). ada 83 investments were likely much greater but are difficult toquantify.2. for descriptions of nondod projects using ada, particularly in aerospace, transportation, and telecommunications, see "ada successstories," maintained by the ada information clearinghouse, located on the world wide web at http://sweng.fallschurch.va.us/adaic/usage.3. if all programming activities are included (i.e., applicationoriented programming by other professionals), the total number ofprogrammers increases to 3.45 million, less than 3 percent of which are ada 83 programmers.4. the newspapers were the april 21, 1996, edition of the los angeles times and the march 24, 1996, edition of the washington post.5. other significant 3gls were cobol (11 percent) and java (4 percent). significant 4gls were visual basic (13 percent), powerbuilder(10 percent), and foxpro and visual c++ (4 percent each).6. the industry groups surveyed were automobile services, financial services, medical devices, and industrial machinery.7. exceptions to this generalization include cobol, which was never a popular language in academia but is used widely in business anddefense applications, and pascal, which was popular for many years in universities but not in industry.8. "foundation" is defined as one of the initial computing courses taken by students majoring in the field.9. bob mathis, executive director, ada resource association, personal communication, september 8, 1996.10. the committee included representatives of two firms that sell ada products: rational and intermetrics.11. in a position paper to the committee, victor vyssotsky advocated stronger encouragement for programmers to learn numerouslanguages (vyssotsky, 1996).12. as detailed above, only onethird of the 3gl code written for weapon systems is in ada. because any software produced since thepolicy went into effect in 1987 (except for software not maintained or upgraded by dod) would require a waiver, many more than a fewwaivers each year should have been approved for weapon systems alone. in addition, the use of ada for automated information systems indod is even lower in relative and absolute terms.13. gerald pasternack, citibank, presentation to the committee, may 23, 1996, washington, d.c.notes18ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.2software engineering and the role of ada in dod systemsrecent progress in software engineering includes the development of models and technology to improvesoftware processes and architectures. this chapter highlights some of these approaches as a framework for crafting adod software policy that is more broadly conceived than the current policy on programming languages, and as amethod of evaluating ada's role in dod systems. in addition to evaluating ada's capability for supportingsoftware engineering processes, this chapter compares ada with other thirdgeneration programming languages(3gls). technical comparisons between ada and other languages can be made with greater confidence than canquantifying the performance of programming languages. the committee found the quality of the data available forsuch empirical analyses to be lacking; in addition to discussing these data limitations the committee thus suggestsways to improve collection of and access to needed data. in the absence of data that are reliable enough to serve as abasis for sound conclusions, the committee's findings are based on a combination of those data, technicalcomparisons, anecdotal project experience, and, ultimately, on the deliberations of the committee and its expertjudgment.software engineering process and architecturein the 1980s, when dod's current programming language policy was first established, implementation ofsuch a policy was perceived to be the most straightforward approach to improving dod's software engineeringcapability. but in the past decade software engineering technology and practices have changed fundamentally.examples of important developments include advanced tools and techniques such as computerautomated softwareengineering (case) tools, application generators, and objectoriented methods; process improvement, includingiterative/spiral development processes, the software engineering institute's capability maturity model, the airforce software development capability evaluation, and the iso 9000 quality standard; productline managementsuch as architecturedriven processes and components and common operating environments; and technology forsoftware engineering and the role of ada in dod systems19ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.heterogeneous software, including open systems, internet, and common object request broker architecturestandards.reflecting these fundamental changes, a consistent theme emerged throughout the committee's deliberationsand in presentations from industry and dod experts: programming language is important, but not as important as athorough understanding of application requirements, a mature software development process, and a good softwarearchitecture. while understanding of requirements is certainly an important factor in project success, it represents alargely languageindependent aspect of software engineering and thus is not emphasized in the followingdiscussion. process maturity and architecture quality, on the other hand, represent aspects of software engineeringthat are influenced and supported by programming languages and the environments in which they are developed.furthermore, one very important aspect of "good" processes and architectures is their ability to accommodatechanges in requirements.1while there is much debate over what constitutes an architecture,2 the following observations are made tosummarize architecture's importance and its close linkage with modern software development processes:3 achieving a stable software architecture represents a significant project milestone at which the criticaldecisions to make, buy, or reuse software should have been resolved. this milestone in a project's lifecycle represents a transition from the exploratory stage (characterized by discovery and resolution ofnumerous unknowns and sources of risk) of a project to the development phase (characterized bymanagement according to a particular development plan).4 architecture representations provide a basis for balancing the tradeoffs between the problem space (i.e.,requirements and constraints) and the solution space (i.e., the product design, implementation, andquality). the software architecture and process provide the framework for most of the important (i.e., highpayoffor highrisk) human communications among the analysis, design, implementation, and test activities. poor architectures and immature processes often underlie many project failures. a mature process, anunderstanding of the primary requirements, and a demonstrable architecture are important prerequisitesfor predictable outcomes. architecture development and process definition are the intellectual steps that map a problem to itssolution without violating existing constraints; these tasks require human innovation and cannot beautomated.dod's formulation of an improved policy regarding its use of the ada programming language should takeinto consideration the fundamental need for improved software architectures, more effective and maturedevelopment processes, and increased process automation. because dod's requirements for qualityšgenerallyhigh reliability, stateoftheart performance, and maintainability by dod personnelšusually cannot becompromised, dod software development projects often require increased funds and/or extended schedules. thefour subsections below describe process and architecture as elements fundamental to needed improvements insoftware economicsšit is this significance of architecture and process that motivates the committee's belief thatdod should expand its software policy to encompass more than just a programming language policy. thediscussion below focuses on improving the costeffectiveness of dod software and achieving a better return oninvestment (roi); it is assumed that quality is held fixed at the levels necessary for dod systems.software engineering and the role of ada in dod systems20ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.economics of software engineeringmost software development costs are a function of four basic parameters:1. the size of the software end product in terms of humangenerated source code and documentation;2. the process employed to produce the software;3. the environment and tools employed to produce the software; and4. the expertise of the personnel involved, that is, the capability of the software developers.one very important aspect of software economics (as represented in today's software cost models) is that therelationship between cost and size exhibits diseconomies of scale: the cost per unit of functionality increases withsoftware size. this relationship stems primarily from the complexity of managing interpersonal and inter teamcommunications; as the number of team members increases, the complications relating to the team members'differing perspectives and backgrounds increase even more rapidly. given the factors affecting softwaredevelopment costs, economic leverage is best achieved by focusing on technologies that enable the following:51. reducing the size or complexity (or improving the architecture) of what needs to be developed;2. improving the development process; and3. employing better environments and tools to automate the process.most software experts would distinguish among the above factors; they would also acknowledge significantinterrelationships. for example, tools enable reduction of the amount of source code and process improvements;attempts to reduce size lead to process improvements; and improved processes drive tool requirements. theseinterrelationships mean that even though programming languages do not directly affect project outcomes, they canhave significant indirect effects.reducing the complexity of software productsin general, the most significant step toward reducing cost and improving roi is to design an architecture thatachieves product requirements and quality goals with the minimum amount of humangenerated source material.this is the primary motivation behind development of highorder languages (e.g., ada 83 and 95, c++, andfourthgeneration programming languages), use of automatic code generators (case tools and graphical userinterface builders), reuse of commercial offtheshelf (cots) software products (operating systems, "windowing"environments, database management systems, "middleware," and networks), and reliance on object orientation(encapsulation, abstraction, component reuse, and architecture frameworks).since the difference between large and small projects has a greater than linear impact on lifecycle cost, usingthe highestlevel language and appropriate cots or nondevelopmental items can lower costs significantly,especially in warfighting domains where largescale systems are the norm. furthermore, simpler is generallybetter: reducing its size usually makes a program more understandable, easier to change, and more reliable. onetypical negative side effect is that higherlevel abstractions tend to degrade performanceši.e., increase resourceconsumption, whether in processor cycles, memory usage, or communications bandwidth. fortunately, thesedrawbacks have been greatly offset by improvements in hardware performance, compiler technology, and codeoptimization (although much less so in embedded platforms). ada, and particularly ada 95, allows for reduction inthe source size ofsoftware engineering and the role of ada in dod systems21ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.software products through language features that support abstraction, objectoriented programming, andcomponent integration (e.g., of reusable components, cots products, and legacy components). the language c++provides similar advantages in the commercial market.in numerous dod domains, a common approach today is to maximize the use of cots products.6 while thisis certainly desirable as a means of reducing the overall amount of custom development, it has often not been a"silver bullet" in practice. table 2.1 identifies some of the advantages and disadvantages of employing cotsproducts, compared to custom software, in dod domains.the advantages of using cots rather than custom software are significant, but there are still applicationareas (particularly in warfighting) in which the advantages of having control over reliability, performance, or rapidenhancements provided by custom software are compelling. the disadvantages of cots are not sufficient toperemptorily drop that approach, but they point to areas in which architectural tradeoff analysis and riskmanagement approaches will be needed.improving software processesthe importance of a mature software development process has been well established (cstb, 1987; dod,1987b). modern software development processes have moved away from the conventional waterfall model, inwhich each stage of the development process depends on completion of the previous stage. while there arevariations, current concepts call for an initial version of a system to be constructed rapidly early in thedevelopment process, with an emphasis on addressing the highrisk areas, stabilizing the basic architecture, andrefining the driving requirements (with extensive user input where possible). development then proceeds as aseries of iterations ("spirals," "increments," "generations," "releases," and other terms have been used), building onthe core architecture until the desired level of functionality, performance, and robustness is achieved.software cost models, such as the cocomo model (boehm et al., 1996), have been updated to reflect theuse of modern software development processes and can be used to quantify the importance of process. theparameters defining the effects of process on the cost and schedule estimates produced by cocomo include thefollowing: application familiaritythe developer's degree of domain experience; process flexibilitythe degree of contractual rigor, ceremony, and freedom of change inherent in theproject "contract," "vision," and "plan"; architecture definition and risk resolutionthe degree of technical feasibility demonstrated prior tocommitment to fullscale production; teamworkthe degree of cooperation and shared vision among stakeholders (buyers, developers, users,and personnel responsible for verification, validation, and maintenance, among others); and software process maturitythe maturity level of the development organization, as defined by thecapability maturity model (paulk et al., 1993).cost estimates produced by cocomo 2.0 show that the difference between a good and bad process for alarge (300,000 lines of source code) program will often exceed a factor of 1.3 in the length of time it will take for ateam to develop a software product, a factor of 2 in cost, and a factor of 5 in quality (delivered defect rate).realization of this relationship has led to significant investments and advances in software process improvementtechniques over the past 10 years, exemplified by dod investment in the capability maturity model, developedby the software engineering institute at carnegie mellon university.software engineering and the role of ada in dod systems22ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.table 2.1 advantages and disadvantages of commercial offtheshelf (cots) and custom softwareintegration of cotscustom developmentadvantages predictable license costs broadly used, mature technologies immediately available dedicated support organization hardware/software independence rich functionality frequent upgrades complete freedom smaller, often simpler often better performance control of development and enhancement control of reliability tradeoffsdisadvantages upfront license fees recurring maintenance fees dependence on vendor sacrifices in efficiency constraints on functionality integration not always trivial no control over upgrades and maintenance unnecessary features that consume extra resources reliability often unknown or inadequate scale difficult to change incompatibilities among vendors licensing and intellectual property issues difficulties in testing and evaluation development expensive, unpredictable availability date unpredictable maintenance expensive portability often expensive drains expert resourcesinfluence of software environments, tools, and languages on the software engineeringprocessthe tools and environment employed in the software engineering process generally have a linear effect on theproductivity of the process. compilers, editors, "debuggers," configuration management tools, traceability tools,quality assurance analysis tools, test tools, and user interfaces provide the foundation for carrying out the processand maximizing automation. however, the maturity, availability, and performance of these toolsand theirprocurement and maintenance costsmust be taken into account. cost models indicate that tools and automationgenerally enable cost savings ranging from 30 to 60 percent (see box 3.2 in chapter 3).as mentioned above, environments and tools have indirect effects; however, they also enable certainimprovements in process and reductions in size that have much greater impacts. thus, the view that the quality ofthe software engineering process is independent of the programming language can be misleading. languagestandardization has led to tools for automated support of configuration control and increased automation of qualityassessment (through interface specification, compilation and consistency analysis, readability, and "inspectionautomation"). these, in turn, have led to practical and significant process improvements, such as iterativedevelopment, architecturedriven design, and automation of documentation (royce, 1990). furthermore,languages like ada 95 add objectoriented features, which have enhanced their versatility. such features, in somecases, allow ada 95 programs to implement the same function as ada 83 programs with a significant reduction inthe number of sourcesoftware engineering and the role of ada in dod systems23ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.lines of code.7 these improvements are not unique to ada 95, but absent the technical features and automationsupport that are standard in the ada environment (compiler, library manager, and debugger), many of theseprocess improvements have been impractical for other languages.over the past 10 years, ada 83 has supported the process and software engineering design goals describedabove by enabling (1) integration of components (abstraction and encapsulation, language standardization,separation of module specification from body, strong typing, and library management) that allow structured designearly in the lifecycle and incremental improvement of the breadth, depth, and performance of the evolving designthrough multiple iterations; (2) reduction of rework via early definition and verification of architectural interfacesprior to coding; (3) incorporation of configurationmanagement discipline, separate compilation, and interface andimplementation partitioning directly in the language, thus enabling environments that are much more controlledand are instrumented for single and multiple team development and management of continuous change; and (4)reliability features, allowing errors to be automatically identified earlier in the lifecycle by compiletime andruntime consistency checks. ada 95 further improves this language support.the primary point of this sectionthat the software engineering community has benefited greatly from the useof ada, owing mostly to the language's support for the transition to development of better processes and betterarchitectureswas predicted by fred brooks a decade ago (brooks, 1986):i predict that a decade from now, when the effectiveness of ada is assessed, it will be seen to have made asubstantial difference, but not because of any particular language feature, nor indeed of all of them combined.neither will the new ada environments prove to be the cause of the improvements. ada's greatest contribution willbe that switching to it occasioned training programmers in modern software design techniques.it is from such a perspective that the committee analyzed the businesscase for use of ada (chapter 3) and as aresult recommends a broader software engineering policy for dod (chapter 4).technical evaluation of ada 95 and other thirdgenerationprogramming languagesthis section provides a brief technical evaluation of the programming languages ada 95, c, c++, and java,based on the summaries of language features given in appendix b and focusing specifically on attributes related tothe development of realtime critical systems. the committee's evaluation led it to conclude that, for realtimecritical systems, ada 95 is superior to the other languages, from a technical and software engineering standpoint.it is important to recognize that some facets of this technical evaluation may change over the next several years asthe other languages, particularly java, mature and evolve in response to applications with requirements for higherintegrity or realtime multimedia interaction, for example.criteria related to critical systems development fall into two sets of categories: (1) compiletime and runtimechecking to support encapsulation and safety, and (2) support for hard realtime systems.8 criteria related toencapsulation and safety include: support of userdefined abstractions and enforcement of modularity and information hiding; compiletime enforcement of type distinctions; runtime management of pointers, arrays, and variant structures; and support for software fault tolerance and recovery.software engineering and the role of ada in dod systems24ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.with respect to these criteria, ada 95 and java fare well. ada 95 offers more support than does java forcompiletime type distinctions by (1) employing generic templates, and (2) simplifying the expression of strongtype distinctions between otherwise structurally equivalent numeric, enumeration, array, and pointer types. javaand ada provide stronger enforcement of modularity and information hiding than do c and c++, because c andc++ both provide "back doors" that allow external access to internal variables. java and ada also provide thefollowing safety features: (1) default "null" initialization of pointers, and runtime checks for null on alldereferences of pointers; (2) runtime checks for outofbounds indexing into an array and attempts to select thewrong variant from a subtype hierarchy; and (3) runtime exceptions indicating all failures of runtime checks,allowing programmerspecified exception handlers to implement appropriate fault tolerance and recovery actions.in c and c++, there are no checks to prevent the creation of dangling references to data structures, making the useof pointers more errorprone.criteria related to realtime systems development include: support for safe, static allocation of all runtime data structures; predictability of constructs with respect to realtime deadlines; and language support for realtimeoriented interactions between multiple threads of control.with respect to these criteria, ada 95 provides a number of advantages, including providing mechanisms forstatically preallocating data structures while still allowing safe and convenient manipulation of such structureswith pointers. in java, all nonprimitive data structures are allocated dynamically (on the "heap"), with theattendant danger of runtime storage exhaustion and unpredictable storage allocation and reclamation times. usingonly "static" structures in java could make this allocation predictable, but in many cases this restriction wouldcreate additional problems.ada 95 provides dataoriented synchronization mechanisms that reduce overhead and minimize the potentialfor highpriority threads being delayed indefinitely while waiting for release of resources held by lowerprioritythreads (priority "inversion"). java provides some multithreading primitives in the language and the standardlibrary, but the standard java locking mechanism provides no standard support for limiting the amount of time ahighpriority thread will wait for a lowpriority thread. the inter thread interaction model in java is based onexplicit notification rather than stateoriented guards, increasing the likelihood of race conditions, which can leadto uncertainty in data access. the c and c++ languages do not directly address multithreading and support forrealtime processing.for critical realtime code, ada 95 emerges as technically superior compared to java, c, and c++. the javalanguage has not yet been standardized and its design is still somewhat in flux, and it may evolve to providefurther support for critical and/or realtime systems. c, c++, and ada can also be expected to continue to evolve,albeit at a slower pace.from a businesscase standpoint it is too early for dod to consider java in this application domain. javamight evolve into a language with strong realtime support capabilities, or it might not. for the foreseeable future,ada provides the strongest available support for highassurance, realtime software development. as languagesdevelop attractive new capabilities, dod should be prepared to periodically perform technical comparisons, suchas the one provided here and in appendix b. but as discussed in chapter 3, such a technical comparison is onlyone part of the businesscase associated with establishing a software management policy.software engineering and the role of ada in dod systems25ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.available comparisons of ada 83 and other thirdgenerationprogramming languagesover the past 5 years several studies have concluded that, for custom software development, ada 83 is moreeffective than its leading alternatives (cobol, c, c++, fortran, jovial, and cms2) in improving softwaremaintainability and reliability, improving overall lifecycle cost, and enabling management of the risks of largescale development (mosemann, 1991; masters, 1996). these studies are based on various mixes of expert opinionand project results. the data supporting the conclusions are generally not normalized or controlled, and none of thestudies to date has been rigorously peer reviewed. this section summarizes the available information comparingada 83 with other leading 3gls. this information falls into three main categories:1. analyses of language features: comparisons of how the features of programming languages contributeto such desired properties as reliability, maintainability, and efficient programming;2. comparisons of empirical data: comparisons based on data collected from completed projects invarious languages; and3. anecdotal experience from projects: qualitative responses to project outcomes.analyses of language features9analyses of language features have the advantage of being based on full and open examination of welldefined language features. their main disadvantage is that they are partial at best and are particularly weak inassessing the complex tradeoffs among language features accomplished in the course of actual projects.the most thorough of these analyses can be found in a 1985 federal aviation administration study (ibm,1985) comparing ada 83 with c, pascal, jovial, and fortran, and in a 1991 software engineering institute study(weiderman, 1991) covering ada 83 and c++. both studies used the same evaluation scales, covering the desiredproperties of capability, efficiency, availability/reliability, maintainability/extensibility, lifecycle cost, and risk.figure 2.1 summarizes the results of these analyses, comparing ada 83 and c (ibm, 1985) and ada 83 and c++(weiderman, 1991) to the theoretical maximum score (higher numbers indicate better performance; the fulldefinitions of criteria and numerical results are provided in appendix d). the differences in the ratings for ada 83in the 1985 and 1991 studies are probably good indicators of the variability attendant on evaluations of thisnature.10 allowing for the range of variability, the most significant difference shown in figure 2.1 is ada 83'smuch stronger rating in the availability/reliability area, corroborating the results of this committee's comparativeanalysis in the preceding section ("technical evaluation of ada 95 and other thirdgeneration languages") andin appendix b.comparisons of empirical datathe major advantage of empirical project data is that the data represent the end results of projects and reflectthe various features of each language. the major disadvantage is that the varying conditions associated withdisparate projects make it difficult to assess sources of variability caused by differing definitions, assumptions, andcontexts. moreover, many of the results come from proprietary (and thus unavailable) data on project productivityand quality, such as those presented in jones (1994) and reifer (1996).11 the major source of empirical data andinformation derived from them are summarized in table 2.2 more details on the data are provided in appendix d.software engineering and the role of ada in dod systems26ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.figure 2.1 comparisons of language features.sources: software engineering institute (sei) data from weiderman (1991); federal aviation administration(faa) data from ibm (1985).one major problem with empirical data is that quantitative determination of important features such as costper source line of code (cost/sloc) and defects per 1,000 source lines of code (defects/ksloc) is confounded bydifferences in the expressive power of a source line of code in different programming languages. one way ofnormalizing is to look at source lines of code per function point (jones, 1995). however, as shown in table 2.3,these ratios have wide variability. lubashevsky (1996) reports variations in source lines of code per function pointexceeding factors of 2 for c and 6 for c++. finally, there are differences in expressiveness for the same languageacross different application domains.appendix d points out that the similarity in the data for c, ada, and c++ in jones (1994) relating to cost perfunction point and defects per function point (see table 2.2) appears simply to reflect jones's (1995) mean valuesof sloc/function point for c, ada, and c++. thus, the jones data appear to indicate that cost/sloc and defects/ksloc show little variation across programming languages. while this conclusion is perhaps warranted for cost,it is a conclusion at considerable variance with the data from other studies on defects/ksloc.the different cost/sloc values given by reifer (1996) appear to be overshadowed by potential differences inthe relative expressive power of a line of code in ada, c, and c++. however, the lower number of defects/kslocreported for ada in reifer (1996) is still significant, particularly with respect to embedded weapon systemssoftware.software engineering and the role of ada in dod systems27ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.table 2.2 comparisons of languages: summary of empirical data(study)domaindata, analysisavailable?number of adaprojectsnumber of totalprojectscost ($ per source line of code)defects per kslocafortranada 83cc++fortranada 83cc++(zeigler, 1995) compilers,toolsyes12n/a6.610.5n/an/a0.100.68n/a(nasasel, 1994, 1995)bengineeringyes15120ada 83 40% lower than fortrann/an/a4.82.10n/an/a(reifer, 1996) militaryinformation systemsno?190n/a302525n/a3.006.004.00(reifer, 1996) embeddedweapon systemsno?190n/a150175n/an/a0.300.800.60(jones, 1994)ctelecommunicationsno?manyn/a176029661180n/a0.170.290.14a ksloc: 1,000 source lines of code.b mcgarry et al. (1994); waligora et al. (1995).c values in terms of function points, rather than lines of code.software engineering and the role of ada in dod systems28ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.table 2.3 source lines of code per function pointlanguagelowmeanhighada 83607180c60128170c++3053125source: data from jones (1995).two sources of data are particularly sound with respect to comparability of projects and availability of data andanalysis. the zeigler (1995) study has the most thorough analysis of whether the differences in data on the cost andnumber of defects for ada and c could be caused by other factors. with respect to expressiveness of a line of code,zeigler analyzed lines of code per feature (loc/feature) and found that ada was about 16 percent more "verbose"than c (109 loc/feature for ada, compared to 94 for c). applying this correction to the data indicates that adaoutperforms c on the basis of cost per feature by a factor of 1.37 and on the basis of defects per feature by a factor of5.9.zeigler also analyzed the potential for confounding effects of relative software complexity, personnelcapability, and learning curve effects associated with c and ada, and presents a good case that these factors didnot cause any significant bias. zeigler thus provides a strong argument for ada programs having had lower lifecycle costs and fewer defects than c programs in the large (more than 1 million lines of both ada and c) project incompilers and tools that was the basis for his study. however, the zeigler study is suggestive, rather thandefinitive, about the applicability of this result to other domains and other teams (the development teams on theprojects studied were stable and composed of highly capable, seasoned personnel).the nasa software engineering laboratory (sel) projects described by mcgarry et al. (1994) also providesome helpful comparative data but do not cover most dod domains of interest. the sel projects are highlyprecedented, flight dynamics engineering applications that are not embedded and do not require realtimefunctionality. sel's analyses of ada initially concluded that, owing to greater reuse, ada projects enjoyedsignificant cost and schedule reductions compared to those using fortran. subsequently, application of the adaobjectoriented reuse approach in fortran projects yielded comparable gains. significantly, however, over theperiod from 1988 to 1994, the rate of defects associated with ada was less than half the level of defects seen withfortran.a subsequent nasasel study (waligora et al., 1995) corroborated the reduction in defect rate with ada,and concluded that ada development costs were 40 percent less than those of fortran, for equivalent functionality.this conclusion was based on analysis indicating that ada's generic features achieved reuse with many fewerstatements than fortran's repeated code.both the sel and zeigler analyses also concluded that programming languages were not the dominant factorin influencing software productivity and quality. sel found several other variables (objectoriented reuse, use ofcleanroom techniques, code reading) to be more significant. zeigler cites architecture and design, configurationmanagement, testing, process, programmer expertise, and management skills as more significant than theparticular programming language used.in summary, based on analysis of available empirical data and comparisons of language features, a conclusionthat ada is superior in ensuring availability, reliability, and fewer defects appears warranted. the evidence is notstrong enough to assert ada's superiority with respect to cost, but when considered with other data (appendix d),and given the lack of solid evidence indicating less expensive custom software development in other languages, acase can be made that using ada provides cost savings in building custom software, particularly for realtime,highassurance warfighting applications.software engineering and the role of ada in dod systems29ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.anecdotal experience from projectsthe current dod base of experience with ada is substantial. in dod software inventories, ada representsabout onethird of weapon systems code (hook et al., 1995), representing more than 50 million source lines ofoperational code in many of dod's most crucial systems.the aerospace industries association (aia) has stated that its member companies have all "... greatlybenefited from the software engineering support features of ada, including reduced error rates," and notes thatada has had a "substantial positive impact" especially in "large, high visibility projects such as f22, bsy2,boeing 777, and peace shield" (aia, 1996). however, aia also notes that "some [projects] have suffered becauseada support tools were not robust nor available when needed, or because ada presented interface difficulties inheterogeneous environments" (aia, 1996); aia has advocated ending dod's ada mandate.representatives from the dod services related to the committee numerous instances of success in adaprojects that were delivered (to varying degrees) on budget, on schedule, and with satisfied users. some of themost compelling data in this regard, drawn from a broad range of projects, were provided by robert kent of theair force electronic systems center (esc). according to mr. kent, esc's experience is that "ada projects have amuch higher success rate than nonada projects." he substantiated this claim with several case studies indicatingthat a substantial number of very large missioncritical applications (greater than i million source lines) have beensuccessfully delivered and maintained in ada. while the financial success of ada projects is not universal, someof the results from the case studies indicate that a mature software organization will perform better with ada thanwith other languages.other case studies presented to the committee to illustrate successful ada development include the following: air force: ccpdsr, cobra dane system modernization, react, stars demonstration project,12prism; navy: bsy2, aegis; and army: faadc2i.ten years ago, it was very difficult to find a single software success story in any programming language.today, there are several, and most of the largescale, successful dod projects have employed ada as one of thetechnologies to support their efforts to improve both processes and architectures.</font>successful ada users outside dod include doe (adasage), nasa (space station program and softwareengineering laboratory), numerous international organizations (transport canada, canadian department ofnational defense, celsius tech, eurocontrol, australian commonwealth, united kingdom ministry of defense).commercial organizations have also utilized ada in their products. a primary example is boeing corporation,which, like dod, sought a single, common programming language for its commercial missioncritical software(box 2.1).successful ada users outside dod include doe (adasage), nasa (space station program and softwareengineering laboratory), numerous international organizations (transport canada, canadian department ofnational defense, celsius tech, eurocontrol, australian commonwealth, united kingdom ministry of defense).commercial organizations have also utilized ada in their products. a primary example is boeing corporation,which, like dod, sought a single, common programming language for its commercial missioncritical software(box 2.1).the need to institute collection of data for software metricsthe committee searched for sources of data that could provide a strong scientific basis for concluding thatada is or is not a superior programming language in any given application domain. with respect to suchconfirmatory data, the committee concluded the following:software engineering and the role of ada in dod systems30ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.box 2.1 use of ada on boeing commercial airplanesdecision to use ada. in the late 1970s, boeing began to use airborne software on its 757 and 767airplanes. due to the state of practice, a large variety of languages and language processors were used, thusmaking the application of standards difficult. in 1985, boeing's commercial airplane group (bcag) initiated aprogram to solve the airborne software language problem. the first step in the initiative was to choose apreferred language. the major elements of the criteria were support of structured programming practices,highorder language, block structured language, portability, and understandability. additionally goals includedthe use of software engineering principles such as information hiding, abstract data types, and string typechecking; the ability to specify interfaces precisely; and the use of standardized fixedpoint and floatingpointarithmetic. the evaluation process involved consulting with several key suppliers. the process resulted in theselection of the ada language.preparation to use ada. bcag relies on its suppliers to provide airborne software for its commercialairplanes. hence, preparation to use ada had to be a joint program with its suppliers. the charter of the jointprogram included evaluating compilers, preparing personnel to use ada, and sharing of operationalexperiences in the use of ada. several joint meetings were held over a period of years, and a newsletter waspublished to share information and insights. boeing also prepared guidelines to define a subset of ada foruse in safetycritical applications. the guidelines benefited from input from the joint program and otherindustry sources.experience with ada. the use of ada has significantly reduced the number of different programminglanguages used on the boeing 777. ada was used on 60 percent of the systems on the 777 and represented70 percent of the lines of code developed. no correlation was found between the language used and thenumber of problems found on a system. the other principle language used in new development was c. therichness and complexity of the ada language helped knowledgeable users with mature tools achieve modestgains in productivity. however, the complexity of the language caused problems for other users who had towork through compiler problems. a key lesson was that the need for retraining was not adequatelyunderstood.future plans for use of ada. bcag expects to continue its use of ada for airborne application. astandard language allows the use of tools to aid in the development of software that would be difficult orimpossible to implement in a multiplelanguage environment. the use of ada in the future would be improvedby greater consistency among the available compilers.source: leonard l. tripp, boeing commercial airplane group, personal communication, august 27,1996. the data are uneven. the ada community has collected a good deal of data on dod's and otherorganizations' experience with ada, but comparable data are not available on dod's experience with c,c++, and other languages. the data are largely unavailable. the software data that have been collected are largely in proprietarydatabases held by dod contractors, consultants, or commercial costmodeling or market analysis firms.software engineering and the role of ada in dod systems31ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved. the data lack common points of comparison and are incommensurable.  some of the data are known tobe inconsistent with respect to rules for counting lines of code, functionality, effort, and defects. otherdata are accumulated with no knowledge of their degree of consistency. the data are incomplete. most of the data collected address quantities such as size, level of effort, andnumber of defects, but do not take into account the environmental variables (e.g., cost drivers) associatedwith the quantities measured. also, it is unclear to what extent the data collected are fully representativeof project experience (e.g., perhaps only the good projects collect or report data). data are collected but are not systematically organized. many dod organizations collect software datafor project monitoring and control, as well as environmental data such as those indicating processmaturity. but the data are not organized and stored in a repository that could facilitate analysis to supportdod software engineering processand productimprovement efforts and policy analyses.most of the available data generally support the conclusion that ada is preferable for dod warfightingapplications, and the committee did not find any data to refute that conclusion. but for future policy analyses andinitiatives to improve dod software engineering practices, a stronger base of dod software metrics data thatdescribes project outcomes would more than repay the investment necessary to develop it. without more reliabledata, decision making will have only a weak foundation.on an individual project level, dod has endorsed the concept of using metrics data to improve softwareprocess management through its endorsement of the software engineering institute's capability maturity model,which includes quantitative process management as a key process. within dod, several local efforts to collect andanalyze data for evaluating software add considerable value. some good examples are the air force cost analysisagency, the army software test and evaluation program, the navy undersea warfare center, and the defenselogistics agency's columbus, ohio, facility. however, dod is not applying this practice at a more strategic levelto improve its overall software costeffectiveness and is missing a major opportunity to improve its software costeffectiveness. dod should establish a sustained commitment to collect and analyze consistent software experiencedata.foundations for such a program already exist. the joint logistics commanders "practical softwaremeasurement" guidebook (dod, 1996a) provides good case studies and guidelines for tailoring and focusingmeasurement of software capabilities on activities that add value. the software engineering institute's softwarecore metrics reports (carleton et al., 1992) provide a foundation for collecting consistent data across projects andorganizations. nasa's software engineering laboratory (mcgarry et al., 1994) provides a good model. also, agood start toward a dod software metrics initiative is represented by its national software data and informationrepository; this effort needs some improvement and has languished due to lack of a sustained commitment.as dod's chief information officer, the assistant secretary of defense (c3i) is the logical focal point forestablishing and sustaining a dodwide software metrics initiative. the initiative would need a precise scope,strong staffing, and focused management, but the examples above provide evidence that such investments cangenerate significant positive results.notes1. barry m. horowitz, president of mitre corporation, has noted the following with respect to requirements and architecture: "bothgovernment and industry typically put almost all of their efforts into the initial performance and functionality of a program in spite of thefact that these will change substantially over the life of the system. at the same time, there is a neartotal lack of attention to anarchitectural baseline that would form a stable foundation for incorporating the system's changing requirements" (horowitz, 1991, p. 10).notes32ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.2. no technical standard exists for software architecture; however, the ieee software engineering standards committee has created aplanning group to investigate the issue. see "standards annual report1996," located at http://www.computer.org/standard/anreport/toc.htm.3. horowitz (1991) emphasizes the importance of architecture; more recently, a defense science board task force emphasized theimportance of software architecture, and estimated that "a wellformulated architecture might reduce costs of changes/upgrades by3050%" (dod, 1994a).4. see the contents of the lifecycle architecture milestone and associated rationale in boehm (1996).5. while personnel capability and understanding of requirements are also important cost factors, these topics are excluded from thediscussion below because they are mostly languageindependent variables.6. this trend is driven by the dual use initiative within dod (dod, 1995b) and by legislative changes, namely the federal acquisitionreform act of 1996.7. one source (jones, 1995) found that the mean value of source code statements per function point is 71 for ada 83 and 49 for ada 95,for a 30 percent reduction. the amount of empirical evidence is small, however.8. other sets of criteria would apply for other classes of applications.9. no independent evaluations of language features were located by the committee, prompting the analysis presented above in the sectiontitled "technical evaluation of ada 95 and other thirdgeneration programming languages" and in appendix b of this report. mostevaluations have been carried out by government agencies or at their direction.10. some of the differences in efficiency and risk ratings may be due to increased ada maturity, but the decline in availability/reliability ismore likely due to differences in interpretation of the evaluation criteria.11. both of these authors are software consultants; capers jones is president of software productivity research inc., and donald reifer,formerly director of dod's ada joint program office, is with reifer consultants inc.12. see frazier and bailey (1996) for a recent discussion of stars demonstration project outcomes.notes33ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.3dod software policy: analysis and recommendationsthe kinds of software programs that dod needs for weapons systems and those that commercial industrycreates for popular use often do not share the same basic requirements. dod's requirements for highassurancewhich include reliability, availability, survivability, safety, and security are considerably more stringent, given thenational security stakes involved. dod's requirements for performancecritical realtime embedded operationcontinually stress the capabilities of available hardware and software technology. its requirements for complexintegrated systems mean that weapon systems software must perform at a level higher than typical commercialprograms found at the same stage of development, and all of these requirements must be satisfied simultaneously.in this regard, dod (and its primary contractors) continues to be at the leading edge of the development of largescale software engineering technology. it is likely to remain in this position for many years to come, although anincreasing number of commercial software systems are comparable to those of dod in size and requiredrobustness.this chapter establishes a set of objectives and criteria for evaluating the costeffectiveness of alternativeprogramming languages for support of dod missions. it then presents a businesscase analysis to evaluate adaagainst other programming languages (generally focusing on c and c++) with respect to these criteria. drawing onthe technical and empirical evaluations reviewed in chapter 2, this analysis is performed for (1) dod warfightingsoftware with no direct commercial counterparts, and (2) commercially dominated applications that are commonlyused in all organizations. the analysis concludes that ada can provide dod with a considerable advantage indoddominated warfighting applications, but not in commercially dominated applications. it also concludes thatensuring the ada advantage for warfighting applications will require dod investment to sustain a robust adainfrastructure, but that the benefits justify the investment.the final sections of this chapter summarize the policy changes recommended by the committee on the basisof this analysis, evaluate this policy with respect to possible alternative dod policies on ada, and present aneconomic evaluation of the recommended investment strategy.dod software policy: analysis and recommendations34ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.policy objectives and criteria relevant to meeting themrelating criteria to objectivesdod increasingly is emphasizing the concept of "information dominance" as a key to military superiority(powell, 1992; dod, 1996d). secretary of defense william perry has stated that "–our warfighting strategysustains and builds ... on the application of information technology to gain great military leverage to continue togive us [an] unfair competitive advantage" (perry, 1996a).1 since software development is a fundamental aspect ofinformation technology, an appropriate objective for dod software policy is to ensure that dod software enablessystems that are superior to any that an adversary might develop, thus affording dod a competitive advantage.achieving superiority in software and information technology for military purposes requires attention tosituationdependent mixes of functionality and other attributes. in an electronic warfare countermeasure/countercountermeasure competition, rapid and reliable modification of software is a critical capability. to thwartinformation system penetration, subversion, and threatened denial of service, computer security is paramount.performance is critical for processing of wideband sensor data. safety is critical to controlling the course ofweapons. interoperability is critical for joint operations. and for all dod systems, dod's budget limitations makecost critical.it would be convenient if these criteria could be combined into a single "dod return on investment" index.alternative policies could then be evaluated definitively with respect to this composite criterion. however,decades of policy analysis have led to the conclusion that such combined analyses are feasible only in the contextof particular military scenarios (quade, 1964; quade and boucher, 1968). this creates two equally difficultproblemsaggregating the results from multiple scenarios, and evaluating the relevance of the scenarios in a rapidlychanging world.given this situation, a useful approach is to identify the critical criteria most relevant to dod's achievinginformation dominance, to evaluate ada and alternative programming languages with respect to these criteria, andto base conclusions and recommendations on a judgmentbased weighting of the criteria. given the objective ofhaving superior software, such evaluation must consider the effect of dod programming language choices both ondod itself and on its adversaries.critical criteria in dod's selection of a programming languageas pointed out in "economics of software engineering" in chapter 2, software costmodeling has shown thatthe criteria of software functionality, cost, and speed of development can be related to other criteria that are moreclosely coupled to choice of programming language. these determinants are software size, process, developmentenvironment, and personnel. additional criteria for assessing software quality that are crucial in supporting dod'scritical missions and ability to respond rapidly to changes include highassurance and realtime performance, aset that covers reliability, security, safety, survivability, and realtime performance; and ease of change, acapability that enables rapidresponse to changes in threats, technology, or mission requirements.besides the individual production factors involving software tools, technology, and personnel, an evenstronger determinant of international competitive advantage in information dominance is the existence of a sociotechnical infrastructure, which couples the production factors with knowledge resources, marketing channels,strategic partnerships, user groups, closely linked customersupplier chains, and trends in domestic demand, thusstimulating innovation and enabling rapid development of new software products. porter's (1990) analysis of thesignificance of a strong national sociotechnical infrastructure in determining the competitive standing of anindustry or a service sector supports consideration of the sociotechnical infrastructure's role in the warfightingsector also.dod software policy: analysis and recommendations35ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.these seven criteriasoftware size, process, environment, personnel, highassurance and realtimeperformance, ease of change, and sociotechnical infrastructure are used in the businesscase analysis that follows.warfighting and commercially dominated applicationsthe current sociotechnical infrastructure is probably the main factor considered by many commercial firmsin choosing c or c++ as their primary programming language, even when they may have performed a technicalevaluation that indicated ada was superior.2 for example, the fact that much of the financial community's softwareexpertise, tooling, components, and middleware is oriented to c and c++ would generally be enough to lead somefirms to choose c or c++.3 conversely, this argument can be turned in favor of dod's maintaining an adabasedcompetitive advantage in software for warfighting, a domain in which dod of course plays the dominant role.the term "warfighting" is used in the businesscase analysis that follows to determine whether the use of adawould provide a clear advantage for dod, when compared to the alternative of using (typically nonada)commercial software solutions. this determination should be made at the subsystem level, in the context ofdecisions to build or buy software for the system. for example, an integrated combat system such as aegis canhave "warfighting" weapon control subsystems for which a custom ada solution is superior, and "nonwarfighting" data management and graphical user interface subsystems for which nonada commercial solutionsare superior.warfighting applicationsthere are two primary criteria for determining whether a subsystem belongs in the "warfighting" category:1. relatively little commercial software and expertise is available for implementing the desiredfunctions. for example, even though intelligence analysis is involved in warfighting, many of itsfunctions (database update, query and visualization, report generation) can be readily satisfied vianonwarfighting commercial software.2. the application requires software quality attribute levels higher than those supportable by commercialsoftware. for many warfighting functions, these involve realtime performance, reliability, andsurvivability, particularly in highstress, crisismode situations in which dod information processingfunctions may be under attack.the application domains for warfighting software include, but are not necessarily limited to, the followingareas. also mentioned are related support services and capabilities that are nevertheless outside the veryspecialized domain of warfighting. weapon control includes weapon sensor processing; guidance, navigation, and control; and combatoriented weapon delivery platform control. included also are special weapon delivery platform operatordevices such as headsup displays. weapon control does not include administrative functions and "hotelservices" for large weapon delivery platforms such as aircraft carriers, or support subsystems performingmainstream data management, networking, and graphical user interface functions.dod software policy: analysis and recommendations36ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved. electronic warfare depends on software involved in rapidresponse electronic detection, identification,discrimination, tracking, platformbased communication, and associated countermeasure and countercountermeasure applications. it does not include software for support subsystems performing mainstreamdata management, networking, and graphical user interface functions. wideband realtime surveillance includes processing of hard or soft realtime images and data frominfrared, radar, or other sensors. it does not include offline query and analysis of surveillance archives,or support subsystems performing mainstream data management, networking, and graphical user interfacefunctions. battle management and battlefield communication includes hard or soft realtime weapons allocation,targeting, control, coordination, damage assessment, and associated battlefield communications requiringsuch special capabilities as spread spectrum, antijamming, and frequency hopping. it does not includeoffline monitoring, update, query, and analysis of battle asset status, or offbattlefield communications.thus, the range of "warfighting command, control, and communications (c3i) applications" is narrowerthan previous categorizations such as "c3i" or "missioncritical."in addition to the nonwarfighting, more generic applications mentioned above, warfighting also does notinclude testing, simulation, training, offline analysis, maintenance, and diagnostics. software for suchapplications might well be implemented in ada, but other languages may be better choices in some situations.commercially dominated applicationscommercially dominated applications include office and management support, routine operations support,asset status monitoring, logistics, medicine, and nonbattlefield communications processing.ada businesscase analysistable 3.1 summarizes the results of the committee's businesscase analysis for dod use of ada versus otherthirdgeneration programming languages (3gls) for both warfighting and commercially dominated applications.evaluation of ada with respect to software size, process, development environment, personnel, highassurance andrealtime performance, ease of change, and sociotechnical infrastructure is presented below.criteria for evaluation of adasoftware sizethe critical portions of warfighting applications are largely custom software, or components reused fromprevious defense applications. reducing the size of these applications involves capitalizing on the existingapplications software base. the largest fraction of this software base (approximately onethird) is in ada, giving anappreciable (but not overwhelming) advantage to ada. furthermore, dropping ada would leave dod with a largebody (approximately 50 million source lines) of ada code to reengineer.dod software policy: analysis and recommendations37ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.table 3.1 ada businesscase analysis summarycriterionwarfighting applicationscommercially dominated applicationssize critical portions largely custom, ordodmanaged reuse some ada advantage due to existingdod ada investments dropping ada would leave largeexisting dod ada software baseunsupported predominantly commercial offtheshelf(cots)based solutions; much lessprogramming than with custom solutions cots largely nonada, with manyvolatile interfaces; a considerabledisadvantage for adaprocess some ada advantage: earlyverification of architecture interfaceobviates need for rework ada advantage for custom software isless applicable for cots; some adadisadvantage in cotsbased rapiddevelopment processesenvironment dod investment required for adaparity in general tools dod investment creates some adaadvantage in highassurance, realtimetools nonada tools and techniques muchstronger than ada counterpartspersonnel dod has dominant position in ada/applications skill base, which requiressome investment to sustain expensive for adversaries to createcomparable ada/applications skill base nonada/applications skill baseachievable, but with initial cost, lowercompetitive advantage nonada/applications skill base muchstronger than ada counterparthigh assurance and realtimeperformance ada superior; attributes are successcritical ada superiority diluted by cots;attributes are less successcriticalease of change ada somewhat superior, more so forhighassurance changes ada somewhat superior for customsoftware but at a disadvantage forcotsbased applications (see "size"above)sociotechnical infrastructure existing dod adabasedinfrastructure stronger thanalternatives; requires some investmentto sustain expensive for adversaries to match andsustain comparable infrastructure existing c/c++ based infrastructuremuch stronger than adabasedinfrastructurein commercially dominated applications, software size can be significantly reduced by the use of commercialofftheshelf (cots) software and fourthgeneration programming languages (4gls). given that most of theseapplications are developed in c and c++, and given current and likely future cots volatility, it will generally beharder for dod to use ada, as compared to c and c++, to develop and sustain noncots portions of thesoftware.dod software policy: analysis and recommendations38ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.processas discussed in "influence of software environments, tools, and languages on the software engineeringprocess" in chapter 2, ada enables the definition and verification of architectural interfaces early in thedevelopment process. this capability reduces a major source of rework, giving ada another appreciable, but notoverwhelming, advantage in the largely custom warfighting sector.the more cotsintensive, commercially dominated applications would not benefit much from adabasedearly interface checking (absent a significant investment in sustaining ada interface specifications for eachevolving cots product). further, cotsbased rapid development processes based on early availability of c andc++ interfaces would leave ada at some disadvantage.environmentin warfighting applications, investment in very highassurance, realtime ada software tools has beenbeneficial to dod. without continued investment, however, ada tools will not be robust in either warfighting orcommercial applications. the predominance of c and c++ tools in such areas as mainstream databases andgraphical user interfaces places ada at a significant disadvantage.for all applications, the large commercial marketplace will continue to stimulate development of a largeselection of general software tools (e.g., smart editors, "debuggers," static and dynamic analyzers, and tools forconfiguration management, quality assurance, and testing), more frequently supporting c and c++ than ada. adaparity for general tools would require additional dod investment.personnelfor development of software for warfighting, dod has in place an established group of experts whounderstand the existing base of ada warfighting software and can expeditiously extend it. some dod investmentin adabased education and training is necessary to sustain the current skill base and to add new personnel, butthis investment is minor compared to the investment an adversary would need to make to compete across the boardwith dod in warfighting software (either by building an ada skill base or developing a comparable warfightingapplications software base in another language). competing in warfighting niches (e.g., information warfare andsecurity) would still be feasible for adversaries, independent of the choice of programming language. althoughdod could retrain its warfighting software programmers to use c and c++, thus avoiding the need for educationin more specialized programming languages, such an approach would require a considerable time delay as well asinvestment for retraining the existing ada applications skill base, and it would eliminate the competitive advantagecurrently enabled by the ada applications skill base.because commercially dominated applications software is written mostly in c, c++, and other nonadalanguages such as cobol, java, and 4gls, dod use of ada in this sector would forego the advantages of relyingon the base of commercial skills.high assurance and realtime performanceas described in appendix b and summarized in the chapter 2 section titled "technical evaluation of ada 95and other thirdgeneration programming languages," ada provides a significant technical advantage forachieving highassurance and realtime performance, two attributes that are critical to dod's competitiveadvantage for many warfighting applications.in commercially dominated applications, levels of assurance that can be provided by cots represent thestandard. complementing cotsbased capabilities with those provided by ada would notdod software policy: analysis and recommendations39ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.improve much on cots levels of assurance and realtime performance, which in general are sufficient for all but asmall fraction of commercially dominated applications.ease of changeas described in appendix b and summarized in the chapter 2 section "technical evaluation of ada 95 andother thirdgeneration programming languages," ada's encapsulation, type checking, "generics," and othercapabilities facilitate changes in software and lead to lower maintenance costs for custom software. with ada,high levels of assurance can be sustained for modified software, a distinct advantage for warfighting applications.as discussed for the criterion of software size, requiring the use of ada for cotsdominated commercialapplications would be a disadvantage because of the need to adapt to frequent cots changes.sociotechnical infrastructuredod has developed a strong base of aerospace contractors and subcontractors who have in common afamiliarity with both ada and warfighting applications, enabling them to quickly combine in various ways toaddress new needs for and opportunities in warfighting software. no dod adversary has a comparable range ofcapabilities or is likely to make the major investment required to generate and sustain such capabilities. thus,although a moderate dod investment is required to sustain adabased warfighting software, the competitiveadvantage gained in warfighting applications makes it more than worthwhile.on the other hand, for commercially dominated applications, the pervasiveness of c and c++ in the sociotechnical infrastructure places ada at a major disadvantage.conclusionsin weighing the factors discussed above and listed in table 3.1, the most compelling points for ada's use forwarfighting applications are the strong competitive advantages accruing to dod in the areas of personnel, highassurance and realtime performance, and sociotechnical infrastructure. evaluation of ada with respect tosoftware size, process, development environment, and ease of change does not produce a sufficient rationale forrequiring ada's use. with respect to these criteria, ada offers some moderate advantages, but, in some cases (e.g.,for general software tools), dod investment is required just to achieve parity between ada and other availableprogramming languages.based on the points above, there is sufficient justification to continue the requirement to use ada inwarfighting applications if dod also commits to the associated necessary investment in sustaining theinfrastructure for ada. the committee believes that an appropriate level of investment is roughly $15 million peryear (detailed in chapter 5); the economic analysis presented at the end of this chapter indicates that this level ofinvestment is justified.considering that programming languages are the materials out of which software is built, this investmentstrategy is a familiar one for dod. it is analogous to investing in and encouraging the use of highperformancephysical materials that provide dod with competitive advantages for its weapon systems (see box 3.1). however,this observation is not meant to imply that ada technology should be put on the militarily critical technologieslist and be subject to embargo; rather, dod can gain an advantage by sustaining its ada capability for warfightingsystems.consideration of the factors listed in table 3.1 for commercially dominated applications leads to theconclusion that a dod requirement for adabased software in commercially dominated applicationsdod software policy: analysis and recommendations40ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.box 3.1 ada 95 as a dod materials investmentsuppose that dod has been developing a new generation of materials for highperformance weaponsystems. these materials have four main characteristics:1. they are based on proven costeffective development and performance with a previous generation ofmaterials.2. their use requires special manufacturing and maintenance expertise. dod and its supplier communityhave the largest source of such expertise, including tooling and components.3. they provide the potential for dod to create and maintain systems that will significantly outperformadersaries' weapon systems.4. they require a continuing investment in materials research and development and in manufacturingtechnology of less than 0.1 percent of the cost of the weapon systems in which they will be deployed.when such materials are physical materials that contribute to lowobservable, highstrength, or hightemperature performance, dod routinely makes such investments. the same rationale can be applied toinvestment in weapon systems software, in which programming languages operate as the counterpart ofphysical materials. each programming language contributes to varying extents to a warfighting application'smalleability, ability to withstand stress, and suitability for various operational environments.for embedded weapon systems, the rationale for investment outlined above applies well to ada 95,which has characteristics analogous to those described for new materials above.1. several studies (see chapter 2) have indicated that ada 83 (the previous programming "material") hasenabled more costeffective development and maintenance of embedded weapon systems softwarethan have other languages.2. the dod software community has by far the largest source of people capable of programming in ada83, particularly for embedded weapon systems, and dod's strongest embedded weapon systemssoftware tools and components are based on ada 83.3. ada 95 incorporates a decade of experience in ways that improve on ada 83's capability to addressrealtime, distributed, and objectoriented systems.4. ada 83's capabilities and ada 95's potential are products of a continuing dod investment of morethan $10 million annually for the past decade. a comparable investment is necessary to provide dodwith the continuing improvements in ada 95 tools, components, infrastructure, and education requiredto keep dod well ahead of any other nation's ability to produce or modify embedded weapon systemssoftware.if dod chooses to implement its future embedded weapon systems software in other programminglanguages such as c or c++, it can still produce good systems. however, such systems would providelowerlevels of assurance than those produced with ada 95. also, choosing another programming languagewould require a large dod investment in moving its weapon system software components, manufacturingexpertise, and maintenance expertise from ada to c or c++. a further result of such a transition would be tomake dod's weapon system software components and expertise easier for adversaries to assimilate.dod software policy: analysis and recommendations41ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.if any adversary chose to build its embedded weapon systems software using c or c++ and commercialofftheshelf (cots) components, it would have some advantages in tooling and a large labor pool to drawfrom. however, it would have several formidable problems in competing with dod's weapon systemssoftware. chief among these problems are the amount of new c and c++ software (a large fraction of 50million lines) that would need to be developed to replace the current inventory of ada code; the need toretrain the labor force in weapon systems applications; the mismatch between cots software (e.g.,"windows") and realtime, highassurance requirements; and the need to match dod's expertise in suchareas as reuse (via ada's package specifications and generics), sensorbased control algorithms and datastructures in ada, and ada's realtime scheduling capability.is not justified. for custom 3gl software in this sector, ada is a strong candidate and should be considered inprogramming language decisions. however, it should not be necessary to provide extra justification for the use oflanguages other than ada.findings and recommendationsbased on its assessment of today's environment for software development and its evaluation of dod'scurrent programming language policy (chapter 1), its examination of trends in software engineering andcomparison of various programming languages (chapter 2), and the results of its businesscase analysis to evaluateada in two software application domains (the first two sections of this chapter), the committee developed thefollowing set of findings and recommendations for dod. the recommendations address the use of ada inwarfighting software, the application in which the committee finds ada to have demonstrated benefit; the properscope and implementation of dod software policy; investment in ada; and collection of data as a basis forassessing the effectiveness of software and software policy.ada competitive advantagefinding. ada gives dod a competitive advantage in warfighting software applications, including weaponcontrol, electronic warfare, performancecritical surveillance, and battle management.recommendation. continue vigorous promotion of ada in warfighting application areas.rationale. available project data and analyses of programming language features indicate that, comparedwith other programming languages, ada provides dod with higherquality warfighting software at a lower lifecycle cost. dod can increase its advantage by strengthening its adabased production factors (involving softwaretools, technology, and personnel) for warfighting software (see chapters 2 and 3).applicability of policy to dod domainsfinding. dod's current requirement for use of ada is overly broad in its application to all dodmaintainedsoftware.dod software policy: analysis and recommendations42ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.recommendation. focus the ada requirement on warfighting applications, particularly in critical, realtimeapplications, in which ada has demonstrated success. for commercially dominated applications, such as office andmanagement support, routine operations support, asset monitoring, logistics, and medicine, the option of usingada should be analyzed but should not be assumed to be preferable.rationale. for warfighting software, supporting adabased production factors (involving software tools,technology, and personnel) gives dod a competitive advantage. in this domain, eliminating the use of ada wouldboth compromise this advantage and diminish the capabilities for maintaining dod's existing 50 million lines ofada. in commercially dominated areas, pushing applications toward ada would create a disadvantage for dod(see chapters 2 and 3).scope of policyfinding. dod's current requirement for use of ada overemphasizes programming language considerations.recommendation. broaden the current policy to integrate the choice of programming language with otherkey software engineering concerns, such as software requirements, architecture, process, and quality factors.rationale. the current policy isolates the ada requirement and the waiver process from other softwareengineering decisions, causing programs to make premature or nonoptimal decisions (see chapter 1). dod hasalready taken steps to broaden the policy focus in its draft revision of its programming language policy, doddirective 3405.1; this report recommends modifications to that draft policy (appendix a).policy implementationfinding. dod's current ada requirement and the related waiver process have been weakly implemented.many programs have simply ignored the waiver process. other programs make programming language decisionsat the system level, but often a mix of ada and nonada subsystems is more appropriate (see chapter 1).recommendation. integrate the ada decision process with an overall software engineering plan review(sepr) process. passing such a review should be a requirement for entering the system acquisition milestone i andii reviews covered by dod instruction 5000.2. it should also be required for systems not covered in 5000.2, andrecommended for doddirected software development and maintenance of all kinds.rationale. the sepr concept is based on the highly successful commercial architecture review boardpractice. the sepr process involves peer reviewing not only the software and system development plans, but alsothe software and system architecture (building plan) and its ability to satisfy mission requirements, operationalconcepts, conformance with architectural frameworks, and budget and schedule constraints; the process alsoinvolves reviewing other key decisions such as choice of programming language (see chapter 4).investment in adafinding. for ada to remain the strongest programming language for warfighting software, dod mustprovide technology and infrastructure support.dod software policy: analysis and recommendations43ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.recommendation. invest in a significant level of support for ada, or drop the ada requirement. the strategydeveloped by the committee recommends an investment level of approximately $15 million per year.rationale. with investment, dod can create a significant adabased complex of production factors(involving software tools, technology, and personnel) for warfighting application domains. without such support,ada will become a secondtier, niche language such as jovial or cms2 (see chapter 5).software metrics datafinding. dod's incomplete and incommensurable base of software metrics data weakens its ability to makeeffective software policy, management, and technical decisions.recommendation. establish a sustained commitment to collect and analyze consistent software metrics data.rationale. the five sets of findings and recommendations above are based on a mix of incomplete andincommensurable data, anecdotal evidence, and expert judgment. for this study, the patterns of consistency inthese sources of evidence provide reasonable support for the results but not as much as could be provided byquantitative analysis based on solid data. a few organizations within dod have benefited significantly fromefforts to provide a sound basis for software metrics; a dodwide data collection effort would magnify the netbenefits (see chapter 2).assessment of policy alternativestable 3.2 summarizes current dod policy, the committee's recommended alternatives to the policy currentlyin force, and other programming language policy alternatives suggested to or considered by the committee. thesubsections that follow in the text summarize the committee's rationale for preferring these recommended actionsover the alternatives.conditions for requiring adathere are five conditions to be examined in determining whether a software development is subject to theada requirement. the following subsections describe the approach to defining these conditions. the committeerecommends that all of these conditions be met in order for ada to be required.dod software policy: analysis and recommendations44ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.table 3.2 policy alternatives recommended by the committee and alternatives consideredcommitteepolicy itemcurrent policyrecommendationalternatives consideredconditions for requiring adaapplication domainall dod softwaresystems; all sectorsapplication subsystem is in thewarfighting sectornoneother subsetsmaintenancedoddirectedmaintenancesame as current policyall dod softwareonly dodperformedmaintenancelevel of applicabilityentire systemsubsystem is critical or is largerthan 10 klocother size, criticalitycriteriaexisting solutionsconsider cots, ndis4glsno better cots, ndi, or 4glsolution existsrequire cots, ndis,4glsother languagesno lifecycle cost effectiveness justificationfor use of another languagesame as current policyrequire another language(c, c++, java)require objectorientedsolutionsada requirementsystem coverageentire system; 100% adacode95% or more of subsystem inadaother percentageslanguage choice processexceptionswaiverbased;independent of othersoftware engineeringreviewspart of software engineeringplan review processtied to different softwareengineering reviewsapprovalsaes or asd (c3i)approval delegated throughsaes to appropriate level;periodically reviewed by asd(c3i)asd (c3i) onlydelegated to projectmanager's superior;periodically reviewed bysaes, asd (c3i)investment in ada infrastructurelevel$10 m in fy94; $0 m infy98$15 m/year$2 m/year (barelysustaining)$30 m/year (majorinitiative)note: asd (c3i), assistant secretary of defense (command, control, communications, and intelligence); cots, commercial offtheshelf; 4gl, fourthgeneration programming language; kloc, 1,000 lines of code; ndis, nondevelopmental items; sae, serviceacquisition executive.dod software policy: analysis and recommendations45ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.application subsystem is in the warfighting sectorcurrent dod policy requires that ada be used for all applications (subject to a waiver process and the criteriain table 3.2). the committee recommends requiring ada only for subsystems in doddominated warfightingapplications, as defined above in this chapter. for other dod applications, ada should be considered as acandidate but should not be required. the focus on subsystems makes it possible to separate the weapon controlaspects of a system, which should be written in ada, from other aspects of the system, which may be written inada, but need not be. an aircraft carrier is a good example of such a system.as discussed above, in nonwarfighting applications, the rapid pace of nonada commercial softwaresolutions shifts the businesscase away from ada. for warfighting applications, a focused ada strategy cangenerate a differential that enables dod to develop and adapt software more readily than its adversaries.the primary alternative to be considered is to not impose any requirement. advocates of this approach (aia,1996) argue that developers of warfighting software can choose a programming language by analyzing tradeoffs,in the same way that they make decisions about other nondevelopmental items (ndis), such as commercialhardware and cots software. the committee recognizes that many dod and contractor organizations can makegood technical choices when given the freedom to do so. however, the uneven distribution of software expertiseacross the dod acquisition system could lead to some poor results, therefore leaving dod worse off under anopen policy than it would be under a requirement to use ada in specific critical applications.the primary problem with leaving programming language selection to developers is that dod acquisitionsstill are done largely one system at a time, rather than according to a productline approach. currently the focus insource selection is the cost of developing individual systems, and less attention is paid to important factors, suchas assurance and adaptability, that are difficult to quantify. such an approach can frequently lead to situations inwhich bidders can propose cheap but fragile solutions (e.g., using immature commercialgrade nonada processcontrol software). dod's program management staff often does not have sufficient software expertise (seechapter 1) to be able to disqualify such inadequate solutions. the net result for dod warfighting software thenbecomes a mix of strong and weak ada and nonada solutions, and a sociotechnical infrastructure characterizedby increasing problems with proliferation of programming languages. requiring ada in warfighting applications isnot a panacea, but it should lead to betterperforming systems for dod.other possible policy alternatives could require that ada be used for other subsets of dod software, such asall software maintained by dod personnel. in this particular case, ada's use would be required for a great deal offinancial and other commercially dominated software, which the committee's businesscase analysis indicateswould not be a costeffective approach for dod. the committee was unable to identify other subsets in whichmandating use of ada would match the costeffectiveness of requiring its use in warfighting applications.4maintenance is directed by doddod's current requirement for use of ada excludes software that is embedded in a warfighting systemcomponent (e.g., an altimeter) purchased as a suppliermaintained commercial item. in such cases, dod canfrequently capitalize on dualuse (commercial and military) products as it does on cots software. the committeerecommends maintaining this aspect of the policy. the alternative of requiring ada for all software in dodwarfighting systems is less costeffective because it cuts off the opportunity to use many of these dualusecomponents. another alternative, requiring use of ada only for dodperformed rather than doddirectedmaintenance (i.e., maintenance performed by dod as well as by its contractors) would invite proliferation ofprogramming languages in dod's contractormaintaineddod software policy: analysis and recommendations46ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.warfighting software inventory, with the same consequent relative weakening of dod's position discussed in theprevious subsection.subsystem is critical or larger than 10, 000 lines of codethe committee concluded that dod's current policy of requiring waivers for use of nonada software forsmall, noncritical subsystems can cause bureaucratic delays that add little value. dod should consider alternativesize and criticality criteria. in suggesting alternatives, the committee focused on the objective of keeping the policysimple. the metric of 10,000 lines of code is based solely on engineering judgment: the committee's consensuswas that 3,000 lines was too low and 30,000 lines was too high. "critical" should be interpreted as key to missionsuccess.no better cots, ndi, or 4gl solution existsas discussed in chapter 1, the current dod policy establishing ada's precedence over cots, ndi, and 4glsolutions has led to a number of bureaucratic delays or incorrect choices of an ada solution over a more costeffective cots solution.in addition to its recommended alternative, another alternative considered by the committee was to requirethe use of cots, ndi, and 4gl solutions. as discussed in chapter 2, these solutions can have many drawbacksfor dod and other systems, and requiring their use would push many dod systems into adopting less costeffective solutions.no lifecycle costeffectiveness consideration justifies use of another languagethis criterion for required use of ada is identical to dod's current policy. as recommended below,embedding of the ada waiver process within the sepr process (chapter 4) should make justifications for use ofnonada software both sounder and less onerous.alternatives suggested to the committee were to require the use of other programming languages (e.g., c, c++, or java) or to require the use of objectoriented approaches. the comparisons of language features in chapter 2and the businesscase analysis presented above in this chapter do not support a recommendation for requiringother languages. with respect to objectoriented techniques, the committee's assessment was that these are notwell enough defined or sufficiently mature to support a requirement for use.ada requirementif all of the above criteria hold for a given software development, the committee's recommendation is that therequirement to use ada should hold. the following subsection analyzes the appropriate coverage of therequirement.95 percent or more of the subsystem 's warfighting software is to be written in adathe current dod policy calls for the entire system to be developed in ada. the committee recommends onlythat at least 95 percent of the applicable subsystem use ada. again, the intent of this recommendation is to avoidbureaucratic delays in cases involving small amounts of nonada "glue code" or performance enhancements, and95 percent is again based on engineering judgment. the committee believes that 90 percent is too low and 98percent too high. as with the criterion for subsystem size above, the scope of this requirement could be subject tosome manipulation by programdod software policy: analysis and recommendations47ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.desire to evade the requirements. however, the committee concluded that coupling the ada waiver process withthe sepr process detailed in chapter 4 would eliminate most of the gamesmanship in a costeffective manner.language choice processthe following subsections recommend alternative approaches to implementation and approval of thelanguage choice process.replace the waiver approval process with other dod software reviewsthe current dod ada waiver approval process is disconnected from other reviews of a project, causing extrawork and outofcontext decisions (see chapter 1). as discussed in chapter 4, embedding the waiver processwithin the sepr process should make it sounder and less onerous.requests for waivers could also be considered at other review and approval milestones. the committee'srecommendation associates the sepr reviews with the major automated information systems review council(maisrc) reviews at milestones i and ii, but recommends that the sepr reviews for major weapon systems becompleted as prerequisites to the counterpart defense acquisition board (dab) milestone i and ii reviews (seefigure 3.1). the sepr reviews could be embedded within the dab reviews, but experience to date indicates thatsoftware issues have had little visibility in many previous dab reviews. the sepr reviews and programminglanguage decisions could also be handled in conjunction with source selection, but source selection may occureither too early or too late to allow effective consideration of waiver requests, depending on the relative timing ofsource selection and dab/maisrc milestone reviews. basing a sepr review on a 60day proposal effort couldalso make it too superficial and vulnerable to manipulation. on the other hand, requiring an sepr review forsource selection would likely stimulate better proposals.reconsider the level at which waivers can be approvedthe current dod waiver policy requires service acquisition executive (sae) approval for service levelwaivers and assistant secretary of defense (c3i) approval for waivers in joint programs. as discussed in chapter 1,this requirement for approval at extremely high levels has induced considerable avoidance of the waiver process(sometimes leading to inappropriate use of ada, sometimes simply to disregarding of the requirement). thecommittee recommends that saelevel approval via the sepr process be required only for major systemacquisition, and that authority for granting waivers be delegated, as part of the sepr process, to the equivalent of aproductline manager (a program executive officer for families of warfighting systems; a base commander forbasespecific systems). this approach would make the reviews and waiver process more missionrelevant.periodic reviews by saes and the assistant secretary of defense (c3i) to assess the effectiveness of the sepr andada waiver process would ensure their longrange effectiveness without involving top executives regularly inlowlevel system decisions.waiver approval at levels even higher than the current level (e.g., that of the assistant secretary of defense(c3i) for every project) could also be considered but would exacerbate the current problems of criticalpath delaysand avoidance of the waiver process. delegation of authority for approval to even lowerlevels (e.g., the projectmanager's direct superior) could also be considered, but in many cases managers at such levels do not havesufficient visibility or responsibility across productline objectives to make appropriate decisions affecting longrange productline effectiveness.dod software policy: analysis and recommendations48ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.figure 3.1 integration software plan review (sepr) process with defense acquisition board (dab) and majorautomated information systems review council (maisrc) milestones for weapon and information systems.investment in ada infrastructurethe current dod strategy is to reduce investment in ada from a $10 million annual budget in fiscal year1994 to essentially zero in fiscal year 1998. other programming languages that dod uses but provides little or nosupport for include jovial and cms2; at this level of investment, bindings, runtime systems, language features,and tools are kept current only by projects using the language. this level is inadequate to keep a programminglanguage up to date and serves as a major disincentive for projects to continue to use the language. thus, dod'splanned zeroing out of investment in ada is incompatible with any dod requirement to use ada.chapter 5 identifies a set of investments that are necessary to provide dod with a competitive advantage inwarfighting software, and indicates that its magnitude is roughly $15 million per year. the economic analysis inthe following section indicates that the resulting cost savings justify this level of investment.an alternative policy would be to attempt to sustain ada at a considerably lowerlevel, on the order of $2million annually. this level would be enough to enable dod to keep its current 50 million lines of ada frombecoming hopelessly obsolete, but not enough to keep new programs from deciding that ada would require toomuch extra investment to justify its use. another alternative would be a major initiative level of investment, atroughly $30 million per year. this was the level recommended by the 1991 dod software technology strategy for a3year period (dod, 1991). it included such additions as a demonstration/validation phase for ada 95, a majorsuite of tools for reengineering legacy software into ada, and investment in beyondada 95 programminglanguage research. since 1991, the primary window of opportunity for an ada 95 demonstration/validation phasehas passed; programming language research is now being pursued in general by the national science foundationand in particular by the defense advanced research projects agency's dynamic objectoriented languageinitiative. given this situation, a strategy of investment at the margin in such areas as reengineering tools andrealtime,dod software policy: analysis and recommendations49ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.highassurance tools at the $15 million annual level appears more costeffective than a major initiative, and can bejustified given the large installed base of ada warfighting software.economic analysis of investment in ada infrastructuregiven the fragility of the underlying data, a complex economic analysis attempting to establish the optimalinvestment in ada infrastructure is not justified. instead, a simple analysis is presented to estimate how therecommended $15 million level of investment will affect ada tool capability, tool experience, and languagecapability (see box 3.2). the simplifying assumptions, all made on the conservative side, are as follows:1. only the annual maintenance of the 50 million lines of ada code in existing weapon systems softwareis considered. this assumption is conservative because it does not consider developing and sustainingcurrent and future ada systems.2. only 8 percent of the software will be changed per year. this assumption is conservative with respectto the average rate of change of 11 percent per year for embedded control software and 20 percent peryear for humanmachine interactive software in the cocomo database (boehm, 1981).3. the cost per changed line of code is only $40. this assumption is conservative with respect to generalestimates that changing weapon systems software costs at least $75 per line of code.4. only the effects of investment on ada tool capability and ada language and tool experience areconsidered. this assumption is conservative with respect to other cost effects due to process, reuse,and size improvements (separate vs. common development of infrastructure software).5. the presence versus the absence of an investment program for ada will affect improvement in toolcapability and language and tool experience by one cost model rating level (see box 3.2 for details). this assumption is conservative with respect to the relative effects on other languages that are notsupported by such investment, such as jovial and cms2.6. the effect of increasing tool capability and language and tool experience one rating level is an 8percent improvement. this assumption is conservative with respect to most estimates generated bysoftware cost models, which indicate that the improvement per rating level for these variablesaverages 10 to 12 percent (see box 3.2).given these assumptions, an estimate of the annual cost of sustaining the 50 million lines of code (50mloc) of existing dod weapon systems software in ada is(50 mloc) (0.08/year) ($40/loc) = $160 million/year.with a onelevel improvement in tool capability and language and tool experience, the estimated annual costof sustaining existing dod weapon systems software in ada is($160 million/year) (0.92) (0.92) = $135 million/year.thus, a conservative estimate of the annual maintenance cost savings resulting from a onelevel improvementin capability is $25 million per year, considerably more than the annual investment in ada of $15 million per yearthat would be required to achieve the improvement in rating level.dod software policy: analysis and recommendations50ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.box 3.2 software cost models and the effects of investmentas discussed in chapter 2, most current models for estimating software costs have input parameters orcost drivers reflecting the product's size and the project's personnel, development environment, and processcharacteristics. the personnel and environment cost drivers generally take the form of multipliers affectingthe estimated cost. for example, the cocomo 2.0 tool model rates cost drivers for tools andcorresponding cost multipliers as shown in the following table.relative estimated cost for various levelsof tool supportsupport leveltool rating levelcost multipliervery lowedit, code "debugging" tools1.20lowsimple frontend, backend case; littleintegration1.10nominalbasic lifecycle tools; moderately integrated1.00highstrong, mature lifecycle tools; moderatelyintegrated0.88very highstrong, mature, proactive lifecycle tools;well integrated with processes reuse0.75the stronger the project's tool support, the lower its estimated cost. the estimated cost of a project withlow tool support (simple frontend and backend computerautomated software engineering (case) tools withlittle integration) is 10 percent higher than the estimated cost of a project with nominal tool support (basiclifecycle tools with moderate integration). the values in the table are based on a mix of severalorganizations' experience and calibration to project data. cocomo 2.0 is currently calibrated with data from65 projects, for which the calibrated cost estimates are within 25 percent of the actual cost 60 percent of thetime.the corresponding rating scale and cost multipliers by the cocomo 2.0 ltex (language and toolexperience) model are shown immediately below.relative estimated cost of various levels of support for programminglanguage and tool experiencesupport levelltex ratingacost multipliervery low2 months or less1.24low6 months1.11nominal1 year1.00high3 years0.90very high6 years0.82a ltex: language and tool experiencedod software policy: analysis and recommendations51ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.the use of calendar time as a basis for evaluating experience has both the advantage and disadvantageof being simple. the estimated cost of a project using personnel with low (median of 6 months) language andtool experience is 11 percent higher than the cost of using personnel with a nominal (median of 1 year) levelof experience.other models estimate similar costs. for example, the jensenseer model (jensen and lucas, 1983)and the softcostr model1 have cost drivers comparable to the cocomo tool and ltex cost driver, withcost differentials in the range of 10 to 12 percent per rating level. checkpoint has a "case tools" cost driver,with cost differentials varying from 10 to 15 percent per rating level, depending on interactions with othercost drivers covering staffing, methods, and language level (jones, 1996d).a recent sample of 25 ada projects from the air force cost analysis agency indicates an average toolrating for the level of tool support of "nominal" and an average ltex rating for the level of language and toolexperience support of "high." as discussed in chapter 5, the committee's recommended strategy for dod'sinvestment in ada tools is to invest at the margin with tool suppliers to develop tools with clear benefits thatotherwise would not be built. with this investment, the level of ada tool support likely would increase by onetool rating level over the next 5 years. without this investment, the level of ada tool support would likelydecrease with respect to the pace of surrounding technology. thus, it is reasonable to assume that the neteffect of the ada investment would be an improvement of onelevel on the tool rating scale, and acorresponding 8 percent cost reduction.another effect of the committee's recommended ada investment strategy, discussed in chapter 5, wouldbe to stimulate education and training in ada, again via collaborative investments with suppliers at themargin. without this investment, it will be much harder 5 years from now to find sources of qualified adapersonnel, and the likely net effect will be a onelevel decrease in the average ltex rating for ada projects.with the ada investment, the likely effect will be an increase in the average rating. thus, a conservativeassessment of the net effect of the committee's recommended ada investment would be an increase ofonelevel on the ltex rating scale, and a corresponding 8 percent cost reduction.1 d.j. reifer, personal communication to b. boehm, august 1996.notes1. see also perry (1996b).2. this process is illustrated by the experience of xerox as described in weiderman (1991). xerox's digital systems department evaluatedada, c++, and two other languages for use in large, realtime, embedded systems software, and concluded that ada was superior in termsof language features, implementation, and cost. in practice, however, the bulk of xerox's embedded systems software continues to bedeveloped in c and c++.3. for example, gerald pasternack of citicorp testified to the committee about low awareness of and a low supply of ada programmers inthe new york financial market.4. the committee heard from several dod representatives that measures to reform acquisition emphasize performance requirements overmilitary specifications. this trend can be interpreted as supporting the option of having no requirement to use ada.notes52ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.4implementation of recommended dod software policythe committee's recommendations for dod's software policy address two broad objectives. the first part ofthis chapter describes appropriate principles for selection of a programming language, and appendix a containsthe committee's proposed modifications to a revised version of dod directive 3405.1 (dod, 1987a), which wasin the process of being redrafted during the course of this study. the second component of the committee'srecommendations concerns the software engineering plan review, which is proposed as a method forimplementing dod's software policy and is described in the second part of this chapter.recommended policy for choice of programming language1the committee recommends that dod approach programming language policy at three levels of precedence.the overall goal is to achieve the best combination of costs and benefits (each interpreted quite broadly, asexplained below); a number of principles for acquisition of software follow from and are subordinate to thisoverriding goal. the second level of precedence interprets those principles as they apply to the choice of aprogramming language (at any level of programming). the third level specifies circumstances under which ada isrequired for software development using a thirdgeneration programming language (3gl).this hierarchy expresses goals for software acquisition that are broader than the choice of programminglanguage alone, clarifying the importance of many other decisions (such as decisions about whether to make, buy,or, build components; design of the development process; and necessary skills) required to achieve dod's goals.the focus is on operational software. it does not apply to software developed, acquired, or used by dodresearch and development activities, funded by 6.1, 6.2, and 6.3a appropriations. however, research anddevelopment software efforts likely to lead to new dod operational capabilities should include plans for thetransition of such software to meet operational software policy requirements (these plans are described under"approval authority and milestones" in the next section).implementation of recommended dod software policy53ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.goals of software developmenthighquality, lowcost, and timely delivery are the primary goals for software development. here, "quality"and "cost" are interpreted broadly. quality includes, but is not necessarily limited to, functionality, fitness for apurpose, assurance (including reliability, survivability, availability, safety, and information security), efficiency,ease of use, interoperability, future adaptability (including extensibility, maintainability, portability, scalability,and compliance with standards), and development of dod's software expertise. cost includes, but is not limitedto, full lifecycle monetary costs (i.e., both shortand longterm costs) and the extent of use of other scarceresources such as expert personnel. cost also includes assessment of program risk and monetary and nonmonetaryconsequences of system failure. timely delivery, or schedule, is listed as a third goal because it is difficult toclassify as either a quality or cost factor. these overriding goals are reflected in the following statements, whichthe committee believes should serve as guidance for dod software development.1. projects will specify and prioritize quality, cost, and schedule goals, and will analyze tradeoffs andthe businesscase for particular decisions. failure to articulate and prioritize project requirementsappropriately, and to analyze them in the context of their impacts on cost and schedule, commonlyleads to project failure or inappropriate acquisition decisions. it is not reasonable for dod to specify asingle prioritization of goals, because the importance and relevance of different factors vary widely.however, projects should conduct an analysis and defend it in the review process. requirementsshould not be overstated, an approach that often has the effect of ruling out simpler, more costeffective solutions.2. projects will not develop new software unless quality, cost, and schedule goals cannot be met withnondevelopmental items (ndis). developing and maintaining new software within projects tend to bemore expensive than reusing suitable existing software.3. commercial items are preferred over other nondevelopmental items if they meet quality, cost, andschedule constraints. true commercial items will spread the costs of maintenance and improvementover a larger base, leading to cost savings. issues such as possible "lockin" to a single source shouldbe considered as constraints to achieving desirable qualities such as adaptability and portability.4. software development will emphasize good software engineering practice, including the applicationof management techniques, methodologies, support tools, metrics, and appropriate programminglanguages. good practices provide better quality at lower cost, regardless of which programminglanguage is used. good practices also tend to improve timeliness and reduce risk.5. software developers should be chosen based on their experience,  a criterion that includes, but is notlimited to, successful past performance; experience in the software domain or productline; use ofappropriate management techniques, methodologies, support tools, and metrics; and mature softwareengineering capability and expertise.6. projects will, when possible, exploit and/or contribute to open system architectures and commonproductlines, frameworks, and libraries.  investment in commonality, where feasible, increasesportability and opportunities for reuse, and reduces cost.7. projects will avoid developing projectspecific tools and technologies unless the cost, schedule, and/or quality advantage can be defended. such development is expensive and is seldom justified.implementation of recommended dod software policy54ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.guidelines for choice of programming language1. projects will use the highestlevel language that meets quality, cost, and schedule constraints for eachsoftware component. other things being equal, higherlevel languages increase productivity andreduce cost. specifically, 3gls (highorder languages) are generally preferable to machine orassembly language; further, fourthgeneration programming languages (4gls), program generators,graphical user interface builders, and database query languages, such as structured query language(sql), are generally preferable to 3gls. modification of the lowerlevel language output from ahigherlevel language processor should be considered as programming at the lowerlevel; that is,components written in a language should be maintained in that language, and the output of a languageprocessor should be changed only in exceptional cases.2. standardized and nonproprietary languages are preferred. using standardized languages increasesthe portability of code and programmers, and diminishes the possibility of "lockin" to a singlesource. this principle applies at all language levels. thus standard sql is preferable to a proprietarydatabase query language. in some cases, unusual or "niche" languages are the best choice; however,these choices need to be defended.3. projects should not develop new languages, and language processors for them, except for domainspecific languages that provide directives for application generators. such development is costly, inboth the short and longterm, and should require unusual justification.4. all relevant quality, cost, and schedule factors should be considered in the choice of programminglanguage for each component.applying these four principles, it is reasonable, for example, to use small "shell" scripts to "glue" togethersystem components, rather than writing them in ada or some other highorder language; however, large andcomplex shell scripts may violate the principles by being difficult to maintain. likewise, large packages ofspreadsheet macros, or other code written in (more or less) proprietary 4gls, need to be considered carefully. thekey is to ensure that decisions are made carefully, weighing all relevant economic and engineering cost, quality,and schedule factors. these requirements lead to the following recommended policy for the use of ada.recommended policy for requiring the use of the ada programming languagethe committee believes that ada should be presumed to be the best choice, and thus should be used forsoftware development, for subsystems of dod's operational software systems that meet all of the followingcriteria:1. the subsystem is in a warfighting software application area as defined in chapter 3. while ada maystill be a good choice for other systems, dod policy should require that ada be used only in areaswhere it has clear advantages and is most likely to maximize dod's competitive position relative tothat of its adversaries.2. dod will direct the maintenance of the software. if a vendor is serving a broader customercommunity, then maintenance costs are spread over a larger base and are thus of less concern. if doddirects the maintenance, whether or not the maintenance is performed by dod personnel or a vendor,then dod must cover the lifecycle cost, and ada is assumed to be more costeffective over an entirelifecycle.3. the software subsystem is large, more than 10,000 lines of code, or the subsystem is critical. smalland noncritical subsystems, as a rule, incur lower development and maintenance costs, and thusimplementation of recommended dod software policy55ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.are not worth the cost of oversight. such systems tend to be simpler and the choice of programminglanguage is less critical. however, the choice is more important for critical components.4. there is no better cots, ndi, or 4gl software solution. if existing software or higherlevel languagesolutions are suitable, new development solely to promote ada should not be required.5. there is no lifecycle costeffectiveness justification for using another programming language.6. new software is being developed or an existing subsystem is being reengineered; a reengineering is amodification substantial enough that rewriting the subsystem would be costeffective. for systemsmeeting criteria 1 through 5, ada is generally superior to other highorder languages, and conversionover time should be encouraged.for systems that meet all of the above criteria, ada (preferably ada 95) must be used for the preponderance(95 percent) of new or modified software subsystems or components; up to 5 percent may be written in otherlanguages to facilitate component integration and other functions.projects that meet all of the criteria except number i above must analyze ada as an alternative. as explainedin chapter 2, ada is generally preferred for custom software because, compared with other 3gls, it encouragesbetter software development practices, has better error checking and recovery capacity, has better support incertain domains, is standardized and has a validation facility, contributes to commonality, and leads to highqualityat lower lifecycle cost.software engineering plan review processthe committee recommends that dod broaden its current policy on programming language to include arange of software engineering factors that have a greater overall influence on software capability than does choiceof a particular language alone. this section addresses how policy guidance regarding these factors, as described inchapter 2, can be translated into operational decisions in systems development. the principal mechanism is thesoftware engineering plan review (sepr).the committee explored a number of approaches for integrating selection of a programming language withrelated review and approval processes for software engineering decisions. one approach was to integrate theprogramming language selection process with a capability maturity model assessment (paulk et al., 1993), butthis type of assessment focuses more on organizational process maturity than on specific technical decisions madeby a particular project. another approach was to add review of programming language and software engineeringdecisions to the defense acquisition board (dab) and major automated information systems review council(maisrc) milestones i and ii review processes (as defined by dod directive 5000.2r (dod, 1996c)). keysoftware decisions are generally covered well in maisrc reviews but often fall below the threshold of visibilityin dab reviews, which cover most doddominated software application areas.the committee determined that the dod's best alternative to these two approaches was to require passage of afocused sepr as a part of a major system's dab or maisrc milestone i and ii reviews. seprs used incommercial practice have proven to be highly effective for reviewing software and system requirements, plans,architectural decisions, and programming language decisions at lifecycle points similar to dab and maisrcmilestones i and ii. for example, the sepr concept has been used successfully in large technologydependentcommercial and government organizations, including at&t and lucent technologies (architecture review board(at&t, 1993)), citibank (building permit system), nasa (architecture reviews), and others.2the sepr process is intended to provide a forum for the following activities:implementation of recommended dod software policy56ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.1. involvement of stakeholders in key software engineering decisions,2. contributions of peers and experts to key software engineering decisions,3. stimulating commonality of process and architectural elements where appropriate, and4. establishing accountability of a senior acquisition official for major software engineering decisionsthroughout the lifecycles of related systems.the sepr process is intended to help program managers (and possibly contractors) achieve a bestpracticeslevel of decision making for the software engineering associated with major systems, as well as to assureconsideration of organizational and lifecycle factors. implementation details are established not by seniorofficials, but rather by productline stakeholders and expert peers, who have an incentive to minimize unnecessarybureaucracy and documentation. the principal policy elements for systems subject to dab and maisrc reviewsare the following:1. authority for approving software engineering plans resides in the office of the assistant secretary ofdefense (c3i) and in the service acquisition executives (saes) and their software executiveofficials (seos).2. seprs are conducted by software engineering plan review boards (seprbs) at key points in theengineering process and are conducted by peers and representatives of key stakeholders. thesereviews are typically managed at the program executive officer (peo) level.3. software engineering plans, focusing on major software engineering process, technology, andarchitecture decisions, are submitted by program managers in preparation for the sepr process.4. the office of the assistant secretary of defense (c3i) periodically reviews the effectiveness of thedod services' and dod components' implementation of the sepr process.the sepr process has three elements: (1) a policy framework established for major software engineeringdecisions and for seprs; (2) involvement in the review by peers as well as the principal stakeholders in systemdesign; and (3) software engineering common practices, sepr evaluation criteria, and sepr process policiesdeveloped at the service and command levels (these would be specific to each service, and possibly to peos whocould, for example, require conformance to particular architectural frameworks for a class of systems (e.g., aparticular level of a common operating environment). these three elements are detailed below.policy frameworkthe purpose of the sepr process is to embody institutional and longterm interests in requirements forformulation, development, and postdeployment that might otherwise be neglected or compromised in favor ofshortterm goals. such shortterm expedients could arise as undesired results of incentives created in theacquisition process or for other reasons.early decisions concerning design, process, and other software engineering factors can have a significantinfluence on overall lifecycle cost and risk, and on the potential for productline commonality andinteroperability. for example, the following questions arise: what is the necessary level of maintainability (e.g., ongoing improvements in performance and quality,and evolution of computational infrastructure), and how will it be achieved? what is the necessary level of interoperability (e.g., within productlines, with related dod systems, andwith related systems controlled by allies and in coalition forces), and how will it be achieved?implementation of recommended dod software policy57ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved. what is the necessary level of trustworthiness (inluding reliability, fault tolerance, and survivability), andhow will it be achieved? what are the likely future needs (e.g., new and changed requirements anticipated), and how will they beaccommodated? what are the likely technology constraints, and what plans have been developed for inserting newtechnology?stakeholder rolethe committee recommends that the saes be in charge of carrying out the sepr process at the dod servicelevel. the saes would establish milestones for the sepr process, appoint expert reviewers and stakeholderrepresentatives, and establish criteria for evaluation. the saes and their associated seos would be responsiblefor implementing these functions, although this responsibility could be delegated as detailed below. theappropriate counterparts in other dod components would have corresponding responsibilities.the most important element is participation in the sepr by peer software managers experienced in theapplication area, as well as by key stakeholders as either advocates or reviewers. because the seprb's staffingfrom stakeholder organizations can vary considerably among systems, seprb representation is divided intomandatory and discretionary categories. the sae must appoint representatives from mandatory stakeholders, butcan include discretionary stakeholders as appropriate to the software engineering plan to be reviewed.for systems subject to milestone decision authority (mda) at the service level or in the office of thesecretary of defense, the mandatory list of stakeholders and peer reviewers includes the following:1. the peos (senior productline officials) responsible for both development and postdeploymentsupport for the candidate system and closely related systems;2. management and technical officials responsible for maintenance of the systems being specified ordeveloped;3. representatives from user organizations, as appropriate;4. peer program managers with related software engineering management experience; and5. program managers for the system being specified, developed, or reengineered (stakeholders, butreviews rather than reviewers).the discretionary list of stakeholders depends on the characteristics of the system being developed, but couldinclude the following:1. program managers for development and support of critical related systems that must interoperate withor are otherwise closely affected by the system under review;2. representatives of the dod community who have specific technical expertise and cognizance ofemerging technologies;3. representatives of other program executive offices, program offices, or other components that areresponsible for key common architectural frameworks; and4. representation, where appropriate, from the office of the secretary of defense or the joint chiefs ofstaff.implementation of recommended dod software policy58ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.approval authority and milestonesfor systems subject to mda, approval authority for the process resides with the assistant secretary ofdefense (c3i) or the sae, depending on the class of system. the direct management of the sepr process wouldbe carried out by the saes and their associated seos, with possible delegation to the peo level. but the actualapproval authority should not be delegated beyond the sae. the assistant secretary of defense (c3i) wouldmonitor the review process.when significant deviations are needed from dod's stated policy and principles, direct approval of theassistant secretary of defense (c3i) may be required; this should be determined when approval authority isdelegated to the saes. it is the intent of these recommendations, however, that policy be framed with sufficientflexibility and outlook to the future that such deviations are not required in the ordinary conduct of business. it isalso the intent that implementation be delegated to a level sufficient to ensure in depth review of softwareengineering decisions. seprs are ongoing processes, with specific approvals pertinent to specific milestones.seprs must be linked, at a minimum, to dab and maisrc milestones i and ii.many smaller systems are subject to dod software engineering policy, but not to mda. for these systems,approval authority resides with the sae, but there is flexibility with respect to delegation and the need for formalseprs. normally, the sae can delegate approval authority to a peo or, for very small systems, to a majorcommand. in the latter case, approval can be granted for a family of related small systems as a result of a softwareengineering plan for a single productline. but the committee suggests that for nonmda systems, the decision toconduct a formal sepr process (or some more expedient process) be required for warfighting software, and be arecommended practice at the discretion of the approval authority for other software.given that the director of defense research and engineering (ddr&e) is responsible for advanced (6.3a)research, the committee recommends that the ddr&e establish a software engineering review process thataddresses issues pertinent to the efficient transition of software technologies associated with major 6.3ademonstration programs, including plans to modify prototype 6.3a software to conform to the committee'srecommended policy on selection of programming language, as appropriate. the review criteria, which would beat the discretion of the ddr&e, would not need to use the sepr process, thus enabling the ddr&e to managethe tradeoff between efficient transitions, on the one hand, and responsiveness and flexibility of researchprograms to the emergence of new technologies and concepts, on the other.submission of software engineering plansas envisioned by the committee, the sepr process requires program managers responsible for mda systemspecification, development, and major reengineering efforts to submit a software engineering plan, preceded by arequest to the sae to convene a seprb. the sae, considering the recommendations of the program manager andthe cognizant peo, would then select stakeholder organizations, which appoint representatives. for smallersystems, the sae and peo roles are further delegated, as indicated above.it is the committee's intent that the approval authority would work with the seprb and the program managerto develop a software engineering plan suitable for the project and in conformance with all dod policies. no entryinto the dab milestone i and ii reviews could be initiated without concurrence of the approval authority. criteriaused for evaluation of the software engineering plan should be defined by the approval authority.the software engineering plan should be a simple document3 and should cover areas relevant to the decisionprocess, including the following:implementation of recommended dod software policy59ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved. the system's scope and concept of operation; the key system and software requirements, including stakeholder needs; the key elements of the system and software architecture, including programming language decisions; the system and software lifecycle plans, including increments, budgets, and schedules; and a rationale demonstrating that the software can be developed within the budget and schedule specified inthe lifecycle plan, can satisfy the requirements and key stakeholder needs, and can successfully supportthe concept of operation.the sepr approval authority, in consultation with peo and program manager representatives, would developspecific criteria to be reviewed. the criteria for review could include, for example: system structural architecture, partitioning the system into components; differentiation of key architecture requirements from secondary features and capabilities; nature and extent of compliance of the architectural plan with related openarchitecture and dodframework common interfaces; definition of increments and completion criteria (e.g., design to cost); cost and risk management; risk management plan designed into early releases; metrics for indicating progress and measuring completion of milestones; major milestone content, evaluation criteria, and demonstration scenarios; and basis for decisions to make, buy, or reuse components (see below).for each subsystem or component in the system, the following areas should be addressed: availability of cots products, nondevelopmental items, and other existing or reusable components; appropriateness of new development; appropriateness of new development for reuse (capitalization) in related systems; potential for reuse or insertion into other related systemsincentives can be established by additionalresources provided by the peo; use of tooling and generators for development, and status of the tooling and generators; degree of compliance with related interface or framework standards; maintenance responsibility (government, contractor, or commercial); and choice of programming language, subject to the recommended policy in appendix a.software engineering codesas experience is gained, saes, peos, and other stakeholders will develop servicespecific or domainspecific refinements of the review criteria listed in the previous section. for example, a service may designateconformance with a common architectural framework as a review item. these refinements may attain the status ofsoftware engineering "codes" (analogous to building codes) particular to a service or peo productline. thesewould serve as "bestpractices" documents that would necessarily evolve over time, according to requirements andtechnology developments. they would also enable program managers to develop expectations concerning thesepr process on the basis of their conformance with such codes.implementation of recommended dod software policy60ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.notes1. this section and appendix a present similar material in different formats. appendix a was prepared by the committee to serve as aproposed revision to dod directive 3405.1 (dod, 1987a); this section discusses the principles and rationale underlying the committee'ssuggested changes to that policy document.2. the committee recommends using the term "software engineering plan reviews" rather than "architecture reviews" to emphasize theimportance of integrating plans for products (i.e., architecture or building plan) with plans for process (e.g., increments, milestones,budgets).3. the lifecycle objectives and lifecycle architecture milestones introduced in boehm (1996) provide guidelines for the level of detail of asoftware engineering plan desired at dab and maisrc milestones i and ii.notes61ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.5implementation of recommended strategy for investment inadathis chapter describes the committee's recommended $15 million annual investment strategy for ada in thecontext of the focus on use of ada for dod's warfighting software. the components of the strategy aremaintaining and enhancing the ada 95 language; ensuring support for ada's compilers, tools, and applicationprogramming interfaces (apis) for warfighting systems; stimulating ada education and curriculum development;and providing support for a centralized source of ada information and expertise within dod. the chapterconcludes by providing a detailed plan and funding breakdown for the recommended investments in ada.goals of the investment strategyit is important to state explicitly what the goals of the proposed investment and procurement strategy for adaare, and what they are not. using ada benefits dod mainly because of the language's orientation towardreliability. ada's features are designed to maximize the chance that a coding error will be detected at compiletime, and failing that, at runtime. as illustrated in "technical evaluation of ada 95 and other thirdgenerationprogramming languages" in chapter 2, ada is ahead of languages such as c and c++ in that it provides strongsupport for compiletime and runtime consistency checking. although other languages may approach ada in theirability to check reliability and consistency, no other thirdgeneration programming language (3gl) has achievedcomparably widespread use for critical (highassurance, and often realtime) systems.the first goal is to ensure that ada tools for critical warfighting software development are superior to thosein other languages. this is at the heart of the strategy to keep ada competitively superior for the development ofwarfighting software systems. it involves a proactive strategy of seeking out and expediting (via complementaryfunding) development of such tools for the commercial marketplace.the second goal is to ensure that robust ada compilers and associated tools for host and target computersused in dod's warfighting systems remain available and reasonable in cost. it is not a goalimplementation of recommended strategy for investment in ada62ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.to make ada compilers as inexpensive or ubiquitous as c compilers. the strategy recognizes that a compiler for areliabilityoriented language like ada, with large numbers of compiletime and runtime consistency checks, willinevitably be larger and more expensive to develop and maintain than other 3gl compilers. a reasonable targetwould be for a productionquality ada compiler to be available at a price comparable to the cost of a productionquality c compiler, plus additional productionquality thirdparty compiletime and runtime checking tools for c(for example, a "lint"like tool and a "purify"like tool). the strategy also recognizes that any compiler for anembedded system with associated robust cross"debugging" support and integration with an appropriate realtimeexecutive will be more expensive than a personal computer (pc) native compiler. it is not expected that adacrosscompilers will ever match the price of offtheshelf pc native compilers.for similar reasons, it is not a goal that ada become the predominant programming language for commercialprogramming. for critical systems programming, ada already has a significant market share. nevertheless, this is arelatively small marketplace, and dod is a major player, meaning that it will have to continue to invest in themarket for tools that support the development of critical systems.the third goal is to ensure that an adacompatible interface is readily available for all offtheshelf softwarecomponents used in dod's warfighting systems. such systems include relevant database management systems,operating systems, realtime executives, and networking packages. it is not a goal that such componentsnecessarily be written in ada.the fourth goal is that more educational institutions provide exposure to ada concepts in the context of asoftware engineering curriculum, particularly in courses covering critical systems development. it is not a goalthat ada become the predominant teaching language (though ada has advantages for teaching because of itsreadability and consistency checking). rather, the goal is to increase the exposure to and use of ada in theeducational environment, thereby increasing the pool of programmers familiar with ada and reducing the ultimatetraining costs for dod's contractor community.a related goal is to increase the use of ada in software engineering research, which will enhance the adatechnology base for warfighting systems, as well as increase exposure to and understanding of ada in theacademic and research communities. it is not suggested that all dodsponsored research use ada or that all dodresearch prototypes be written in ada. rather, it is recommended that critical systems software research emphasizeada's use, that more research programs include ada in the set of languages they consider, and that an increasednumber of advanced technology tools support ada in addition to other languages that are supported.the final goal relates to centralized support and infrastructure for dod 's use of ada. dod can continue tobenefit from using ada for its critical systems, but the benefits will be offset by other cost increases if each projectneeds to maintain its own support infrastructure for ada. by continuing to support a centralized organization likethe ada joint program office, even if its mission is redirected toward ongoing support rather than productdevelopment, dod can achieve economies of scale. it is not suggested that such an organization directly supportthe development of new ada compilers. rather, it is emphasized that a centralized organization is necessary toprovide expertise, resource directories (such as the world wide web site supported by the ada joint programoffice), technology management, and technology transition.ada investment strategydod can benefit from providing ongoing support for ada technology by building on its significantinvestment in ada 83, and the ada 95 revision. in addition, dod should use its leverage as a large customer forcommercial hardware and software products to expand the availability of commercial tools and components thatsupport ada, which would help the ada market become more selfsustaining.implementation of recommended strategy for investment in ada63ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.continued investment by dod is required in the following areas:1. supporting the continued maintenance of the ada 95 language, and the enhancement of adarelatedsecondary standards in areas relevant to defense systems;2. ensuring that, for all dod warfighting systems, hardware has robust ada compiler and tool support,commercial offtheshelf (cots) software has adacompatible apis, and ada tools for criticalwarfighting software are superior to those in other languages;3. providing support for the continued development of curricula related to ada and software engineeringin the nation's colleges and universities, particularly in the area of critical systems; and4. funding a centralized dod source of information and expertise on ada and related softwareengineering technologies.each area is discussed in more detail below.language maintenance and enhancementthe ada 95 standard requires ongoing support. parts of the standard require interpretation, implying the needfor a group of experts to meet periodically to resolve these issues. any large software system will developunanticipated requirements for improvement as its use becomes widespread, and ada 95 is no exception. inaddition, advanced areas such as security, distribution, or persistence require ongoing development of "secondary"standards and accompanying validation test suites to systematize the best way to use ada in these areas. for ada,there is an international organization for standardization working group (iso wg9), which has a number of"rapporteur" groups that coordinate these maintenance and secondary standardization tasks. funding of thesegroups is essential to make their activities effective and timely, and dod must provide some of the critical fundingto keep these groups active. even in the area of compiler validation, where the commerce department's nationalinstitute of standards and technology is now providing a nominal level of support, dod may find it necessary toprovide funding to ensure that its highpriority needs are met in a timely manner.support for ada compilers, tools, and application programming interfacesada 95 is a technically successful revision of ada 83. like all standards, however, it needs "champions" forits adoption, since there are always costs involved in adopting a standard or revision. now that the ada 95 revisionis complete, the user and supplier communities must be given incentives to adopt the standard. although dod isno longer a dominant player in the software market, it is still a large customer, and arguably the primary customerfor critical systems. any major customer can establish incentives to motivate its suppliers to support a preferredstandard; in order for dod to play this role for its critical warfighting systems, it must emphasize the importanceof providing support for ada compilers and tools, and for ada apis for warfighting software applications. dodshould similarly use its market power to make it possible to tailor a warfighting system to operate efficiently inada, even if the original system was built largely using cots components or nonada technologies. this meansthat dod should require that all components included in dod warfighting software have a demonstrable, fullfunction, adacallable interface. for example, all operating systems used in dod warfighting systems shouldinclude an adacallable interface, sufficient for exercising all capabilities of the operating system necessary forwarfighting systems. the adacallable interface must be kept up to date by the operating system supplier; in orderfor a capability to be considered acceptable for delivery, itimplementation of recommended strategy for investment in ada64ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.must be accessible via ada. similarly, a hardware device that is controlled by software should be delivered with ademonstrable adacallable interface before it is accepted for a dod warfighting system.another incentive to encourage use of ada is to ensure that all computers used for developing dodwarfighting software include an ada compiler at a price and quality comparable to those of other compilers. thecriteria for choosing a computer for hosting software development should include the availability, price, andquality of the ada compiler. this will help to ensure that hardware vendors wishing to sell in the dod warfightingsystems marketplace make certain that there is a highquality, reasonably priced ada compiler on their platform.warfighting systems procurements should stipulate that ada compilers be available at the same time theequipment is available, rather than months or years later. this approach will ensure that ada development remainsviable on hardware platforms relevant to dod.for ada to be a viable option for a given system, appropriate ada compilers and associated tools must beavailable for the relevant host and target hardware. in the mid 1980s, most hardware vendors made an effort toensure that an ada compiler and associated tools existed for their hardware. recently, however, the burden seemsto have shifted from the hardware vendors to the individual system development contractors. the linkage betweenpurchasing hardware and compiler availability seems to have been lost.in addition to robust support for compilers, adacompatible apis to relevant cots software components arealso important to make the use of ada costeffective. as in the hardware area, the linkage between selling softwarecomponents to dod and providing appropriate ada support seems to have been lost. for example, rather thanrequiring that database management systems for warfighting software systems come with an adacompatibleinterface, the burden seems to have shifted to individual contractors to acquire or develop such interfaces. becausecots software products are being continually enhanced, this approach is even less satisfactory than in thehardware area.providing multilingual interfaces to cots software products is now done as a matter of course. as withhardware, software vendors who wish to compete for dod warfighting systems business should recognize thatincluding ada among the languages supported is a normal cost of doing business. the cost of including an adacompatible interface is relatively small. with the advent of multilingual interface standards such as corba idl,1this proposed requirement becomes even more practical. on the other hand, when the burden of providing anadacompatible interface is left to individual contractors, the cost is greater, particularly given the need to keep upwith ongoing enhancements.dod should recreate this linkage between robust ada compiler and tool support and the choice of hardware.hardware vendors who wish to compete for dod warfighting systems procurements should see the provision ofappropriate ada support as a requirement, in the same way that hardware vendors have recognized the need toprovide a posixcompliant2 operating system to satisfy dod's open systems requirements.as defined in chapter 2, "warfighting systems" are the highassurance, performancecritical portions ofsystems for weapon control, electronic warfare, wideband realtime surveillance, realtime battle management, andspecial battlefield communications. the ada support requirements recommended above apply only to hardwareand software vendors choosing to support such systems. examples of ada tools that support critical warfightingsoftware engineering include adaoriented tools for realtime and faulttolerant software; tools for softwarereliability, availability, survivability, security, and safety assurance; tools to facilitate effective use of ada 95'snew, objectoriented, realtime, and distributed system capabilities for warfighting systems; and adaorientedtools for special warfighting applications domains (e.g., realtime distributed avionics systems test, debugging, andperformance tuning).implementation of recommended strategy for investment in ada65ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.curriculum developmentfor the past several years, the ada joint program office has provided support for the development of adabased curriculums at a number of u.s. colleges and universities. this has contributed to the growing number ofcolleges and universities that include ada and software engineering in their computer science programs. asdiscussed in chapter 1, the number of courses in ada and in software engineering has increased recently, but thereare still many colleges and universities that provide little or no exposure to the kinds of software challenges facedin the development of complex critical systems. one of the frequent concerns of defense contractors has been theavailability of welltrained software engineers. since dod's investments in ada curriculum development seem tohave assisted in such training, the grants for this purpose should continue. an effort to distribute the grantsgeographically is advisable, to ensure that ada instruction is available in areas where dod warfighting systemsare developed.in addition to supporting adarelated curriculum development, dod should ensure that some portion of itssoftware research budget is focused on enhancing the ada technology base. a growing number of tools andtechniques are being investigated in the research community for enhancing the productivity and quality of softwaredevelopment. whether these tools are actually written in ada is not particularly relevant to dod. what isrelevant, however, is whether these tools can be used to support systems with components written in ada. with theavailability of the gnat compiler in source code (for details, see chapter 1), there are fewer obstacles to the useof ada as a vehicle for research in programming languages and programming support tools.in keeping with the competitive strategy recommended in earlier chapters, this investment package shouldplace a highpriority on adabased research and curriculum development for software needs in warfightingapplication domains (e.g., for realtime, highassurance software).centralized support organizationin testimony provided to the committee, the importance of a centralized organization to support ada andrelated software engineering technologies was repeatedly stressed. the ada joint program office has served thisfunction over the past decade. while it is not the role of this committee to recommend the disposition of thisfunction, it may be appropriate to consider transferring executive responsibility to a higherlevel organization withcognizance over warfighting software, such as the office of the assistant secretary of defense (c3i) or theundersecretary of defense (acquisition and technology). with regard to choosing a support organization, it isworth noting that ada is one of several software technologies important to defense systems. thus, combiningsupport for ada with support for other important software technologies might save resources and provide betterservice overall.detailed plan for investments in ada technology and supportchapter 3 presented the argument that if ada 95 is well supported, it could create a significant warfightingcompetitive advantage for dod. the committee recommends the following investment strategy to help bring thisabout. the overall $15 million annual budget needed for ongoing enhancement of adarelated technology, andongoing support for the effective use of ada within the dod community, can be divided into two major areas. thefirst is for funding contracts with organizations outside dod. the second area is for funding the ongoing activitiesof a centralized support organization within dod oriented toward programming languages.implementation of recommended strategy for investment in ada66ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.the total annual budget of $11.5 million for contracts should be allocated as follows: education contracts for ada and software engineering curriculum development:$1.5 million, based on approximately 20 awards at $75,000 each; application programming interface binding development and maintenance:$1.0 million, based on approximately 5 awards at $200,000 each; expert consultation to support language maintenance and evolution:$0.6 million, based on approximately 15 parttime experts at $40,000 each; maintenance and enhancement of validation suites:$0.4 million, based on approximately 2 awards at $200,000 each; and development of warfightingcritical tools and technology:$8.0 million, based on approximately 15 fully funded academic/researchoriented awards averaging$200,000 each, and 20 cofunded industry/developmentoriented awards averaging $250,000 in dodfunds each.the annual budget of $3.5 million for a centralized support organization should be distributed as follows: compliance monitoring to identify gaps in technology that are hindering compliance and to identifypossible remedies:$0.5 million; support of an information clearinghouse and a world wide web home page:$1.0 million; development of dodoriented education and training materials, ada 83/ada 95 transition support andtools, and technology insertion:$1.0 million; and metrics on programming language usage, costeffectiveness, performance, and defect rates; collection,analysis, and dispersal of the information:$1.0 million.as stated above, it is important to emphasize that these are not onetime investments, but rather continuinginvestments to maintain and enhance the effectiveness of ada for dod. it is also important to recognize that this$15 million annual dod investment is designed to expedite desired capabilities by leveraging the existing $200million annual ada market. it does not represent the entire investment required for ada support.conclusionif dod continues to specify ada as the preferred programming languagešfor any application domainsšit isessential that it make investments such as those outlined in this chapter. the only other sources of ada support areindividual projects, and burdening them would be inefficient, duplicative, and a major disincentive for projects touse ada. from a vendor's standpoint, it would put ada into the same narrow niche as jovial, which has very littlesupport for compilers, tools, bindings, and runtime applications.furthermore, failure to make the relatively modest level of investment described above would imperil theexisting body of ada code for dod's weapon systems. independent of the question of future systemsdevelopment, the legacy of developed ada code requires a robust development community. theimplementation of recommended strategy for investment in ada67ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.economic analysis presented in chapter 3 shows that the cost savings from maintaining this legacy code alone aresufficient to justify the recommended $15 million annual investment in ada. but even further, as discussed in thebusinesscase analysis, the investment provides dod with a key competitive advantage in warfighting software tomore completely achieve its objective of military information dominance.notes1. common object request broker architecture interface definition language.2. portable open systems interface.notes68ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.bibliographyaerospace industries association (aia). 1996. "aia position statement on ada." unpublished manuscript. aia, washington, d.c., july 12.aley, james. 1996. "give it away and get rich." fortune, june 10, p. 98.at&t. 1993. "best current practices: software architecture validation." at&t, murray hill, n.j.boehm, barry. 1981. software engineering economics. prenticehall, englewood cliffs, n.j.boehm, barry, and w.e. royce. 1988. "trw ioc ada cocomo: definition and refinements." proceedings of the 4th cocomo usersgroup, pittsburgh, pa., november.boehm, barry. 1996. "anchoring the software process." ieee software,  vol. 13, no. 4, july, pp. 7382.boehm, barry, et al. 1996. "the cocomo 2.0 software cost estimation model: a status report." american programmer, vol. 9, no. 7,july, pp. 217.booch, grady. 1987. software engineering with ada, third edition, chapter 3: "the history of ada's development." benjamin/cummings,menlo park, calif.brooks, jr., frederick p. 1986. "no silver bulletessence and accidents of software engineering." information processing 86, pp. 10691076.(reprinted in ieee computer magazine, april 1987.)brown, norm. 1996. "industrial strength management strategies." ieee software, vol. 13, no. 4, july, pp. 94103.carleton, anita d., et al. 1992. "defining and using software measures." software engineering institute technical reports, cmuseitr11, 1923. software engineering institute, pittsburgh, pa.computer science and telecommunications board (cstb). 1989. scaling up: a research agenda for software engineering. nationalacademy press, washington, d.c.cta. 1991. "survey and analysis of productivity and cost data on ada and c++ software development programs." cta incorporated,burlington, mass., june 26.department of defense (dod). 1976. directive 5000.29, "management of computer resources in major defense systems." april 26.department of defense (dod). 1987a. directive 3405.1, "computer programming language policy." april 2.department of defense (dod). 1987b. "military software." defense science board task force on military software (frederick p. brooks,jr., chair), office of the under secretary of defense for acquisition, dod, washington, d.c., september.department of defense (dod). 1991. "draft dod software technology strategy." director of defense research and engineering, dod,washington, d.c., december.bibliography69ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.department of defense (dod). 1992. "delegations of authority and clarifying guidance on waivers from the use of the ada programminglanguage." april 17.department of defense (dod). 1994a. "report of the defense science board task force on acquiring defense software commercially."dod, washington, d.c., june.department of defense (dod). 1994b. "specifications and standards: a new way of doing business." june 29.department of defense (dod). 1995a. "new world vistas: air and space power for the 21st century. information technology volume." airforce scientific advisory board, washington d.c.department of defense (dod). 1995b. "dual use technology: a defense strategy for affordable, leadingedge technology." undersecretary of defense for acquisition and technology, dod, washington, d.c., february.department of defense (dod). 1995c. "arpa software review panelfinal report." dod, washington, d.c., october.department of defense (dod). 1996a. "practical software measurement version 2.1." joint logistics commanders, joint group on systemsengineering, dod, washington, d.c., march 27.department of defense (dod). 1996b. directive 5000.1, "defense acquisition." february 21.department of defense (dod). 1996c. regulation 5000.2r, "mandatory procedures for major defense acquisition programs (mdaps) andmajor automated information system (mais) acquisition programs." march 15.department of defense (dod). 1996d. "joint warfighting science and technology plan." office of the secretary of defense, dod,washington, d.c., may.druffel, larry. 1993. "ada position paper." unpublished manuscript, december 1.emery, james c., and martin j. mccaffrey. 1991. "ada and management information systems: policy issues concerning programminglanguage options for the department of defense." naval postgraduate school, monterey, calif., june.emery, james c., and dani zweig. 1993. "the use of ada for the implementation of automated information systems within the departmentof defense." naval postgraduate school, monterey, calif., december 28.feigenbaum, edward. 1996. "the ada mandate." unpublished manuscript, chief scientist, u.s. air force.feldman, michael b. 1996. "ada as a foundation programming language." available online at http://www.seas.gwu.edu/faculty/mfeldman/cs 12.html#2.fisher, d.a. 1976. "a common programming language for the department of defensebackground and technical requirements." reportp1991. institute for defense analyses, p. 6. (cited by g. booch in software engineering with ada, third edition, 1987, p. 9.)fisher, david. 1974. "automatic data processing costs in the defense department." ida paper p1046. institute for defense analyses,alexandria, va., october.frazier, thomas p., and john w. bailey. 1996. "the costs and benefits of domainoriented software reuse: evidence from the starsdemonstration projects." ida paper p3191. institute for defense analyses, alexandria, va., june.general accounting office. 1989. "programming language: status, costs, and issues associated with defense's implementation of ada."gao/imtec899. general accounting office, washington, d.c., march.general accounting office. 1991. "programming language: defense policies and plans for implementing ada." gao/imtec9170br.general accounting office, washington, d.c., september.general accounting office. 1993. "software reuse: major issues need to be resolved before benefits can be achieved." gao/imtec9316. general accounting office, washington, d.c., january.giallombardo, robert j. 1992. "effort and schedule estimating models for ada software development." mtr 11303. mitre corporation,bedford, mass., may.hook, audrey a., et al. 1991. "availability of ada and c++ compilers, tools, education and training." ida paper p2601. institute fordefense analyses, alexandria, va., june 12.hook, audrey a., et al. 1995. "a survey of computer programming languages currently used in the department of defense." ida paperp3054. institute for defense analyses, alexandria, va., january.horowitz, barry. 1991. "the importance of architecture in dod software." m9135. mitre corporation, bedford, mass., july.ibm federal systems division. 1985. "language selection analysis report." faa85s0874. prepared for the federal aviationadministration, gaithersburg, md., may.bibliography70ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.iit research institute (iitri). 1996. "catalog of resources for education in ada and software engineering, version 8.0." prepared for theada joint program office, arlington, va., january.jensen, l.w., and s. lucas. 1983. "sensitivity analysis of the jensen software model." hughes aircraft co., los angeles, calif.jones, capers. 1994. "the economics of object oriented software." american programmer, vol. 7, no. 10, october, pp. 2835.jones, capers. 1995. "backfiring: converting lines of code to function points." computer, vol. 28, no. 11, november, pp. 8788.jones, capers. 1996a. "estimating and measuring objectoriented software." unpublished manuscript, february 1.jones, capers. 1996b. "the economic impact of the year 2000 software problem in the united statesversion 2." software productivityresearch inc., burlington, mass., february 22.jones, capers. 1996c. "programming languages table, version 8.2." software productivity research inc., available online at http://www.spr.com/library/langtbl.html.jones, capers. 1996d. "using function points to evaluate case tools, version 4." software productivity research inc., burlington, mass.,august 6.landry, huet c. 1996. "comments on ada mandate." unpublished manuscript, defense information systems agency/jebeb, softwareengineering standards.lawlis, patricia k. 1996. "guidelines for choosing a computer language: support for the visionary organization." c.j. kemp systems inc.,march.lubashevsky. 1996. "'backfire' will backfire." measure up. software productivity solutions inc., indiatlantic, fla., january, pp. 16.maranzano, joe. 1995. "system architecture validation review findings." at&t software technology center, april.masters, michael w. 1996. "programming languages and lifecycle cost." naval surface weapons center, dahlgren, va., march 18.mcgarry, frank, et al., 1994. "software process improvement in the nasa software engineering laboratory." cmu sei94tr22. softwareengineering institute, pittsburgh, pa., december.mosemann, lloyd k. 1991. "ada and c++: a businesscase analysis." deputy assistant secretary of the air force, washington, d.c., july9.national academy of engineering. 1996. defense software research, development and demonstration: capitalizing on continued growth inprivatesector investment. national academy press, washington, d.c., march.national research council. 1995. researchdoctorate programs in the united states: continuity and change. national academy press,washington, d.c.paulk, mark c., et al. 1993. "capability maturity model for software, version 1.1." cmu/sei93tr24. software engineering institute,carnegie mellon university, pittsburgh, pa., february.perry, william. 1996a. "national academy of engineering, bueche prize acceptance address." transcript. national academy ofengineering, washington, d.c., october 2.perry, william. 1996b. "defense in an age of hope." foreign affairs,  novemberdecember, pp. 6479. porter, michael e. 1990. thecompetitive advantage of nations. the free press, new york. powell, colin. 1992. "c41 for the warrior." dod joint chiefs ofstaff, washington, d.c., june 12.quade, e.s., ed. 1964. analysis for military decisions. rand mcnally, chicago. quade, e.s., and boucher, w.i., eds. 1968. systems analysis and policy planning: applications in defense. american elsevier, new york.reifer, donald j. 1996. "quantifying the debate: ada versus c++." crosstalk: the journal of defense software engineering. hill afb, utah,july.riehle, richard. 1996. "ada: an update." object magazine, june, pp. 5052.royce, walker. 1990. "trw's ada process model for incremental development of large software systems." proceedings icse 12, ieee/acm, march, pp. 211.shaw, mary, and david garlan. 1996. software architecture: perspectives on an emerging discipline. prenticehall, englewood cliffs, n.j.telos corporation. 1994. "ada marketing communications study precampaign survey." telos corporation, may.tokar, joyce. 1996. "ada 95: the language for the '90s and beyond." object magazine, june, pp. 5356.bibliography71ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.trw. 1991. "ada and c++: a lifecycle cost analysis." trw inc., redondo beach, calif., june 1.trw. 1991. "case study: ada and c++ cost comparison for ccpdsr." trw inc., redondo beach, calif., june 1.u.s. army. 1992. "implementation of the ada programming language." hqda ltr 25921. september 18.u.s. army. 1994. "change to hqda letter 25921, implementation of the ada programming language." hqda ltr 25941. july 17.u.s. army. 1995. "change to hqda letter 25941, implementation of the ada programming language." hqda ltr 25951. july 17.u.s. navy. 1994. "ada programming language policy," secnavinst 5234.2a. april 28.u.s. navy. 1994. "ada implementation guide," 2 vol. naval information systems management center, april.vyssotsky, victor. 1996. "whither ada?" unpublished manuscript, may 12.waligora, sharon, john baily, and mike stark. 1995. "impact of ada and objectoriented design in the flight dynamics division at goddardspace flight center." nasasel report, sel95001. goddard space flight center, march.weiderman, nelson. 1991. "a comparison of ada 83 and c++." sei91sr4. software engineering institute, pittsburgh, pa., june.zeigler, stephen f. 1995. "comparing development costs of c and ada." rational software corporation, santa clara, calif., march 30.bibliography72ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.appendixesappendixes73ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.appendixes74ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.appendix adod draft software management policy directive withfurther modifications suggested by the committeeintroductionthe committee on the review of the past and present contexts for the use of ada in the department ofdefense reviewed the dod policy currently in use for programming language selection ("computer programminglanguage policy," dod directive 3405.1, dated april 2, 1987), as well as two different draft revisions of thatpolicy. this appendix contains the most recent draft (dated may 15, 1996) reviewed by the committee andincorporates modifications suggested by the committee to make the directive consistent with the recommendationspresented in the main text of this report. modifications are noted in italic font.this modified draft directive is intended to serve as a "template" for development of the new dod directive3405.1. the "enclosures" that are typically attached to dod directives have been omitted for brevity. however, alist of references follows the text of the draft directive, and technical terms are defined in appendix c of thisreport; both sets of documentation are suitable as enclosures for the revised formal dod directive. the enclosuretitled "ada waiver procedures" has been omitted from the template because the committee eliminated the waiverprocess in its recommended policy. other emendations of the draft text to condense wording or otherwise reviseoriginal text are not strictly documented; comparison with the may 15, 1996, draft directive shows minor changesnot accommodated by the device of italicizing more substantial revisions.proposed template for dod directive on software managementa. reissuance and purposethis directive:appendix a75ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.1. updates and establishes policy for management of software developed, used, or maintained by, or for,the department of defense (dod).2. is used in software management decisions across a functional or mission area, domain, or productline. it contains broad software engineering and programming language policy that will be followedby dod.3. establishes the requirement for a software engineering plan review board (seprb) by the office ofthe secretary of defense (osd), the military departments (including the national guard and reservecomponents), and the dod components.4. supersedes reference (a); cancels references (b) and (c); implements federal information resourcemanagement regulation (firmr) subpart 20124.201, federal software exchange program(reference (d)); and supports dod directive 8000.1 (reference (e)) and dod directive 5000.1(reference (f)) and dod instruction 5000.2 (reference (g)).5. authorizes publication of dod instruction 3405.1, "software management implementation."b. applicability and scopethis directive applies to:1. the office of the secretary of defense (osd), the military departments (including the nationalguard and reserve components), the chairman of the joint chiefs of staff and the joint staff, theunified combatant commands, the inspector general of the department of defense, the defenseagencies, and the dod field activities (hereafter referred to collectively as "the dodcomponents").2. all software developed, acquired, or used by the dod, including that managed in accordance withdod directive 5000.1 (reference (f)).3. dod research and development activities funded by 6.4 and 6.5 appropriations as defined in volume2, dod 7000.14r, (reference (1)).4. software developed, acquired, or used by dod research and development activities, and funded by6.1, 6.2, and 6. 3a appropriations, is exempted from this directive.c. definitionscommittee note: terms used in this directive and modifications to it are defined in appendix c of this report,and those definitions are suitable for inclusion as an enclosure in a new dod directive.d. policyit is dod policy to:1. perform tradeoff and businesscase analysis in the development and acquisition of affordable,rapidly produced, highquality software. quality includes functionality, fitness for a purpose,assurance (i.e., reliability, survivability, availability, safety, security), efficiency, ease of use,interoperability, future adaptability (i.e., extensibility, maintainability, portability, and compliancewith standards), and the development of dod software expertise. cost includes full lifecycle cost,consequence of system failure, impact on system operational costs, and use of other scarce resourcessuch as expert personnel.2. exploit and contribute to open standardsbased technical architectures that support rapid, flexible,and incremental software improvements, and that accommodate increasing reliance on thecommercial sector to satisfy evolving mission and functional requirements. exploit and contribute toappendix a76ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.software architectures that serve as the basis for management and investment decisions for reuseopportunities, interoperability requirements, and development or productlines and productlinecomponents. facilitate the reuse of software assets.3. define mission and functional requirements so that commercial and nondevelopmental items may beused to fulfill such requirements. to the maximum extent practicable, modify requirements andconduct market research and analysis, prior to commencing a development effort, to take advantageof a commercial or nondevelopmental "best value" solution. give preference to commercial offtheshelf (cots) items first and nondevelopmental items (ndi) second when satisfying software assetrequirements.4. implement and continuously improve software process management and software engineeringdisciplines. use software engineering environments that facilitate software process management andsoftware engineering disciplines.5. employ software developers who possess mature software engineering capabilities. softwaredevelopers should have a successful past performance record, experience in the software domain orproductline, a mature software development process, and evidence of use and adequate staffing andtraining in software methodologies, tools, and environments.6. use metrics when monitoring and managing production and delivery of software assets, evaluatingmaintenance and management practices, implementing software architectures and productlines, andeffecting continuous software process improvement.7. enforce compliance with contractual terms and conditions for use of software, including copyright andlicense agreements. centralize this function to the maximum extent practicable.8. use commercial fourthgeneration programming languages (4gls) where appropriate, when theyprovide significant improvements in productivity, usability, maintainability, and portability. selectionof 4gls and associated tools must be based on established acceptance in the commercial marketplacewhere benefits of the technology have been demonstrated. any software code generated using a 4glmust also be maintained in the 4gl.9. use the highestlevel language meeting quality, cost, and scheduling constraints for each softwarecomponent. principles for choice of this language are as follows:a. higherlevel languages are generally preferable to lowerlevel languages.b. standardized and nonproprietary languages are preferred. using standards increases portability ofcode and programmers. nonproprietary languages reduce the risk of vendor lockin.c. new languages must not be developed as part of a system development, except for domainspecificlanguages providing directives for application generators.d. quality, time, and cost factors should be considered in selecting a language.10. use the ada programming language (reference (i)) to develop software subsystems when all of thefollowing apply:a. the application is in a warfighting application area (i.e., weapon control, electronic warfare,wideband realtime surveillance, battle management, special battlefield communications).b. maintenance will be governmentdirected.c. the expected size of the subsystem exceeds 10,000 lines of code, or the subsystem is critical.d. there is no better cots, ndi, 4gl, or higherlevel solution consistent with quality and cost goals.e. there is no lifecycle costeffectiveness justification for using another programming language.f. the code is new or reengineered.appendix a77ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.in cases meeting the above criteria, the required compliance level is set at 95% of the source linesof code. up to 5% of the code can be written in other languages to facilitate component integration.11. when the application is in a nonwarfighting application area (e.g., office and management support,personnel, logistics, medicine, routine operations support), ada will be analyzed as an option whensubstantial 3gl development is to be performed. the analysis will be in accordance with theprinciples set forth in d. 9 above.e. responsibilities1. the under secretary of defense (policy) shall ensure that requests from dod components forguidance on international transfer or export of dod software are processed and appropriate guidanceon such release is provided.2. the office of the assistant secretary of defense (oasd) for c3i shall:a. provide policy, guidance, and oversight for the management of software consistent with applicabledirectives, and may issue additional instructions related to implementation of this directive.b. issue policies and guidance to implement dod software reuse practices and the federal softwareexchange program (reference (d)).c. direct dod components to establish programs, as appropriate, to enhance the software engineeringprocesses and the transition of technologies from commercial and research programs into applicationswithin weapon, automated information systems (aiss), and command and control systems.d. establish an osdlevel software engineering plan review (sepr) process that will review allsoftware architecture plans for any acquisition subject to osd milestone decision authority (mda).the purpose of this review will be to approve and certify the software engineering plans for the systemsoftware prior to milestone i and ii reviews. certification indicates that the software plan conforms tothe policy and principles contained within this directive. for these reviews, the acquisition programshall establish a programspecific software engineering plan review board (seprb). the seprbwill be composed of at least 5 members who are software experts, will include key systemstakeholders (e.g., users, maintainers, interoperation experts), and will be chaired by a representativeof the oasd (c3i).e. establish a process for periodic review of seprb reviews performed by dod components.f. identify research and development requirements to the director, defense research and engineering,for inclusion in research and development programs.3. the head of each dod component shall:a. initiate appropriate strategies and actions to implement the policies in section d within their areas ofresponsibility.b. establish a componentlevel sepr process that will review all software architecture plans for anyacquisition subject to component mda. the purpose of this review will be to approve and certify theplans for the system software prior to milestone i and ii reviews. certification indicates that thesoftware plan conforms to the policy and principles contained within this directive and applicablecomponent policies. for these reviews, the acquisition program shall establish a programspecificseprb. the seprb will be composed of at least 5 members who are software experts, will includekey system stakeholders (e.g., users, maintainers, interoperation experts, program executiveofficials), and will be chaired by a member appointed by the service or component acquisitionexecutive.appendix a78ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.c. establish and monitor a sepr process for nonmda dod componentdirected software, and asappropriate for other dod component software.d. delegate to appropriate subordinate organizations the authority to release software assets, asappropriate, to the federal software exchange program (fsep), reference (d), and for dod reusepurposes.e. specifically address investment strategies, including use of modern software technology and thetransition to newer technologies, in the dod component planning, programming, and budgetingprocess.f. effective date and implementationthis directive is effective immediately.g. references:(a) department of defense (dod) directive 3405.1, "computer programming language policy," april2, 1987 (hereby canceled)(b) assistant secretary of defense for command, control, communications and intelligence (c3i)memorandum, "delegation of authority and clarifying guidance on waivers from the use of theada programming language," april 17, 1992 (hereby canceled)(c) dod instruction 7930.2, "adp software exchange and release," december 31, 1979 (herebycanceled)(d) federal information management regulation (firmr) subpart 20124.201, federal softwareexchange program(e) dod directive 8000.1, "defense information management program," october 27, 1992(f) dod directive 5000.1, "defense acquisition," march 15, 1996(g) dod instruction 5000.2, "defense acquisition management policies and procedures," march 15,1996(h) dod directive ts3600.1, "information warfare," december 21, 1992(i) international organization for standardization (iso/iec 8652:1995), "ada," february 15, 1995(j) dod directive 5200.28, "security requirements for automated information systems (aiss)," march21, 1988(k) dod regulation 5200.1r, "information security program regulation," december 1987, authorizedby dod directive 5200.1, "dod information security program," june 7, 1982(l) dod 7000.14r, "dod financial management regulation," volume 2, "budget presentation andformulation," may 1994, authorized by dodi 7000.14, "dod financial management policy andprocedures"appendix a79ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.appendix btechnical descriptions of ada and other thirdgenerationprogramming languagesthis appendix gives technical and historical descriptions of ada and the most often cited thirdgenerationprogramming languages (3gls)c and c++and a new 3gljavathe focus of rapidly growing interest in theprogramming community and a potential candidate for replacing c, c++, or ada in certain application domains.these descriptions are followed by a comparison of the languages in terms of their capability for ensuring highreliability and for supporting the requirements of longlived, embedded, realtime, and/or distributed systems.any software system can be implemented in essentially any reasonably complete programming language.however, languages vary with respect to how effectivelyin terms of cost, schedule, and level of riskthey supportthe programming of a solution that successfully achieves the required functionality and quality. the descriptionsbelow are intended to clarify such variations among languages. in contrast to the approach taken in the section inchapter 2 titled "software engineering process and architecture," architecture, design, and development andmaintenance processes here are held fixed; for the purposes of the discussion in this appendix, the onlyindependent variable is programming language choice. as pointed out in chapter 2, certain programming languagechoices may enhance the development and maintenance process itself, but that interaction is ignored for thepurposes of this comparison.ada 83ada 83 was the result of a requirementsdriven language design competition, beginning in 1975 with the first"strawman" requirements document, continuing through a series of requirements documents culminating in the"steelman" document, and resulting in a preliminary standard in 1980, an american national standards institute(ansi) standard in 1983, and an international organization forappendix b80ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.standardization (iso) endorsement of the ansi standard in 1987. the actual design work was performed by adesign team, with review by a panel of experts and the interested public at large.major concerns in the design of ada 83 were reliability, maintainability, human engineering, and efficiency.human engineering refers to choosing keywords, syntax, and semantics to maximize readability, while trying tominimize "surprise" and errorprone constructs. for example, all control flow constructs have a distinct "end"marker (e.g., "end if," "end loop"), and all program units allow the name of the unit to be repeated (and thecompiletime to be checked) at the end marker. parameters may be specified as "in," "out," or "in out" to indicatethe direction of information flow upon subprogram call. formal parameter names may be used at the call point toidentify unambiguously the association between formal and actual parameters.ada 83 supports strong type checking, extended to provide strong distinctions between otherwise structurallyequivalent numeric types, as well as between otherwise structurally equivalent array types and pointer types. ada83 is unusual in that it allows the programmer to distinguish two samesized integer types as representing distinctabstractions, and to specify that an array is meaningfully indexed by one, but not the other, or that a subprogramcan meaningfully be passed by one, but not the other. for example, the two integer type declarationstype monthnumber is range 1..12andtype hournumber is range 1..12introduce two distinct integer types, and the fact that they have identical ranges does not alter the fact thatthey are distinguishable at compiletime when used as array indices, subprogram parameters, and recordcomponents. the compiler will detect the use of a value of one type when the other is expected. furthermore, achange to one, such as switching hournumber to be range 0.23, does not have an unintended effect on someother abstraction.ada 83 supports data abstraction, modularity, and information hiding through a module construct called a"package" and through "private" types, types whose internal structure is hidden from code outside the definingpackage. objects, subprograms, and any other language entity may be declared in the private part or body of apackage, thereby hiding it from external access, and allowing revision during maintenance without disturbingexternal clients of the package.program units may be separately compiled while preserving full compiletime consistency checking acrossunits. all program units may have a separate specification and body, allowing the physical configuration controlof interfaces to allow productive parallel development of large systems, and enabling interface integrity to beverified before, rather than after, the code is developed.packages and subprograms may be defined as "generic" units, which are parameterized by types, objects, andsubprograms. such generic units must be explicitly instantiated with appropriate actual parameters prior to use.like other units, generic units have a separate specification and body. when a generic unit is compiled, it ischecked for legality. further checks are performed when the unit is instantiated.ada 83 defines a complete set of runtime consistency checks to enforce range constraints on numeric types,index constraints on array types, and "discriminate" constraints on other composite types. in addition, all pointersare default initialized to null, and checked for null prior to dereferencing. ada 83 defines an ability to raise andhandle runtime exceptions. the predefined runtime checks all raise such runtime exceptions, allowing theprogrammer to write faulttolerant code that catches unanticipated software problems, and performs appropriaterecovery or disciplined shutdown actions.ada 83 includes a standard multithreading model, with a rendezvous construct to support inter threadingcommunication and synchronization. explicit delays are supported, as is timedappendix b81ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.rendezvous. finally, ada 83 includes constructs for explicit user control over representation of types, as well as a"pack" directive to influence the compiler's selection of representation.ada 95the current ada standard, ada 95, was developed between 1990 and 1995. as with ada 83, the developmentwas performed by a language design team, and requirements and review were provided through an open forum. infebruary 1995, the revised language was approved as an iso standard, replacing the former edition of thestandard. the overall goal of the ada 95 design process was to maintain the reliability, maintainability, humanengineering, and efficiency of ada 83, while enhancing the flexibility and extensibility of the language, and theprogrammer's control over storage management and synchronization.ada 95 generalized the type definition mechanisms of ada 83 to allow a type to be defined as an "extension"of another type, and to treat a type and all its extensions, direct and indirect, as a "derivation class" of types, with"classwide" operations and dynamically bound implementations of operations. added to the existing support forabstraction and modularity, type extension and dynamic binding give ada 95 support for the objectorientedprogramming paradigm.ada 95 also enhanced the multithreading model, by providing "protected objects" that allow the programmingof dataoriented synchronization mechanisms, without introducing additional threads.ada 95 added support for pointers to subprograms, as well as pointers to declared, as opposed to heapallocated, objects. all access types include an "accessibility" level, which is checked by the implementation,generally at compiletime, to prevent the creation of dangling references.the numeric model was enhanced with the addition of modular (unsigned, wraparound) integers with bitwiselogical operators, and decimal fixedpoint types, to support exact financial calculations.the generic facility was enhanced to allow parameterization by packages that are instances of other generics,so that layered generic abstractions may be defined. in addition, the generic "contract" model was strengthened sothat the legality of an instantiation is fully determined by the actual parameters and the generic specification,allowing the body of the generic to be altered during maintenance without endangering the legality of existinginstantiations.where appropriate, additional runtime checks were defined in ada 95 to support the enhanced features. inparticular, a conversion from a classwide type to an extension of its root type involves a runtime check to ensurethat the conversion is meaningful, as does a conversion from an "anonymous" access type to a named access typeto prevent the creation of a dangling reference (based on the "accessibility" level mentioned above).in addition to these syntactic and semantic enhancements to the language, a number of additional standardpackages, pragmas, and attributes are defined in "annexes" to the standard. some of these packages, pragmas, andattributes must be supported by all implementations, such as packages for string manipulation and random numbergeneration and pragmas for interfacing to other languages. others are specifically designed to support particularapplication domains, such as realtime, distributed systems, and safety/securitycritical systems.cthe c language was designed at bell laboratories in the early 1970s, as a successor to the language bcpl,for the purpose of writing an operating system (unix) and associated utilities for minicomputers. during the late1970s, c and unix were used widely in universities, and during the 1980s c emerged as the language of choice forsystems programming on minicomputers, workstations,appendix b82ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.and personal computers. the ansi standard for c was approved in 1989, and the iso standard based on ansi cwas approved in 1990.c has a sparse syntax, with braces used for begin and end markers in all control flow, program unit, and typedeclaration constructs. singlecharacter operators are provided for assignment, indirection, addressof, bitwiseand, or, "xor," and not, and the usual arithmetic operations. operators are also provided for pre and postincrement and decrement, operateandassign, and left and rightshift.numeric data types are selected by names, such as "short int" or "long float." there is no capability to select anumeric type by required range or precision, and there is no notion of implementationenforced range constraint.enumeration data types are supported, but are implicitly convertible to and from integer types in any context.historically, interface definitions have not been necessary for c functions, with the default being that afunction returns an "int" and takes any number of parameters. ansi c introduced the notion of a function"prototype" to specify the function interface, and some implementations can be directed to require the presence of aprototype for all functions.all arrays are indexable by any integer or enumeration type; all arrays have a low bound of zero, and a highbound of one less than the specified size. no bounds information is carried with array parameters, and no boundschecking is defined by the language standard, although some tools exist that will check for outofboundsreferences. arrays are treated by the language as essentially constant valued pointers, and array indexing is definedin terms of an indirection applied to the addition of a pointer and an integer index.strings in c are represented by a pointer to their first character, with a null character used by convention tosignify the end of the string. there is no languagedefined checking for running off the end of a string.recordlike "structs" are supported, but there is no languagedefined data abstraction mechanism. opaque,incomplete pointer types can be used to provide some degree of data abstraction. a "union" construct allows thecreation of an undiscriminated union of types. there is no languagedefined check for accessing the "wrong"member of a union.the "cast" construct may be used to explicitly convert between numeric types (although implicit conversionis performed as part of a function call, and implicit widening is performed during arithmetic). the cast constructmay also be used to convert between pointer types, or between an integer and a pointer type. there is nolanguagedefined check associated with a cast.no default initialization is defined by the standard for local variables; pointers, in particular, are not defaultinitialized. no nullchecking is defined for pointer indirection.there is no languagedefined construct for raising and handling exceptions, although there are standardfunctions for sending and handling "signals," which can be used to emulate exceptions in certain circumstances.c provides some control over representation by the use of bit field indicators on "struct" components.however, it does not define the ordering of bit fields within a word. some implementations provide "pack"pragmas or other means of providing more representation control.there is no languagedefined "module" construct other than a source file; objects and functions declared"static" are local to the source file. objects and functions not declared "static," when defined at the top level, areexternally visible from any other file that includes an "extern" declaration for the entity. by convention, the"extern" declarations for a source file, and associated type definitions, are usually grouped into a header file (".h"file), which can be textually included ("#include") in any source file requiring access to the type, object, orfunction.c includes a standard preprocessor that supports textual include, conditional compilation, and parameterizedtextual macros.appendix b83ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.the ansi c standard includes a full set of library functions to support string manipulation (where a string is anullterminated array of characters), random number generation, and input/output, among others.c++the c++ language was first released in 1983 as an enhancement to c, with the major enhancement being theaddition of a "class" construct inspired by the samenamed feature of the language simula67. the language wasinitially defined by the implementation available from at&t ("cfront") that translated c++ to c. cfront, andhence c++, went through several major updates that added features such as multiple inheritance, generictemplates, and exception handling. in the early 1990s, ansi and iso committees were formed to produce astandard for the language. a few additional features, such as runtime type identification and "namespaces," havebeen added during the standardization process. approval of the iso c++ standard is expected within the nextyear.c++ includes all the features of c, although some features are revised to be more strongly typed. forexample, enumeration types in c++ are implicitly convertible to integer types, but not implicitly convertible back.also, function prototypes are required for all c++ functions. c++ adds to c support for data abstraction, typeinheritance, and dynamic binding (virtual functions). two kinds of multiple inheritance are supported: the defaultinheritance replicates the fields if the same base class is inherited through multiple paths, and the virtualinheritance shares fields if the same base class is inherited through multiple paths.c++ also supports a generic template facility. no checking is defined for templates prior to instantiation;there is no template "contract" model. instantiation is implicit by referring to an instance via"templatename8parameters>." template functions are also supported; instantiation of a template function isautomatic at a call, with the template parameters determined implicitly by the types of the call parameters.c++ supports "throw"ing and "catch"ing exceptions. exceptions can be represented by objects of any type;the "catch" is based on a type matching. the standard c++ library defines certain exception types, instances ofwhich are thrown when an allocator fails to allocate storage, or when other errors occur.the array indexing and cast constructs inherited from c remain unchecked in c++. there are standardtemplates for defining checked arrays and checked casts. local pointers in c++ are not default initialized, andthere is no languagedefined check for dereferencing a null pointer. "smart pointer" abstractions can be developedto check for null pointers, or to implement persistence or similar capabilities.as in c, all numeric types are implicitly convertible on assignment and parameter passing, and implicitly"widened" in calculations.c++ supports information hiding through the notion of protected and private data and function members.private members are visible only inside a class (and to its "friends"). protected members are visible inside alldescendants of a class. c++ supports a multilevel namespace though a "namespace" construct, which provides noinformation hiding (there is no "private" part of a namespace) and is simply a hierarchical naming mechanism.javajava was developed over the past 5 years at sun microsystems. it was originally called "oak" and wasintended for use in small appliances, settop boxes, and other embedded applications. in aprilappendix b84ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.1995, a world wide web browser written in java, called hotjava, was announced by sun. hotjava had the abilityto download small programs written in java over the web and execute them in the context of a hypertext markuplanguage (html) page being displayed by the web browser. since then, sun's java technology has been licensedby essentially all other web browser developers, including netscape and microsoft, and has achieved widespreadattention for its potential to provide many of the capabilities of client/server systems without many of theattendant complexities.java is syntactically based on c++ but semantically is closer to modula3 or ada 95. it provides modularitythrough a combination of a "package" concept, which is a namespace with some information hiding associatedwith it, and the "class" construct, which is modeled closely on the c++ (and simula67) class construct. tosupport information hiding, methods (called "member functions" in c++) and data components may be marked aspublic, protected, or private, much as in c++, but with the added notion that, by default, methods and data arevisible only to classes within the same package. unlike c++, there is no textual "include" in java; instead,individual classes, or a whole package of classes, are explicitly imported using an "import" statement at the top ofthe source file defining a class.all code and objects in java must be inside some class. the methods of a class are by default "virtual" injava; calls to such methods are "dynamically" bound. methods may be explicitly specified as "static"; calls to suchmethods are "statically" bound. the data components of a class are by default "perinstance," as in c++. datacomponents may be marked "static," which means that they are "statically" allocated and shared across the class,rather than one per instance.java fully supports single inheritance between classes. by default a class inherits from the single "root" typecalled "java.lang.object." alternatively, it may explicitly specify one parent class from which it inherits nonstaticmethods and data components. java provides a limited kind of multiple inheritance through the concept of an"interface" type: a list of methods that any "implementer" of the interface must provide. a class may specify anynumber of interface types that it claims to "implement." the compiler verifies that the methods required by eachidentified interface are present in the class. there is no separate specification for a class (other than that providedby interface types it implements). there is no separate "prototype" for a method of a class. a tool may be used toextract the documentation and specification for class.java has no direct support for enumeration types. named integer constants may be used, but the compilerprovides implicit widening between integer types on assignment and parameter passing and allows any integertype to index any array. arrays in java are indexed from zero, as in c and c++, but unlike c or c++, theirsemantics are not defined in terms of pointer arithmetic. in fact, java does not support pointer arithmetic. arraysare first class types, and carry a length at runtime against which all indexing is checked.pointers ("references") in java are default initialized to null, and all pointer dereferences are checked for null.conversions between references are checked at runtime for meaningfulness.java has exceptions, much as in c++, except that it enforces compatibility and completeness of "throw"signatures at compiletime (c++ enforces "throw" signatures at runtime). failures of runtime checks, such as anarraybounds check, or a nullpointer check, result in a "throw" of a predefined exception. runtime errorexceptions do not need to be mentioned in a "throw" signature; other exceptions, including userdefinedexceptions, do need to be mentioned in the "throw" signature of a method if it is going to throw or propagate theexception.java has no generic templates; the root type java.lang.object can be used in some contexts to define(heterogeneous) "generic" data structures. proposals exist to add a parametric polymorphism facility to java,which could provide some of the added compiletime type checking associated with "homogeneous" datastructures provided by the generic template features of ada and c++.java has largely the same control flow constructs as c++. as in c and c++, switch statements rely on aprogrammerinserted "break" to terminate a case. java defines a special type "boolean" and requires a value ofboolean type in the expression of an "if," "while," or "for" test. there is no implicitappendix b85ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.conversion to "boolean"; the relational operators return boolean, as do the logical operators. the operator "=" isfor assignment; "==" is for equality. a "break" or "continue" statement may have an identifier to identify theparticular construct being exited or continued, providing some additional flexibility and maintainability relative toc and c++.all class and array instances are allocated dynamically on a garbage collected heap. that is, there are no"stackresident" arrays or class instances. all implementations of java provide a garbage collector. there are noclass instances "nested" inside other class instances, only references to dynamically allocated class instances. thesame goes for arrays.there is no user control over representation of data objects. there is no user control over storagemanagement, other than a system method to force a garbage collection.java has a large standard library of classes and includes support for multithreading through a combination of astandard thread class and the notion of "synchronized" methods.domainspecific comparisonin comparing the features of ada, c, c++, and java, various principles underlying each language can beidentified.with c, the underlying goal is to provide reasonable portability (certainly when compared with assemblylanguage) while giving the programmer full control of the machine. there is little attempt to provide strongconsistency checking at compiletime, and no notion whatsoever of runtime checking built into the language(other than via use of the standard "assert" macro).c++ provides more tools for defining abstractions, and increases the strength of the type checking onenumeration types. however, the default runtime behavior in c++ is still inherited from c, which means no runtime initialization or checking of pointers, no checking of array indexing, and no notion of range checking. thedefault conversion syntax, the simple "cast" inherited from c, does no checking. the basic primitives of c++remain unsafe, although there are additional mechanisms available for creating safe abstractions.java takes the route of strongly enforcing runtime consistency, with all the necessary checks to ensure that aprogram does not corrupt data outside its prescribed space, including pointer initialization and null checking,arraybounds checking, and conversion checks. however, at compiletime, java has essentially gone one stepbackward from c++ by dropping support for enumeration types, thereby eliminating an important source ofcompiletime consistency checks. java very successfully creates a language that prevents code from corruptingdata outside its purview, but it fails to provide tools for supporting thorough compiletime enforcement of interfaceconsistency.a second area of concern with regard to use of java for critical systems development is that it is inextricablytied to a dynamic storage allocation model. garbage collection is certainly less errorprone than is manual storagereclamation, but any use of dynamic storage allocation opens up the possibility of eventual storage exhaustion, asdoes dynamic stack extension. for an embedded or critical system, it is standard practice to require that all storagebe allocated statically (at link time), including the stacks for all threads of control; recursion is also disallowed.in comparison to the above languages, ada 83 and ada 95 attempt to provide more features to makecompiletime consistency checking useful for finding mistakes, backed up by runtime consistency checks forcases in which only a dynamic check is meaningful. as mentioned above, ada is one of the few languages thatallows the programmer to create strong distinctions between structurally equivalent numeric, array, and pointertypes. these distinctions allow an ada interface to capture more of the semantics, and allow the ada compiler tocatch more mistakes in the use of an interface. the last decade has seen an explosion in the number of applicationprogramming interfaces (apis) used to build systems. inappropriate uses of an api are among the most commonmistakes in such systems. by creatingappendix b86ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.stronger distinctions between numeric, enumeration, array, and pointer types, an ada version of an api can reducethe likelihood of inappropriate use, and identify more such errors at compiletime.at runtime, ada has pointer default initialization, pointer null checking, array bounds checking, with usercontrol over both the low and high bound, and conversion checking. in addition, ada provides range checking,variant record checking, and, in ada 95, both compiletime and runtime checks designed to eliminate "dangling"references associated with pointers to deallocated stack variables. this set of "dangling reference" checks("accessibility checks") allows an embedded or critical program to avoid completely the use of dynamic storageallocation, while still providing the convenience of using pointers.both ada and java have support for multithreaded applications as a standard, portable part of the language,whereas c and c++ support multithreading generally through operatingsystemdependent libraries. the adamultithreading support includes various realtimeoriented features, such as timed entry calls and selective acceptswith delay alternatives, whereas java has only a basic timed "sleep" operation. to the basic ada 83 multithreadingsupport, ada 95 adds protected objects, which are designed to support realtime systems by reducing overhead,minimizing "priority inversion," and generally improving predictability of thread synchronization. java'ssynchronized methods, with wait/notify operations, provide similar capability, although with less encapsulation ofthe fields requiring synchronized access, a more raceprone "notification"oriented synchronization model, and noparticular concern for priority inversion.although ada is a generalpurpose 3gl, it was designed with extra attention to the concerns of realtime,embedded, and critical systems developers, namely very thorough consistency checking, mechanisms to support avery "static" storage allocation model, and multithreading support with time and prioritycognizant constructs. assuch, at a technical level, it is a better fit to the needs of dod critical and embedded systems development than arethe other languages in widespread commercial use. these reliabilityoriented features of the ada language makedevelopment and maintenance more costeffective, when cost to achieve the required level of quality and correctfunctionality is included. of course, there are other nontechnical issues involved in language choice (as discussedin chapter 1), and other nonlanguage issues involved in managing successful software development (discussed inchapter 2).appendix b87ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.appendix capplicationprogramminginterface (api)a set of procedure and function specifications providing access to the capabilities of a reusablesoftware component, such as a "windowing" or network communication operating subsystem.architecture.the structure of a system's components and connectors, their interrelationships, and theprinciples and guidelines governing their design and evolution over time.automatedinformationsystem (ais).a combination of computer hardware and computer software, data, and/or telecommunicationsthat performs functions such as collecting, processing, transmitting, and displaying information.the function of such systems is primarily administrative. excluded are computer resources, bothhardware and software, that are physically part of, dedicated to, or essential in realtime to themission performance of weapon systems; used for weapon system specialized training,simulation, diagnostic testing and maintenance, or calibration; or used for research anddevelopment of weapon systems.commercial item.an item regularly used in the course of normal business operations for other than governmentpurposes that has been or will be sold or licensed to the general public, and that requires nounique governmentdirected modifications or maintenance over its lifecycle to meet the needsof the procuring agency.commercial offtheshelf (cots)software.cots software products are commercial items that have been sold, leased, or licensed in aquantity of at least 10 copies in the commercial marketplace, at an advertised price. cotssoftware products include a description or definition of the functions the software performs,documented to good commercial standards, and a definition of the resources needed to run thesoftware.appendix c88ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.domain.a distinct functional area that can be supported by a class of systems and assets with similarrequirements and capabilities.fourthgenerationprogramminglanguage (4gl).a 4gl differs from a thirdgeneration programming language (3gl) in that it removes the needfor a programmer to explicitly make many of the design decisions about data structures andalgorithms. 4gls allow programmers to express instructions in terminology and at a level ofabstraction that are natural for communication between humans who are familiar with theapplication domain. the programmer interaction may even be in a graphical, or menubased,form. 4gls typically incorporate domainspecific knowledge and notation, and so are not"generalpurpose" in the sense that 3gls are, although they may include a 3gl component thatpermits generalpurpose programming. 4gls are associated with "frameworks," "templates,""automatic program generators," "middleware," and "graphical user interface builders." someexamples of 4gls are visual basic, powerbuilder, delphi, and sql.function point.a measure of software functionality that is independent of differences in lines of code requiredto implement a given function in different programming languages.glue code.the relatively small parts of computer programs, or operating system "shell" scripts, that arewritten to integrate nondevelopmental items into a larger system, without modification to thecomponents themselves.governmentdirected softwaremaintenance.maintenance required for software changed in response to government specification ordirection. governmentdirected maintenance may be done by the government or by acommercial organization paid by the government. in contrast, with vendordirectedmaintenance, a vendor chooses which changes are made to the software, and when they will bemade.nondevelopmentalitem (ndi).any software asset that is available in the commercial marketplace; or any software asset that isavailable to the public for free use; or any previously developed software asset that is in use by adepartment or agency of the united states, a state or local government, or a foreign governmentwith which the united states has a mutual defense cooperation agreement.product line.a set of similar products or a family of systems that share common architectures and satisfy themission requirements of one or more domains.reengineering.the process of examining and altering an existing system to reconstitute it in a new form. reengineering may include reverse engineering, restructuring, redocumenting, forwardengineering, retargeting, or translation.reuse.the process of developing or updating a softwareintensive system using existing softwareassets.software asset.any softwarerelated product of the software lifecycle.softwareengineeringenvironment.the set of tools (including supporting hardware, software, and "firmware") used in theproduction and maintenance of software throughout its lifecycle. typical elements includecomputer equipment, compilers, operating systems, "debuggers," simulators, emulators,computeraided software engineering tools, and database management systems.softwaremaintenance.maintenance of software includes, but is not limited to, activities generally referred to asenhancement, evolution, postdeployment software support, or error correction.software metrics.quantitative values used to make an assessment of software condition, products, or processes.representative metrics are effort, schedule, cost, quality, size, and rework.standardsbasedtechnicalarchitecture.an architecture that defines the standards, services, topology, data definitions, and commonframework that enable systems developed to the architecture to interoperate.thirdgenerationprogramminglanguage (3gl).thirdgeneration programming languages generally differ from secondgeneration languages inbeing machineindependent, providing built in control structures, and supporting user definitionof abstractions, including subprograms and data types. they differ from fourthgenerationlanguages in continuing to require the programmer to deal explicitly with the design of datastructures and algorithms. some examples of 3gls are ada, c, c++, cobol, fortran, java,jovial, pascal, and smalltalk.appendix c89ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.warfightingsoftware.there are two primary criteria for determining whether a subsystem belongs in the "warfighting"category: 1. relatively little commercial software and expertise is available for implementing thedesired functions. for example, even though intelligence analysis is involved in warfighting,many of its functions (database update, query and visualization, report generation) can be readilysatisfied via nonwarfighting commercial software. 2. the application requires software qualityattribute levels higher than those supportable by commercial software. for many warfightingfunctions, these involve realtime performance, reliability, and survivability, particularly inhighstress, crisismode situations in which dod information processing functions may beunder attack. the application domains for warfighting software include, but are not necessarilylimited to, the following areas:  weapon control, which includes software involved in weaponsensor processing; guidance, navigation, and control; combatoriented weapon delivery platformcontrol; and software for special weapon delivery platform operator devices such as headsupdisplays. weapon control does not include administrative functions and "hotel services" for largeweapon delivery platforms such as aircraft carriers, or support subsystems performingmainstream data management, networking, and graphical user interface functions.  electronicwarfare, which includes software involved in rapidresponse electronic detection, identification,discrimination, tracking, platformbased communication, and associated countermeasure/countercountermeasure applications, but does not include support subsystems performingmainstream data management, networking, and graphical user interface functions.  widebandrealtime surveillance, which includes software involved in hard or soft realtime image,infrared, radar, or other sensor processing, but does not include offline query and analysis ofsurveillance archives or support subsystems performing mainstream data management,networking, and graphical user interface functions.  battle management and battlefieldcommunication, which includes hard or soft realtime weapons allocation, targeting, control,coordination, damage assessment, and associated battlefield communications requiring suchspecial capabilities as spread spectrum, antijamming, and frequencyhopping, but does not include offline monitoring, update, query, and analysis of battle assetstatus, or offbattlefield communications. thus, the range of"warfighting command, control, andcommunications (c3i) applications" is narrower than previous categorizations such as "c3i" or"missioncritical."the scope of warfighting applications also does not include associated support software for test, simulation,training, offline analysis, maintenance, and diagnostics.appendix c90ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.appendix ddetailed comparisons of ada and other thirdgenerationprogramming languagesthis appendix presents details of studies, summarized in chapter 2 in the sections titled "analyses oflanguage features" and "comparisons of empirical data," that have analyzed the technical features ofprogramming languages and have used empirical project data to compare languages' relative strength with respectto desired characteristics. given the unscientific nature of most of the data, no strong conclusions are warranted.but in a general sense, most experience with ada supports the conclusion that it benefits dod warfightingapplications; few data were found to refute such a conclusion, although the absence of such data may reflect a lackof any organized effort to promote the use of languages other than ada in warfighting systems.evaluations of language featuresa 1985 federal aviation administration (faa) study compared ada with four other languages byconducting expert evaluations based on 48 technical language features arranged in six categories, and combiningthe evaluation results with the results of performance benchmark test results (ibm, 1985). a followon study wasconducted by the software engineering institute (sei) in 1991 using the same expert evaluation methodology asthe original study to compare ada 83 with c++, but without the benchmark tests (weiderman, 1991). the studies,the results of which are presented in table d.1, compared the languages against the maximum possible scores foreach of the six categories, which can be summarized as follows: capabilityšfacets of the implementation language relevant to programming or software engineering; efficiencyšfactors relevant to optimization of generated code and runtime utilization of resources;appendix d91ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved. availability/reliabilityšfactors influencing daytoday safety of operational systems; maintainability/extensibilityšfactors influencing longterm viability of operational systems; lifecycle costšelements of cost associated with or affected by the implementation language; and riskšareas of uncertainty or concern associated with or affected by the implementation language.table d.1 language functionality attributesfaa/ibm studysei studylanguageattributesmaximumscoreada 83cpascaljovialfortranada83c++capability16.716.19.610.47.63.915.311.3efficiency16.48.011.810.811.011.110.710.9availability/ reliability22.621.511.614.515.610.319.112.6maintainability/extensibility17.414.010.212.26.88.313.611.4lifecycle cost11.38.27.47.84.95.28.48.0risk15.68.88.97.69.68.211.79.8total100.076.659.563.355.547.078.864.0sources: federal aviation administration (faa)/ibm data from ibm (1985); software engineering institute (sei) data from weiderman(1991).ada scored the highest overall in both studies. it scored the highest in each individual category, except forefficiency, where it was ranked last, and risk, where it was ranked first in the sei study and third in the faastudy.project evaluation datain comparisons of ada with other programming languages in actual development projects, empirical data oncharacteristics such as expressibility, maintainability, defect rates, reusability, and cost factors are of particularinterest. since ada has been used in relatively large programs, a larger proportion of data has been collected forada than for contemporaneous commercial programming languages like c and c++.much of the data are subjective in nature, and care must be taken in drawing conclusions from such studies.for instance, the data in table d.2 are confounded by differences in the expressive power of a source line of codein different programming languages. one way of normalizing uses tables of source lines of code per functionpoint (jones, 1995). however, as shown in table d.2, these ratios have wide variability. lubashevsky (1996)reports variations in source lines of code per function point exceeding factors of 2 for c and 6 for c++. finally,there are differences in expressiveness for the same language across different application domains.appendix d92ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.table d.2 source lines of code per function pointlanguagelowmeanhighada 83607180c60128170c++3053125source: data from jones (1995).opensource datathe verdix ada development system (vads) data (zeigler, 1995) covers a period of approximately 10years of development and enhancement of vads compilers, debuggers, builder tools, and runtime supportsystems using both c and ada. table d.3 summarizes the comparative c and ada experience data over thisperiod.zeigler analyzed potential confounding effects of relative c and ada software complexity, personnelcapability, and learning curve effects and found that these factors did not cause any significant bias. the studythus provides a strong case that ada was significantly better than c, in terms of both lifecycle cost and freedomfrom defects, for this large (over 1 million lines of both ada and c) project in the compiler and tools area.however, the study can only be suggestive rather than definitive about the applicability of this result to otherdomains and other teams (the verdix teams were both composed of highcapability, lowturnover personnel).since 1976, nasa's software engineering laboratory (sel) has been carefully collecting software data onnonembedded, nonrealtime satellite flight dynamics software. figure d.1 (mcgarry et al., 1994) summarizessel's history of development error rates over this period. the data show a significant general decrease in errorrates over the period, due to such techniques as code reading, systematic testing, and cleanroom techniques. thedata from 1988 to 1994 also show significantly lower error rates for ada than for fortran, measured per 1,000lines of delivered code, or kdloc (an average of 2.1 defects/kdloc for ada vs. 4.8 defects/kdloc forfortran). sel's analyses for ada initially concluded that owing to reuse, ada projects experienced significant costand schedule reductions compared to fortran projects. subsequently, however, the ada objectoriented reuseapproach was applied to fortran projects, resulting in comparable gains.proprietary datathis section summarizes proprietary data from reifer (1996) and jones (1994) that compare ada to otherprogramming languages with respect to cost, delivered defects, reliability, and productivity. because the sourcedata and detailed analysis are unavailable, these results are difficult to assess.costdata on cost, reliability, and maintainability have been compiled in a proprietary database of outcomes of 190software projects 3 years old or less (reifer, 1996). these projects were written in ada 83, ada 95, c, c++, andother thirdgeneration programming languages (3gls, such as cobol or fortran) and were compared to a norm foreach domain, drawn from a database of over 1,500 projects 7 years old or less.appendix d93ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.table d.3 verdix ada development system development datacharacteristiccadascript filesother filestotalstotal lines1,925,5231,883,751117,964604,0784,531,316sloca1,508,6951,272,771117,964604,0783,503,508files6,0579,3852,8153,65321,910updates47,77534,51612,96312,189107,443new features26,48323,0315,5946,14561,253fixes/feature.52.25.82.17.41fixes/kslocb9.214.5939.021.757.25cost/sloc$10.52$6.62$15.38$3.72$8.10defects/ksloc.676.096n/an/a.355a sloc: source lines of code.b ksloc: 1,000 sloc.source: zeigler (1995).reifer's project cost data, shown in table d.4, indicate that, in general, ada, c, and c++ programs were lessexpensive per delivered source line of code (sloc) than other 3gl programs or the domain norm for militaryapplications, although c and c++ programs were less expensive than ada programs in all military domains exceptairborne and spaceborne weapons systems. in commercial domains, the development cost of c and c++ code wasagain less than or equivalent to the cost of ada, and ada was roughly equivalent in cost to other 3gls and thedomain norms. however, the wide variations in expressive power of a line of code in ada, c, and c++ (seetable d.2) tend to overshadow the cost/sloc differences shown in table d.4.another study used telecommunications systems to evaluate objectoriented programming languages (jones,1994). the study used as a baseline a private branch exchange switch software application of 1,500 function pointsin size, compared across several telecommunications companies. based on these data, table d.5 shows the cost ofdeveloping the project in different languages, in dollars per function point. the results indicate that, in thisdomain, coding in c++ was less expensive than coding in ada, while using c was more expensive.delivered defectsreifer's (1996) data, shown in table d.6, indicate that in the 190 software projects represented, ada code hadfewer delivered defects than c and c++ code, which, in turn, had fewer defects than other 3gls. in command andcontrol and telecommunications applications, the difference between ada and c/c++ was smaller than thedifference between c/c++ and other 3gls and the norm. in commercial products, information systems, andweapons systems, ada code clearly had fewer defects than code in c, c++, and other 3gls.based on jones's (1994) data, table d.7 indicates that, for telecommunications applications, the reliability indelivered defects per function point was roughly equivalent for c++ and ada, and higher for c code.appendix d94ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.figure d.1 nasasel development error rates. kdloc: 1,000 delivered lines of code. (reprinted by permissionfrom mcgarry et al. (1994). copyright 1994 by carnegie mellon university.)appendix d95ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.table d.4 cost data by language (dollars per delivered source line of code)application domainada 83ada 95cc++3glnormcommand & controlcommercial50n/a40355045military75n/a757010080commercial products353025304040information systemscommercialn/an/a25253030military303525254035telecommunicationscommercial55n/a40455050military60n/a50509075weapons systemsairborne & spaceborne150n/a175n/a250200groundbased80n/a655010075source: reprinted from reifer (1996).table d.5 telecommunications project costs by language (dollars per function point)assemblycchillpascalada 83 ada 9xac++smalltalkcostb5,5472,9662,2601,9931,7601,5331,1801,007a ada 9x figure based on simulation.b at a monthly salary rate of $10,000.source: data from jones (1994).the fairly consistent factorof10,000 relationship between the data on cost per function point shown intable d.5 and the data on defects per function point shown in table d.7 suggests that jones's cost and defect dataare highly correlated to some third factor. this third factor appears to be the mean sloc/function point ratio fromjones (1995), shown in table d.2. comparing these ratios across c, ada, and c++ indicates that they areapproximately, although not exactly, equal, as shown in table d.8.reliabilitydata from reifer (1996) in table d.9 indicate that the incidence of failure for ada programs was lower thanthat with c, c++, and other 3gls. the outcome of this reliability comparison is similar to the defect comparison;ada was superior to c and c++, which were better than other 3gls.appendix d96ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.table d.6 delivered defect data by language (postdelivery errors per ksloca)application domainada 83ada 95cc++3glnormcommand & controlcommercial1.5n/a1.91.52.72.5military0.7n/a1.01.22.32.0commercial products2.83.55.03.04.54.0information systemscommercial4.0n/a7.05.17.07.0military3.0n/a6.04.06.06.0telecommunicationscommercial1.6n/a2.01.73.33.1military1.0n/a1.51.22.72.5weapons systemsairborne & spaceborne0.3n/a0.80.61.01.0groundbased0.5n/a0.80.71.01.0a ksloc: 1,000 source lines of code.source: reprinted from reifer (1996).table d.7 defects for telecommunications applications (delivered defects per function point)assemblycchillpascalada 83ada 9xac++smalltalkdefects0.520.290.230.200.170.150.140.13a ada 9x figure based on simulation.source: data from jones (1994).table d.8 correlation in function point (fp) measuressloca/fp (jones, 1995)dollars/fp (jones, 1994)defects/fp (jones, 1994)c/ada1.801.691.71c++/ada0.750.670.82a sloc: source lines of code.appendix d97ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.table d.9 reliability data by language (weeks until next major repair incidence)application domainada 83ada 95cc++3glnormcommand & controlcommercial3.0n/a2.5n/a2.02.5military4.0n/a3.0n/a2.02.5commercial products1.0n/a0.41.00.40.5information systemscommercial1.0n/a0.50.60.40.5military0.8n/a0.5n/a0.40.5telecommunicationscommercial3.0n/a1.02.01.51.8military4.0n/a2.03.02.02.0weapons systemsairborne & spaceborne8.0n/a3.0n/a2.52.5groundbased6.0n/a3.0n/a2.02.5source: reprinted from reifer (1996).productivityas described in chapter 2 in the section titled "software engineering process and architecture," one of thekey relationships in software development productivity is the relationship of development effort to program sizethat is, the value of the "process exponent." a mitre study (giallombardo, 1992) found substantialimprovements in productivity for large embedded military software developments provided by ada compared withother 3gls. the study found that effort, as measured by staffmonths required per 1,000 equivalent deliveredsource instructions (kedsi; which counts terminal semicolons rather than source lines of code), increased linearlyfor the large ada projects (process exponent close to 1). for large nonada projects, effort increased more thanlinearly; the increase in effort was also greater than that predicted by the cocomo model, which has a processexponent of 1.2 for embedded or very large systems (boehm and royce, 1988). the differences were clearest forsystem sizes greater than 100 kedsi (which the mitre study used as a definition of "large").in a study of telecommunications applications, jones (1994) compared the productivity of several 3gls,using function points per staffmonth as the metric. the results, presented in table d.10, indicate that, in thisdomain, c++ developments had a higher productivity rate than those using ada, while developments using c wereless productive than those using ada.table d.10 productivity for telecommunications projects by language (function points per staffmonth)assemblycchillpascalada 83ada 9xac++smalltalkproductivity1.803.374.425.015.686.528.479.99a ada 9x figure based on simulation.source: data from jones (1994).appendix d98ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.conclusionin summary, based on the results of currently available empirical data and feature analysis comparisons, aconclusion that ada is superior, with respect to availability/reliability and a lower incidence of defects, appearswarranted. the evidence is not strong enough to assert ada's superiority in the cost area. however, there is somepositive evidence in the cost area, and when it is combined with the anecdotal conclusions favoring ada (describedin "anecdotal experience from projects" in chapter 2) and the lack of solid evidence indicating less expensivecustom software development in other languages, a case can be made that using ada provides cost savings inbuilding custom software, particularly for realtime, highassurance warfighting applications.appendix d99ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.appendix ebriefings and position papers received by the committeebriefingswashington, d.c., april 1012, 19961. "charge to the committee," emmett paige, jr., assistant secretary of defense (command, control,communications, and intelligence), and cynthia rand, principal director for information management, office ofthe assistant secretary of defense (command, control, communications, and intelligence).2. "ada policy and reality," charles engle, director, ada joint program office.3. "dod programming language policy," linda brown, director, stars program, defense advancedresearch projects agency.4. "army policy on ada," robert schwenk, office of the director for information systems and command,control, communications, and computers, department of the army.5. "ada in crisis: the four horsemen," norman brown, dod software program managers network.6. "defense research & engineering perspective," anita jones, director, defense research & engineering.7. "weapons program perspective," radm k.k. paige, technical director, navy aegis program.8. "ada policy: viewpoint," christine anderson, chief, satellite control & simulation division, air forcephillips laboratory.appendix e100ada and beyond: software policies for the department of defensecopyright national academy of sciences. all rights reserved.9. "briefing to nrc ada study committee," dennis turner, director, software engineering, armycommunications electronics command.10. "the future of ada," robert mathis, executive director, ada resource association.11. "ada: a navy perspective," cdr gary evans, naval information systems management center.12. "asc perspective on ada," phil babel, air force aeronautical systems center.13. "joint strike fighter presentation," capt jules bartow, usaf, joint strike fighter program.14. "ada and f22," col robert lyons, usaf, joint strike fighter program.washington, d.c., may 2123, 19961. "perspectives on ada," jan lodal, principal deputy undersecretary of defense (policy).2. "transition of software projects from advanced development," larry lynn, director, defense advancedresearch projects agency.3. "ada," ike nassi, vice president, system software technologies, apple computer inc.4. "ajpo rationale," radm john gauss, commander, joint interoperability and engineering organizationand deputy director for engineering and interoperability, defense information systems agency.5. "ada policy," larry druffel, south carolina research authority, and john goodenough, softwareengineering institute.6. "command and control productlines," and "effect of ada on mitre supported esc programs," robertkent, director, software center, usaf electronic systems center, and steve schwarm, mitre.7. "intentional programming: innovation in the legacy age," charles simonyi, chief architect, microsoftresearch.8. "software at citicorp," gerald pasternack, citicorp.position papers1. "aia position statement on ada," aerospace industries association, july 12, 1996.2. "the ada mandate," edward feigenbaum, chief scientist, u.s. air force, 1996.3. "comments on ada mandate," huet c. landry, defense information systems agency/jebeb, softwareengineering standards, 1996.4. "whither ada?" victor vyssotsky, may 12, 1996.appendix e101